/* automatically generated by rust-bindgen 0.69.1 */

pub const FPDF_OBJECT_UNKNOWN: u32 = 0;
pub const FPDF_OBJECT_BOOLEAN: u32 = 1;
pub const FPDF_OBJECT_NUMBER: u32 = 2;
pub const FPDF_OBJECT_STRING: u32 = 3;
pub const FPDF_OBJECT_NAME: u32 = 4;
pub const FPDF_OBJECT_ARRAY: u32 = 5;
pub const FPDF_OBJECT_DICTIONARY: u32 = 6;
pub const FPDF_OBJECT_STREAM: u32 = 7;
pub const FPDF_OBJECT_NULLOBJ: u32 = 8;
pub const FPDF_OBJECT_REFERENCE: u32 = 9;
pub const FPDF_POLICY_MACHINETIME_ACCESS: u32 = 0;
pub const FPDF_ERR_SUCCESS: u32 = 0;
pub const FPDF_ERR_UNKNOWN: u32 = 1;
pub const FPDF_ERR_FILE: u32 = 2;
pub const FPDF_ERR_FORMAT: u32 = 3;
pub const FPDF_ERR_PASSWORD: u32 = 4;
pub const FPDF_ERR_SECURITY: u32 = 5;
pub const FPDF_ERR_PAGE: u32 = 6;
pub const FPDF_ANNOT: u32 = 1;
pub const FPDF_LCD_TEXT: u32 = 2;
pub const FPDF_NO_NATIVETEXT: u32 = 4;
pub const FPDF_GRAYSCALE: u32 = 8;
pub const FPDF_DEBUG_INFO: u32 = 128;
pub const FPDF_NO_CATCH: u32 = 256;
pub const FPDF_RENDER_LIMITEDIMAGECACHE: u32 = 512;
pub const FPDF_RENDER_FORCEHALFTONE: u32 = 1024;
pub const FPDF_PRINTING: u32 = 2048;
pub const FPDF_RENDER_NO_SMOOTHTEXT: u32 = 4096;
pub const FPDF_RENDER_NO_SMOOTHIMAGE: u32 = 8192;
pub const FPDF_RENDER_NO_SMOOTHPATH: u32 = 16384;
pub const FPDF_REVERSE_BYTE_ORDER: u32 = 16;
pub const FPDF_CONVERT_FILL_TO_STROKE: u32 = 32;
pub const FPDFBitmap_Unknown: u32 = 0;
pub const FPDFBitmap_Gray: u32 = 1;
pub const FPDFBitmap_BGR: u32 = 2;
pub const FPDFBitmap_BGRx: u32 = 3;
pub const FPDFBitmap_BGRA: u32 = 4;
pub const PDFACTION_UNSUPPORTED: u32 = 0;
pub const PDFACTION_GOTO: u32 = 1;
pub const PDFACTION_REMOTEGOTO: u32 = 2;
pub const PDFACTION_URI: u32 = 3;
pub const PDFACTION_LAUNCH: u32 = 4;
pub const PDFACTION_EMBEDDEDGOTO: u32 = 5;
pub const PDFDEST_VIEW_UNKNOWN_MODE: u32 = 0;
pub const PDFDEST_VIEW_XYZ: u32 = 1;
pub const PDFDEST_VIEW_FIT: u32 = 2;
pub const PDFDEST_VIEW_FITH: u32 = 3;
pub const PDFDEST_VIEW_FITV: u32 = 4;
pub const PDFDEST_VIEW_FITR: u32 = 5;
pub const PDFDEST_VIEW_FITB: u32 = 6;
pub const PDFDEST_VIEW_FITBH: u32 = 7;
pub const PDFDEST_VIEW_FITBV: u32 = 8;
pub const FORMTYPE_NONE: u32 = 0;
pub const FORMTYPE_ACRO_FORM: u32 = 1;
pub const FORMTYPE_XFA_FULL: u32 = 2;
pub const FORMTYPE_XFA_FOREGROUND: u32 = 3;
pub const FORMTYPE_COUNT: u32 = 4;
pub const JSPLATFORM_ALERT_BUTTON_OK: u32 = 0;
pub const JSPLATFORM_ALERT_BUTTON_OKCANCEL: u32 = 1;
pub const JSPLATFORM_ALERT_BUTTON_YESNO: u32 = 2;
pub const JSPLATFORM_ALERT_BUTTON_YESNOCANCEL: u32 = 3;
pub const JSPLATFORM_ALERT_BUTTON_DEFAULT: u32 = 0;
pub const JSPLATFORM_ALERT_ICON_ERROR: u32 = 0;
pub const JSPLATFORM_ALERT_ICON_WARNING: u32 = 1;
pub const JSPLATFORM_ALERT_ICON_QUESTION: u32 = 2;
pub const JSPLATFORM_ALERT_ICON_STATUS: u32 = 3;
pub const JSPLATFORM_ALERT_ICON_ASTERISK: u32 = 4;
pub const JSPLATFORM_ALERT_ICON_DEFAULT: u32 = 0;
pub const JSPLATFORM_ALERT_RETURN_OK: u32 = 1;
pub const JSPLATFORM_ALERT_RETURN_CANCEL: u32 = 2;
pub const JSPLATFORM_ALERT_RETURN_NO: u32 = 3;
pub const JSPLATFORM_ALERT_RETURN_YES: u32 = 4;
pub const JSPLATFORM_BEEP_ERROR: u32 = 0;
pub const JSPLATFORM_BEEP_WARNING: u32 = 1;
pub const JSPLATFORM_BEEP_QUESTION: u32 = 2;
pub const JSPLATFORM_BEEP_STATUS: u32 = 3;
pub const JSPLATFORM_BEEP_DEFAULT: u32 = 4;
pub const FXCT_ARROW: u32 = 0;
pub const FXCT_NESW: u32 = 1;
pub const FXCT_NWSE: u32 = 2;
pub const FXCT_VBEAM: u32 = 3;
pub const FXCT_HBEAM: u32 = 4;
pub const FXCT_HAND: u32 = 5;
pub const FPDFDOC_AACTION_WC: u32 = 16;
pub const FPDFDOC_AACTION_WS: u32 = 17;
pub const FPDFDOC_AACTION_DS: u32 = 18;
pub const FPDFDOC_AACTION_WP: u32 = 19;
pub const FPDFDOC_AACTION_DP: u32 = 20;
pub const FPDFPAGE_AACTION_OPEN: u32 = 0;
pub const FPDFPAGE_AACTION_CLOSE: u32 = 1;
pub const FPDF_FORMFIELD_UNKNOWN: u32 = 0;
pub const FPDF_FORMFIELD_PUSHBUTTON: u32 = 1;
pub const FPDF_FORMFIELD_CHECKBOX: u32 = 2;
pub const FPDF_FORMFIELD_RADIOBUTTON: u32 = 3;
pub const FPDF_FORMFIELD_COMBOBOX: u32 = 4;
pub const FPDF_FORMFIELD_LISTBOX: u32 = 5;
pub const FPDF_FORMFIELD_TEXTFIELD: u32 = 6;
pub const FPDF_FORMFIELD_SIGNATURE: u32 = 7;
pub const FPDF_FORMFIELD_COUNT: u32 = 8;
pub const FPDF_ANNOT_UNKNOWN: u32 = 0;
pub const FPDF_ANNOT_TEXT: u32 = 1;
pub const FPDF_ANNOT_LINK: u32 = 2;
pub const FPDF_ANNOT_FREETEXT: u32 = 3;
pub const FPDF_ANNOT_LINE: u32 = 4;
pub const FPDF_ANNOT_SQUARE: u32 = 5;
pub const FPDF_ANNOT_CIRCLE: u32 = 6;
pub const FPDF_ANNOT_POLYGON: u32 = 7;
pub const FPDF_ANNOT_POLYLINE: u32 = 8;
pub const FPDF_ANNOT_HIGHLIGHT: u32 = 9;
pub const FPDF_ANNOT_UNDERLINE: u32 = 10;
pub const FPDF_ANNOT_SQUIGGLY: u32 = 11;
pub const FPDF_ANNOT_STRIKEOUT: u32 = 12;
pub const FPDF_ANNOT_STAMP: u32 = 13;
pub const FPDF_ANNOT_CARET: u32 = 14;
pub const FPDF_ANNOT_INK: u32 = 15;
pub const FPDF_ANNOT_POPUP: u32 = 16;
pub const FPDF_ANNOT_FILEATTACHMENT: u32 = 17;
pub const FPDF_ANNOT_SOUND: u32 = 18;
pub const FPDF_ANNOT_MOVIE: u32 = 19;
pub const FPDF_ANNOT_WIDGET: u32 = 20;
pub const FPDF_ANNOT_SCREEN: u32 = 21;
pub const FPDF_ANNOT_PRINTERMARK: u32 = 22;
pub const FPDF_ANNOT_TRAPNET: u32 = 23;
pub const FPDF_ANNOT_WATERMARK: u32 = 24;
pub const FPDF_ANNOT_THREED: u32 = 25;
pub const FPDF_ANNOT_RICHMEDIA: u32 = 26;
pub const FPDF_ANNOT_XFAWIDGET: u32 = 27;
pub const FPDF_ANNOT_REDACT: u32 = 28;
pub const FPDF_ANNOT_FLAG_NONE: u32 = 0;
pub const FPDF_ANNOT_FLAG_INVISIBLE: u32 = 1;
pub const FPDF_ANNOT_FLAG_HIDDEN: u32 = 2;
pub const FPDF_ANNOT_FLAG_PRINT: u32 = 4;
pub const FPDF_ANNOT_FLAG_NOZOOM: u32 = 8;
pub const FPDF_ANNOT_FLAG_NOROTATE: u32 = 16;
pub const FPDF_ANNOT_FLAG_NOVIEW: u32 = 32;
pub const FPDF_ANNOT_FLAG_READONLY: u32 = 64;
pub const FPDF_ANNOT_FLAG_LOCKED: u32 = 128;
pub const FPDF_ANNOT_FLAG_TOGGLENOVIEW: u32 = 256;
pub const FPDF_ANNOT_APPEARANCEMODE_NORMAL: u32 = 0;
pub const FPDF_ANNOT_APPEARANCEMODE_ROLLOVER: u32 = 1;
pub const FPDF_ANNOT_APPEARANCEMODE_DOWN: u32 = 2;
pub const FPDF_ANNOT_APPEARANCEMODE_COUNT: u32 = 3;
pub const FPDF_FORMFLAG_NONE: u32 = 0;
pub const FPDF_FORMFLAG_READONLY: u32 = 1;
pub const FPDF_FORMFLAG_REQUIRED: u32 = 2;
pub const FPDF_FORMFLAG_NOEXPORT: u32 = 4;
pub const FPDF_FORMFLAG_TEXT_MULTILINE: u32 = 4096;
pub const FPDF_FORMFLAG_TEXT_PASSWORD: u32 = 8192;
pub const FPDF_FORMFLAG_CHOICE_COMBO: u32 = 131072;
pub const FPDF_FORMFLAG_CHOICE_EDIT: u32 = 262144;
pub const FPDF_FORMFLAG_CHOICE_MULTI_SELECT: u32 = 2097152;
pub const PDF_LINEARIZATION_UNKNOWN: i32 = -1;
pub const PDF_NOT_LINEARIZED: u32 = 0;
pub const PDF_LINEARIZED: u32 = 1;
pub const PDF_DATA_ERROR: i32 = -1;
pub const PDF_DATA_NOTAVAIL: u32 = 0;
pub const PDF_DATA_AVAIL: u32 = 1;
pub const PDF_FORM_ERROR: i32 = -1;
pub const PDF_FORM_NOTAVAIL: u32 = 0;
pub const PDF_FORM_AVAIL: u32 = 1;
pub const PDF_FORM_NOTEXIST: u32 = 2;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 38;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const FPDF_COLORSPACE_UNKNOWN: u32 = 0;
pub const FPDF_COLORSPACE_DEVICEGRAY: u32 = 1;
pub const FPDF_COLORSPACE_DEVICERGB: u32 = 2;
pub const FPDF_COLORSPACE_DEVICECMYK: u32 = 3;
pub const FPDF_COLORSPACE_CALGRAY: u32 = 4;
pub const FPDF_COLORSPACE_CALRGB: u32 = 5;
pub const FPDF_COLORSPACE_LAB: u32 = 6;
pub const FPDF_COLORSPACE_ICCBASED: u32 = 7;
pub const FPDF_COLORSPACE_SEPARATION: u32 = 8;
pub const FPDF_COLORSPACE_DEVICEN: u32 = 9;
pub const FPDF_COLORSPACE_INDEXED: u32 = 10;
pub const FPDF_COLORSPACE_PATTERN: u32 = 11;
pub const FPDF_PAGEOBJ_UNKNOWN: u32 = 0;
pub const FPDF_PAGEOBJ_TEXT: u32 = 1;
pub const FPDF_PAGEOBJ_PATH: u32 = 2;
pub const FPDF_PAGEOBJ_IMAGE: u32 = 3;
pub const FPDF_PAGEOBJ_SHADING: u32 = 4;
pub const FPDF_PAGEOBJ_FORM: u32 = 5;
pub const FPDF_SEGMENT_UNKNOWN: i32 = -1;
pub const FPDF_SEGMENT_LINETO: u32 = 0;
pub const FPDF_SEGMENT_BEZIERTO: u32 = 1;
pub const FPDF_SEGMENT_MOVETO: u32 = 2;
pub const FPDF_FILLMODE_NONE: u32 = 0;
pub const FPDF_FILLMODE_ALTERNATE: u32 = 1;
pub const FPDF_FILLMODE_WINDING: u32 = 2;
pub const FPDF_FONT_TYPE1: u32 = 1;
pub const FPDF_FONT_TRUETYPE: u32 = 2;
pub const FPDF_LINECAP_BUTT: u32 = 0;
pub const FPDF_LINECAP_ROUND: u32 = 1;
pub const FPDF_LINECAP_PROJECTING_SQUARE: u32 = 2;
pub const FPDF_LINEJOIN_MITER: u32 = 0;
pub const FPDF_LINEJOIN_ROUND: u32 = 1;
pub const FPDF_LINEJOIN_BEVEL: u32 = 2;
pub const FPDF_PRINTMODE_EMF: u32 = 0;
pub const FPDF_PRINTMODE_TEXTONLY: u32 = 1;
pub const FPDF_PRINTMODE_POSTSCRIPT2: u32 = 2;
pub const FPDF_PRINTMODE_POSTSCRIPT3: u32 = 3;
pub const FPDF_PRINTMODE_POSTSCRIPT2_PASSTHROUGH: u32 = 4;
pub const FPDF_PRINTMODE_POSTSCRIPT3_PASSTHROUGH: u32 = 5;
pub const FPDF_PRINTMODE_EMF_IMAGE_MASKS: u32 = 6;
pub const FPDF_PRINTMODE_POSTSCRIPT3_TYPE42: u32 = 7;
pub const FPDF_PRINTMODE_POSTSCRIPT3_TYPE42_PASSTHROUGH: u32 = 8;
pub const FPDF_UNSP_DOC_XFAFORM: u32 = 1;
pub const FPDF_UNSP_DOC_PORTABLECOLLECTION: u32 = 2;
pub const FPDF_UNSP_DOC_ATTACHMENT: u32 = 3;
pub const FPDF_UNSP_DOC_SECURITY: u32 = 4;
pub const FPDF_UNSP_DOC_SHAREDREVIEW: u32 = 5;
pub const FPDF_UNSP_DOC_SHAREDFORM_ACROBAT: u32 = 6;
pub const FPDF_UNSP_DOC_SHAREDFORM_FILESYSTEM: u32 = 7;
pub const FPDF_UNSP_DOC_SHAREDFORM_EMAIL: u32 = 8;
pub const FPDF_UNSP_ANNOT_3DANNOT: u32 = 11;
pub const FPDF_UNSP_ANNOT_MOVIE: u32 = 12;
pub const FPDF_UNSP_ANNOT_SOUND: u32 = 13;
pub const FPDF_UNSP_ANNOT_SCREEN_MEDIA: u32 = 14;
pub const FPDF_UNSP_ANNOT_SCREEN_RICHMEDIA: u32 = 15;
pub const FPDF_UNSP_ANNOT_ATTACHMENT: u32 = 16;
pub const FPDF_UNSP_ANNOT_SIG: u32 = 17;
pub const PAGEMODE_UNKNOWN: i32 = -1;
pub const PAGEMODE_USENONE: u32 = 0;
pub const PAGEMODE_USEOUTLINES: u32 = 1;
pub const PAGEMODE_USETHUMBS: u32 = 2;
pub const PAGEMODE_FULLSCREEN: u32 = 3;
pub const PAGEMODE_USEOC: u32 = 4;
pub const PAGEMODE_USEATTACHMENTS: u32 = 5;
pub const FLATTEN_FAIL: u32 = 0;
pub const FLATTEN_SUCCESS: u32 = 1;
pub const FLATTEN_NOTHINGTODO: u32 = 2;
pub const FLAT_NORMALDISPLAY: u32 = 0;
pub const FLAT_PRINT: u32 = 1;
pub const FPDF_RENDER_READY: u32 = 0;
pub const FPDF_RENDER_TOBECONTINUED: u32 = 1;
pub const FPDF_RENDER_DONE: u32 = 2;
pub const FPDF_RENDER_FAILED: u32 = 3;
pub const FPDF_INCREMENTAL: u32 = 1;
pub const FPDF_NO_INCREMENTAL: u32 = 2;
pub const FPDF_REMOVE_SECURITY: u32 = 3;
pub const FXFONT_ANSI_CHARSET: u32 = 0;
pub const FXFONT_DEFAULT_CHARSET: u32 = 1;
pub const FXFONT_SYMBOL_CHARSET: u32 = 2;
pub const FXFONT_SHIFTJIS_CHARSET: u32 = 128;
pub const FXFONT_HANGEUL_CHARSET: u32 = 129;
pub const FXFONT_GB2312_CHARSET: u32 = 134;
pub const FXFONT_CHINESEBIG5_CHARSET: u32 = 136;
pub const FXFONT_ARABIC_CHARSET: u32 = 178;
pub const FXFONT_CYRILLIC_CHARSET: u32 = 204;
pub const FXFONT_EASTERNEUROPEAN_CHARSET: u32 = 238;
pub const FXFONT_FF_FIXEDPITCH: u32 = 1;
pub const FXFONT_FF_ROMAN: u32 = 16;
pub const FXFONT_FF_SCRIPT: u32 = 64;
pub const FXFONT_FW_NORMAL: u32 = 400;
pub const FXFONT_FW_BOLD: u32 = 700;
pub const FPDF_MATCHCASE: u32 = 1;
pub const FPDF_MATCHWHOLEWORD: u32 = 2;
pub const FPDF_CONSECUTIVE: u32 = 4;
pub type wchar_t = ::std::os::raw::c_int;
#[doc = " Define 'max_align_t' to match the GCC definition."]
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_UNKNOWN: FPDF_TEXT_RENDERMODE = -1;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_FILL: FPDF_TEXT_RENDERMODE = 0;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_STROKE: FPDF_TEXT_RENDERMODE = 1;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_FILL_STROKE: FPDF_TEXT_RENDERMODE = 2;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_INVISIBLE: FPDF_TEXT_RENDERMODE = 3;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_FILL_CLIP: FPDF_TEXT_RENDERMODE = 4;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_STROKE_CLIP: FPDF_TEXT_RENDERMODE = 5;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_FILL_STROKE_CLIP: FPDF_TEXT_RENDERMODE = 6;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_CLIP: FPDF_TEXT_RENDERMODE = 7;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_LAST: FPDF_TEXT_RENDERMODE = 7;
#[doc = " PDF text rendering modes"]
pub type FPDF_TEXT_RENDERMODE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_action_t__ {
    _unused: [u8; 0],
}
#[doc = " PDF types - use incomplete types (never completed) to force API type safety."]
pub type FPDF_ACTION = *mut fpdf_action_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_annotation_t__ {
    _unused: [u8; 0],
}
pub type FPDF_ANNOTATION = *mut fpdf_annotation_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_attachment_t__ {
    _unused: [u8; 0],
}
pub type FPDF_ATTACHMENT = *mut fpdf_attachment_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_avail_t__ {
    _unused: [u8; 0],
}
pub type FPDF_AVAIL = *mut fpdf_avail_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_bitmap_t__ {
    _unused: [u8; 0],
}
pub type FPDF_BITMAP = *mut fpdf_bitmap_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_bookmark_t__ {
    _unused: [u8; 0],
}
pub type FPDF_BOOKMARK = *mut fpdf_bookmark_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_clippath_t__ {
    _unused: [u8; 0],
}
pub type FPDF_CLIPPATH = *mut fpdf_clippath_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_dest_t__ {
    _unused: [u8; 0],
}
pub type FPDF_DEST = *mut fpdf_dest_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_document_t__ {
    _unused: [u8; 0],
}
pub type FPDF_DOCUMENT = *mut fpdf_document_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_font_t__ {
    _unused: [u8; 0],
}
pub type FPDF_FONT = *mut fpdf_font_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_form_handle_t__ {
    _unused: [u8; 0],
}
pub type FPDF_FORMHANDLE = *mut fpdf_form_handle_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_glyphpath_t__ {
    _unused: [u8; 0],
}
pub type FPDF_GLYPHPATH = *const fpdf_glyphpath_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_javascript_action_t {
    _unused: [u8; 0],
}
pub type FPDF_JAVASCRIPT_ACTION = *mut fpdf_javascript_action_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_link_t__ {
    _unused: [u8; 0],
}
pub type FPDF_LINK = *mut fpdf_link_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_page_t__ {
    _unused: [u8; 0],
}
pub type FPDF_PAGE = *mut fpdf_page_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_pagelink_t__ {
    _unused: [u8; 0],
}
pub type FPDF_PAGELINK = *mut fpdf_pagelink_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_pageobject_t__ {
    _unused: [u8; 0],
}
pub type FPDF_PAGEOBJECT = *mut fpdf_pageobject_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_pageobjectmark_t__ {
    _unused: [u8; 0],
}
pub type FPDF_PAGEOBJECTMARK = *mut fpdf_pageobjectmark_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_pagerange_t__ {
    _unused: [u8; 0],
}
pub type FPDF_PAGERANGE = *mut fpdf_pagerange_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_pathsegment_t {
    _unused: [u8; 0],
}
pub type FPDF_PATHSEGMENT = *const fpdf_pathsegment_t;
pub type FPDF_RECORDER = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_schhandle_t__ {
    _unused: [u8; 0],
}
pub type FPDF_SCHHANDLE = *mut fpdf_schhandle_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_signature_t__ {
    _unused: [u8; 0],
}
pub type FPDF_SIGNATURE = *mut fpdf_signature_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_structelement_t__ {
    _unused: [u8; 0],
}
pub type FPDF_STRUCTELEMENT = *mut fpdf_structelement_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_structtree_t__ {
    _unused: [u8; 0],
}
pub type FPDF_STRUCTTREE = *mut fpdf_structtree_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_textpage_t__ {
    _unused: [u8; 0],
}
pub type FPDF_TEXTPAGE = *mut fpdf_textpage_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_widget_t__ {
    _unused: [u8; 0],
}
pub type FPDF_WIDGET = *mut fpdf_widget_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_xobject_t__ {
    _unused: [u8; 0],
}
pub type FPDF_XOBJECT = *mut fpdf_xobject_t__;
#[doc = " Basic data types"]
pub type FPDF_BOOL = ::std::os::raw::c_int;
pub type FPDF_RESULT = ::std::os::raw::c_int;
pub type FPDF_DWORD = ::std::os::raw::c_ulong;
pub type FS_FLOAT = f32;
pub const _FPDF_DUPLEXTYPE__DuplexUndefined: _FPDF_DUPLEXTYPE_ = 0;
pub const _FPDF_DUPLEXTYPE__Simplex: _FPDF_DUPLEXTYPE_ = 1;
pub const _FPDF_DUPLEXTYPE__DuplexFlipShortEdge: _FPDF_DUPLEXTYPE_ = 2;
pub const _FPDF_DUPLEXTYPE__DuplexFlipLongEdge: _FPDF_DUPLEXTYPE_ = 3;
#[doc = " Duplex types"]
pub type _FPDF_DUPLEXTYPE_ = ::std::os::raw::c_uint;
#[doc = " Duplex types"]
pub use self::_FPDF_DUPLEXTYPE_ as FPDF_DUPLEXTYPE;
#[doc = " String types"]
pub type FPDF_WCHAR = ::std::os::raw::c_ushort;
#[doc = " FPDFSDK may use three types of strings: byte string, wide string (UTF-16LE\n encoded), and platform dependent string"]
pub type FPDF_BYTESTRING = *const ::std::os::raw::c_char;
#[doc = " FPDFSDK always uses UTF-16LE encoded wide strings, each character uses 2\n bytes (except surrogation), with the low byte first."]
pub type FPDF_WIDESTRING = *const ::std::os::raw::c_ushort;
#[doc = " Structure for persisting a string beyond the duration of a callback.\n Note: although represented as a char*, string may be interpreted as\n a UTF-16LE formated string. Used only by XFA callbacks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_BSTR_ {
    #[doc = " String buffer, manipulate only with FPDF_BStr_* methods."]
    pub str_: *mut ::std::os::raw::c_char,
    #[doc = " Length of the string, in bytes."]
    pub len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_FPDF_BSTR_() {
    const UNINIT: ::std::mem::MaybeUninit<FPDF_BSTR_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FPDF_BSTR_>(),
        16usize,
        concat!("Size of: ", stringify!(FPDF_BSTR_))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_BSTR_>(),
        8usize,
        concat!("Alignment of ", stringify!(FPDF_BSTR_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_BSTR_),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_BSTR_),
            "::",
            stringify!(len)
        )
    );
}
#[doc = " Structure for persisting a string beyond the duration of a callback.\n Note: although represented as a char*, string may be interpreted as\n a UTF-16LE formated string. Used only by XFA callbacks."]
pub type FPDF_BSTR = FPDF_BSTR_;
#[doc = " For Windows programmers: In most cases it's OK to treat FPDF_WIDESTRING as a\n Windows unicode string, however, special care needs to be taken if you\n expect to process Unicode larger than 0xffff.\n\n For Linux/Unix programmers: most compiler/library environments use 4 bytes\n for a Unicode character, and you have to convert between FPDF_WIDESTRING and\n system wide string by yourself."]
pub type FPDF_STRING = *const ::std::os::raw::c_char;
#[doc = " Matrix for transformation, in the form [a b c d e f], equivalent to:\n | a  b  0 |\n | c  d  0 |\n | e  f  1 |\n\n Translation is performed with [1 0 0 1 tx ty].\n Scaling is performed with [sx 0 0 sy 0 0].\n See PDF Reference 1.7, 4.2.2 Common Transformations for more."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_MATRIX_ {
    pub a: f32,
    pub b: f32,
    pub c: f32,
    pub d: f32,
    pub e: f32,
    pub f: f32,
}
#[test]
fn bindgen_test_layout__FS_MATRIX_() {
    const UNINIT: ::std::mem::MaybeUninit<_FS_MATRIX_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FS_MATRIX_>(),
        24usize,
        concat!("Size of: ", stringify!(_FS_MATRIX_))
    );
    assert_eq!(
        ::std::mem::align_of::<_FS_MATRIX_>(),
        4usize,
        concat!("Alignment of ", stringify!(_FS_MATRIX_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_MATRIX_),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_MATRIX_),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_MATRIX_),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_MATRIX_),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_MATRIX_),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_MATRIX_),
            "::",
            stringify!(f)
        )
    );
}
#[doc = " Matrix for transformation, in the form [a b c d e f], equivalent to:\n | a  b  0 |\n | c  d  0 |\n | e  f  1 |\n\n Translation is performed with [1 0 0 1 tx ty].\n Scaling is performed with [sx 0 0 sy 0 0].\n See PDF Reference 1.7, 4.2.2 Common Transformations for more."]
pub type FS_MATRIX = _FS_MATRIX_;
#[doc = " Rectangle area(float) in device or page coordinate system."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_RECTF_ {
    #[doc = " The x-coordinate of the left-top corner."]
    pub left: f32,
    #[doc = " The y-coordinate of the left-top corner."]
    pub top: f32,
    #[doc = " The x-coordinate of the right-bottom corner."]
    pub right: f32,
    #[doc = " The y-coordinate of the right-bottom corner."]
    pub bottom: f32,
}
#[test]
fn bindgen_test_layout__FS_RECTF_() {
    const UNINIT: ::std::mem::MaybeUninit<_FS_RECTF_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FS_RECTF_>(),
        16usize,
        concat!("Size of: ", stringify!(_FS_RECTF_))
    );
    assert_eq!(
        ::std::mem::align_of::<_FS_RECTF_>(),
        4usize,
        concat!("Alignment of ", stringify!(_FS_RECTF_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_RECTF_),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_RECTF_),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_RECTF_),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_RECTF_),
            "::",
            stringify!(bottom)
        )
    );
}
#[doc = " Rectangle area(float) in device or page coordinate system."]
pub type FS_LPRECTF = *mut _FS_RECTF_;
#[doc = " Rectangle area(float) in device or page coordinate system."]
pub type FS_RECTF = _FS_RECTF_;
#[doc = " Const Pointer to FS_RECTF structure."]
pub type FS_LPCRECTF = *const FS_RECTF;
#[doc = " Rectangle size. Coordinate system agnostic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_SIZEF_ {
    pub width: f32,
    pub height: f32,
}
#[test]
fn bindgen_test_layout_FS_SIZEF_() {
    const UNINIT: ::std::mem::MaybeUninit<FS_SIZEF_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FS_SIZEF_>(),
        8usize,
        concat!("Size of: ", stringify!(FS_SIZEF_))
    );
    assert_eq!(
        ::std::mem::align_of::<FS_SIZEF_>(),
        4usize,
        concat!("Alignment of ", stringify!(FS_SIZEF_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FS_SIZEF_),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FS_SIZEF_),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " Rectangle size. Coordinate system agnostic."]
pub type FS_LPSIZEF = *mut FS_SIZEF_;
#[doc = " Rectangle size. Coordinate system agnostic."]
pub type FS_SIZEF = FS_SIZEF_;
#[doc = " Const Pointer to FS_SIZEF structure."]
pub type FS_LPCSIZEF = *const FS_SIZEF;
#[doc = " 2D Point. Coordinate system agnostic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_POINTF_ {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_FS_POINTF_() {
    const UNINIT: ::std::mem::MaybeUninit<FS_POINTF_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FS_POINTF_>(),
        8usize,
        concat!("Size of: ", stringify!(FS_POINTF_))
    );
    assert_eq!(
        ::std::mem::align_of::<FS_POINTF_>(),
        4usize,
        concat!("Alignment of ", stringify!(FS_POINTF_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FS_POINTF_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FS_POINTF_),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " 2D Point. Coordinate system agnostic."]
pub type FS_LPPOINTF = *mut FS_POINTF_;
#[doc = " 2D Point. Coordinate system agnostic."]
pub type FS_POINTF = FS_POINTF_;
#[doc = " Const Pointer to FS_POINTF structure."]
pub type FS_LPCPOINTF = *const FS_POINTF;
#[doc = " Annotation enums."]
pub type FPDF_ANNOTATION_SUBTYPE = ::std::os::raw::c_int;
pub type FPDF_ANNOT_APPEARANCEMODE = ::std::os::raw::c_int;
#[doc = " Dictionary value types."]
pub type FPDF_OBJECT_TYPE = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Function: FPDF_InitLibrary\n          Initialize the FPDFSDK library\n Parameters:\n          None\n Return value:\n          None.\n Comments:\n          Convenience function to call FPDF_InitLibraryWithConfig() for\n          backwards compatibility purposes. This will be deprecated in the\n          future."]
    pub fn FPDF_InitLibrary();
}
#[doc = " Process-wide options for initializing the library."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_LIBRARY_CONFIG_ {
    #[doc = " Version number of the interface. Currently must be 2.\n Support for version 1 will be deprecated in the future."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Array of paths to scan in place of the defaults when using built-in\n FXGE font loading code. The array is terminated by a NULL pointer.\n The Array may be NULL itself to use the default paths. May be ignored\n entirely depending upon the platform."]
    pub m_pUserFontPaths: *mut *const ::std::os::raw::c_char,
    #[doc = " Pointer to the v8::Isolate to use, or NULL to force PDFium to create one."]
    pub m_pIsolate: *mut ::std::os::raw::c_void,
    #[doc = " The embedder data slot to use in the v8::Isolate to store PDFium's\n per-isolate data. The value needs to be in the range\n [0, |v8::Internals::kNumIsolateDataLots|). Note that 0 is fine for most\n embedders."]
    pub m_v8EmbedderSlot: ::std::os::raw::c_uint,
    #[doc = " Pointer to the V8::Platform to use."]
    pub m_pPlatform: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FPDF_LIBRARY_CONFIG_() {
    const UNINIT: ::std::mem::MaybeUninit<FPDF_LIBRARY_CONFIG_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FPDF_LIBRARY_CONFIG_>(),
        40usize,
        concat!("Size of: ", stringify!(FPDF_LIBRARY_CONFIG_))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_LIBRARY_CONFIG_>(),
        8usize,
        concat!("Alignment of ", stringify!(FPDF_LIBRARY_CONFIG_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_LIBRARY_CONFIG_),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pUserFontPaths) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_LIBRARY_CONFIG_),
            "::",
            stringify!(m_pUserFontPaths)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pIsolate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_LIBRARY_CONFIG_),
            "::",
            stringify!(m_pIsolate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_v8EmbedderSlot) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_LIBRARY_CONFIG_),
            "::",
            stringify!(m_v8EmbedderSlot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pPlatform) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_LIBRARY_CONFIG_),
            "::",
            stringify!(m_pPlatform)
        )
    );
}
#[doc = " Process-wide options for initializing the library."]
pub type FPDF_LIBRARY_CONFIG = FPDF_LIBRARY_CONFIG_;
extern "C" {
    #[doc = " Function: FPDF_InitLibraryWithConfig\n          Initialize the FPDFSDK library\n Parameters:\n          config - configuration information as above.\n Return value:\n          None.\n Comments:\n          You have to call this function before you can call any PDF\n          processing functions."]
    pub fn FPDF_InitLibraryWithConfig(config: *const FPDF_LIBRARY_CONFIG);
}
extern "C" {
    #[doc = " Function: FPDF_DestroyLibary\n          Release all resources allocated by the FPDFSDK library.\n Parameters:\n          None.\n Return value:\n          None.\n Comments:\n          You can call this function to release all memory blocks allocated by\n          the library.\n          After this function is called, you should not call any PDF\n          processing functions."]
    pub fn FPDF_DestroyLibrary();
}
extern "C" {
    #[doc = " Function: FPDF_SetSandBoxPolicy\n          Set the policy for the sandbox environment.\n Parameters:\n          policy -   The specified policy for setting, for example:\n                     FPDF_POLICY_MACHINETIME_ACCESS.\n          enable -   True to enable, false to disable the policy.\n Return value:\n          None."]
    pub fn FPDF_SetSandBoxPolicy(policy: FPDF_DWORD, enable: FPDF_BOOL);
}
extern "C" {
    #[doc = " Function: FPDF_LoadDocument\n          Open and load a PDF document.\n Parameters:\n          file_path -  Path to the PDF file (including extension).\n          password  -  A string used as the password for the PDF file.\n                       If no password is needed, empty or NULL can be used.\n                       See comments below regarding the encoding.\n Return value:\n          A handle to the loaded document, or NULL on failure.\n Comments:\n          Loaded document can be closed by FPDF_CloseDocument().\n          If this function fails, you can use FPDF_GetLastError() to retrieve\n          the reason why it failed.\n\n          The encoding for |password| can be either UTF-8 or Latin-1. PDFs,\n          depending on the security handler revision, will only accept one or\n          the other encoding. If |password|'s encoding and the PDF's expected\n          encoding do not match, FPDF_LoadDocument() will automatically\n          convert |password| to the other encoding."]
    pub fn FPDF_LoadDocument(file_path: FPDF_STRING, password: FPDF_BYTESTRING) -> FPDF_DOCUMENT;
}
extern "C" {
    #[doc = " Function: FPDF_LoadMemDocument\n          Open and load a PDF document from memory.\n Parameters:\n          data_buf    -   Pointer to a buffer containing the PDF document.\n          size        -   Number of bytes in the PDF document.\n          password    -   A string used as the password for the PDF file.\n                          If no password is needed, empty or NULL can be used.\n Return value:\n          A handle to the loaded document, or NULL on failure.\n Comments:\n          The memory buffer must remain valid when the document is open.\n          The loaded document can be closed by FPDF_CloseDocument.\n          If this function fails, you can use FPDF_GetLastError() to retrieve\n          the reason why it failed.\n\n          See the comments for FPDF_LoadDocument() regarding the encoding for\n          |password|.\n Notes:\n          If PDFium is built with the XFA module, the application should call\n          FPDF_LoadXFA() function after the PDF document loaded to support XFA\n          fields defined in the fpdfformfill.h file."]
    pub fn FPDF_LoadMemDocument(
        data_buf: *const ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
        password: FPDF_BYTESTRING,
    ) -> FPDF_DOCUMENT;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDF_LoadMemDocument64\n          Open and load a PDF document from memory.\n Parameters:\n          data_buf    -   Pointer to a buffer containing the PDF document.\n          size        -   Number of bytes in the PDF document.\n          password    -   A string used as the password for the PDF file.\n                          If no password is needed, empty or NULL can be used.\n Return value:\n          A handle to the loaded document, or NULL on failure.\n Comments:\n          The memory buffer must remain valid when the document is open.\n          The loaded document can be closed by FPDF_CloseDocument.\n          If this function fails, you can use FPDF_GetLastError() to retrieve\n          the reason why it failed.\n\n          See the comments for FPDF_LoadDocument() regarding the encoding for\n          |password|.\n Notes:\n          If PDFium is built with the XFA module, the application should call\n          FPDF_LoadXFA() function after the PDF document loaded to support XFA\n          fields defined in the fpdfformfill.h file."]
    pub fn FPDF_LoadMemDocument64(
        data_buf: *const ::std::os::raw::c_void,
        size: usize,
        password: FPDF_BYTESTRING,
    ) -> FPDF_DOCUMENT;
}
#[doc = " Structure for custom file access."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_FILEACCESS {
    #[doc = " File length, in bytes."]
    pub m_FileLen: ::std::os::raw::c_ulong,
    #[doc = " A function pointer for getting a block of data from a specific position.\n Position is specified by byte offset from the beginning of the file.\n The pointer to the buffer is never NULL and the size is never 0.\n The position and size will never go out of range of the file length.\n It may be possible for FPDFSDK to call this function multiple times for\n the same position.\n Return value: should be non-zero if successful, zero for error."]
    pub m_GetBlock: ::std::option::Option<
        unsafe extern "C" fn(
            param: *mut ::std::os::raw::c_void,
            position: ::std::os::raw::c_ulong,
            pBuf: *mut ::std::os::raw::c_uchar,
            size: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " A custom pointer for all implementation specific data.  This pointer will\n be used as the first parameter to the m_GetBlock callback."]
    pub m_Param: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FPDF_FILEACCESS() {
    const UNINIT: ::std::mem::MaybeUninit<FPDF_FILEACCESS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FPDF_FILEACCESS>(),
        24usize,
        concat!("Size of: ", stringify!(FPDF_FILEACCESS))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_FILEACCESS>(),
        8usize,
        concat!("Alignment of ", stringify!(FPDF_FILEACCESS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_FileLen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEACCESS),
            "::",
            stringify!(m_FileLen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_GetBlock) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEACCESS),
            "::",
            stringify!(m_GetBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_Param) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEACCESS),
            "::",
            stringify!(m_Param)
        )
    );
}
#[doc = " Structure for file reading or writing (I/O).\n\n Note: This is a handler and should be implemented by callers,\n and is only used from XFA."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_FILEHANDLER_ {
    #[doc = " User-defined data.\n Note: Callers can use this field to track controls."]
    pub clientData: *mut ::std::os::raw::c_void,
    #[doc = " Callback function to release the current file stream object.\n\n Parameters:\n       clientData   -  Pointer to user-defined data.\n Returns:\n       None."]
    pub Release:
        ::std::option::Option<unsafe extern "C" fn(clientData: *mut ::std::os::raw::c_void)>,
    #[doc = " Callback function to retrieve the current file stream size.\n\n Parameters:\n       clientData   -  Pointer to user-defined data.\n Returns:\n       Size of file stream."]
    pub GetSize: ::std::option::Option<
        unsafe extern "C" fn(clientData: *mut ::std::os::raw::c_void) -> FPDF_DWORD,
    >,
    #[doc = " Callback function to read data from the current file stream.\n\n Parameters:\n       clientData   -  Pointer to user-defined data.\n       offset       -  Offset position starts from the beginning of file\n                       stream. This parameter indicates reading position.\n       buffer       -  Memory buffer to store data which are read from\n                       file stream. This parameter should not be NULL.\n       size         -  Size of data which should be read from file stream,\n                       in bytes. The buffer indicated by |buffer| must be\n                       large enough to store specified data.\n Returns:\n       0 for success, other value for failure."]
    pub ReadBlock: ::std::option::Option<
        unsafe extern "C" fn(
            clientData: *mut ::std::os::raw::c_void,
            offset: FPDF_DWORD,
            buffer: *mut ::std::os::raw::c_void,
            size: FPDF_DWORD,
        ) -> FPDF_RESULT,
    >,
    #[doc = " Callback function to write data into the current file stream.\n\n Parameters:\n       clientData   -  Pointer to user-defined data.\n       offset       -  Offset position starts from the beginning of file\n                       stream. This parameter indicates writing position.\n       buffer       -  Memory buffer contains data which is written into\n                       file stream. This parameter should not be NULL.\n       size         -  Size of data which should be written into file\n                       stream, in bytes.\n Returns:\n       0 for success, other value for failure."]
    pub WriteBlock: ::std::option::Option<
        unsafe extern "C" fn(
            clientData: *mut ::std::os::raw::c_void,
            offset: FPDF_DWORD,
            buffer: *const ::std::os::raw::c_void,
            size: FPDF_DWORD,
        ) -> FPDF_RESULT,
    >,
    #[doc = " Callback function to flush all internal accessing buffers.\n\n Parameters:\n       clientData   -  Pointer to user-defined data.\n Returns:\n       0 for success, other value for failure."]
    pub Flush: ::std::option::Option<
        unsafe extern "C" fn(clientData: *mut ::std::os::raw::c_void) -> FPDF_RESULT,
    >,
    #[doc = " Callback function to change file size.\n\n Description:\n       This function is called under writing mode usually. Implementer\n       can determine whether to realize it based on application requests.\n Parameters:\n       clientData   -  Pointer to user-defined data.\n       size         -  New size of file stream, in bytes.\n Returns:\n       0 for success, other value for failure."]
    pub Truncate: ::std::option::Option<
        unsafe extern "C" fn(
            clientData: *mut ::std::os::raw::c_void,
            size: FPDF_DWORD,
        ) -> FPDF_RESULT,
    >,
}
#[test]
fn bindgen_test_layout_FPDF_FILEHANDLER_() {
    const UNINIT: ::std::mem::MaybeUninit<FPDF_FILEHANDLER_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FPDF_FILEHANDLER_>(),
        56usize,
        concat!("Size of: ", stringify!(FPDF_FILEHANDLER_))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_FILEHANDLER_>(),
        8usize,
        concat!("Alignment of ", stringify!(FPDF_FILEHANDLER_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clientData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(clientData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Release) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(Release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(GetSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadBlock) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(ReadBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WriteBlock) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(WriteBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flush) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(Flush)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Truncate) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(Truncate)
        )
    );
}
#[doc = " Structure for file reading or writing (I/O).\n\n Note: This is a handler and should be implemented by callers,\n and is only used from XFA."]
pub type FPDF_FILEHANDLER = FPDF_FILEHANDLER_;
extern "C" {
    #[doc = " Function: FPDF_LoadCustomDocument\n          Load PDF document from a custom access descriptor.\n Parameters:\n          pFileAccess -   A structure for accessing the file.\n          password    -   Optional password for decrypting the PDF file.\n Return value:\n          A handle to the loaded document, or NULL on failure.\n Comments:\n          The application must keep the file resources |pFileAccess| points to\n          valid until the returned FPDF_DOCUMENT is closed. |pFileAccess|\n          itself does not need to outlive the FPDF_DOCUMENT.\n\n          The loaded document can be closed with FPDF_CloseDocument().\n\n          See the comments for FPDF_LoadDocument() regarding the encoding for\n          |password|.\n Notes:\n          If PDFium is built with the XFA module, the application should call\n          FPDF_LoadXFA() function after the PDF document loaded to support XFA\n          fields defined in the fpdfformfill.h file."]
    pub fn FPDF_LoadCustomDocument(
        pFileAccess: *mut FPDF_FILEACCESS,
        password: FPDF_BYTESTRING,
    ) -> FPDF_DOCUMENT;
}
extern "C" {
    #[doc = " Function: FPDF_GetFileVersion\n          Get the file version of the given PDF document.\n Parameters:\n          doc         -   Handle to a document.\n          fileVersion -   The PDF file version. File version: 14 for 1.4, 15\n                          for 1.5, ...\n Return value:\n          True if succeeds, false otherwise.\n Comments:\n          If the document was created by FPDF_CreateNewDocument,\n          then this function will always fail."]
    pub fn FPDF_GetFileVersion(
        doc: FPDF_DOCUMENT,
        fileVersion: *mut ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDF_GetLastError\n          Get last error code when a function fails.\n Parameters:\n          None.\n Return value:\n          A 32-bit integer indicating error code as defined above.\n Comments:\n          If the previous SDK call succeeded, the return value of this\n          function is not defined."]
    pub fn FPDF_GetLastError() -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDF_DocumentHasValidCrossReferenceTable\n          Whether the document's cross reference table is valid or not.\n Parameters:\n          document    -   Handle to a document. Returned by FPDF_LoadDocument.\n Return value:\n          True if the PDF parser did not encounter problems parsing the cross\n          reference table. False if the parser could not parse the cross\n          reference table and the table had to be rebuild from other data\n          within the document.\n Comments:\n          The return value can change over time as the PDF parser evolves."]
    pub fn FPDF_DocumentHasValidCrossReferenceTable(document: FPDF_DOCUMENT) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDF_GetTrailerEnds\n          Get the byte offsets of trailer ends.\n Parameters:\n          document    -   Handle to document. Returned by FPDF_LoadDocument().\n          buffer      -   The address of a buffer that receives the\n                          byte offsets.\n          length      -   The size, in ints, of |buffer|.\n Return value:\n          Returns the number of ints in the buffer on success, 0 on error.\n\n |buffer| is an array of integers that describes the exact byte offsets of the\n trailer ends in the document. If |length| is less than the returned length,\n or |document| or |buffer| is NULL, |buffer| will not be modified."]
    pub fn FPDF_GetTrailerEnds(
        document: FPDF_DOCUMENT,
        buffer: *mut ::std::os::raw::c_uint,
        length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Function: FPDF_GetDocPermission\n          Get file permission flags of the document.\n Parameters:\n          document    -   Handle to a document. Returned by FPDF_LoadDocument.\n Return value:\n          A 32-bit integer indicating permission flags. Please refer to the\n          PDF Reference for detailed descriptions. If the document is not\n          protected, 0xffffffff will be returned."]
    pub fn FPDF_GetDocPermissions(document: FPDF_DOCUMENT) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Function: FPDF_GetSecurityHandlerRevision\n          Get the revision for the security handler.\n Parameters:\n          document    -   Handle to a document. Returned by FPDF_LoadDocument.\n Return value:\n          The security handler revision number. Please refer to the PDF\n          Reference for a detailed description. If the document is not\n          protected, -1 will be returned."]
    pub fn FPDF_GetSecurityHandlerRevision(document: FPDF_DOCUMENT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDF_GetPageCount\n          Get total number of pages in the document.\n Parameters:\n          document    -   Handle to document. Returned by FPDF_LoadDocument.\n Return value:\n          Total number of pages in the document."]
    pub fn FPDF_GetPageCount(document: FPDF_DOCUMENT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDF_LoadPage\n          Load a page inside the document.\n Parameters:\n          document    -   Handle to document. Returned by FPDF_LoadDocument\n          page_index  -   Index number of the page. 0 for the first page.\n Return value:\n          A handle to the loaded page, or NULL if page load fails.\n Comments:\n          The loaded page can be rendered to devices using FPDF_RenderPage.\n          The loaded page can be closed using FPDF_ClosePage."]
    pub fn FPDF_LoadPage(document: FPDF_DOCUMENT, page_index: ::std::os::raw::c_int) -> FPDF_PAGE;
}
extern "C" {
    #[doc = " Experimental API\n Function: FPDF_GetPageWidthF\n          Get page width.\n Parameters:\n          page        -   Handle to the page. Returned by FPDF_LoadPage().\n Return value:\n          Page width (excluding non-displayable area) measured in points.\n          One point is 1/72 inch (around 0.3528 mm)."]
    pub fn FPDF_GetPageWidthF(page: FPDF_PAGE) -> f32;
}
extern "C" {
    #[doc = " Function: FPDF_GetPageWidth\n          Get page width.\n Parameters:\n          page        -   Handle to the page. Returned by FPDF_LoadPage.\n Return value:\n          Page width (excluding non-displayable area) measured in points.\n          One point is 1/72 inch (around 0.3528 mm).\n Note:\n          Prefer FPDF_GetPageWidthF() above. This will be deprecated in the\n          future."]
    pub fn FPDF_GetPageWidth(page: FPDF_PAGE) -> f64;
}
extern "C" {
    #[doc = " Experimental API\n Function: FPDF_GetPageHeightF\n          Get page height.\n Parameters:\n          page        -   Handle to the page. Returned by FPDF_LoadPage().\n Return value:\n          Page height (excluding non-displayable area) measured in points.\n          One point is 1/72 inch (around 0.3528 mm)"]
    pub fn FPDF_GetPageHeightF(page: FPDF_PAGE) -> f32;
}
extern "C" {
    #[doc = " Function: FPDF_GetPageHeight\n          Get page height.\n Parameters:\n          page        -   Handle to the page. Returned by FPDF_LoadPage.\n Return value:\n          Page height (excluding non-displayable area) measured in points.\n          One point is 1/72 inch (around 0.3528 mm)\n Note:\n          Prefer FPDF_GetPageHeightF() above. This will be deprecated in the\n          future."]
    pub fn FPDF_GetPageHeight(page: FPDF_PAGE) -> f64;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDF_GetPageBoundingBox\n          Get the bounding box of the page. This is the intersection between\n          its media box and its crop box.\n Parameters:\n          page        -   Handle to the page. Returned by FPDF_LoadPage.\n          rect        -   Pointer to a rect to receive the page bounding box.\n                          On an error, |rect| won't be filled.\n Return value:\n          True for success."]
    pub fn FPDF_GetPageBoundingBox(page: FPDF_PAGE, rect: *mut FS_RECTF) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDF_GetPageSizeByIndexF\n          Get the size of the page at the given index.\n Parameters:\n          document    -   Handle to document. Returned by FPDF_LoadDocument().\n          page_index  -   Page index, zero for the first page.\n          size        -   Pointer to a FS_SIZEF to receive the page size.\n                          (in points).\n Return value:\n          Non-zero for success. 0 for error (document or page not found)."]
    pub fn FPDF_GetPageSizeByIndexF(
        document: FPDF_DOCUMENT,
        page_index: ::std::os::raw::c_int,
        size: *mut FS_SIZEF,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDF_GetPageSizeByIndex\n          Get the size of the page at the given index.\n Parameters:\n          document    -   Handle to document. Returned by FPDF_LoadDocument.\n          page_index  -   Page index, zero for the first page.\n          width       -   Pointer to a double to receive the page width\n                          (in points).\n          height      -   Pointer to a double to receive the page height\n                          (in points).\n Return value:\n          Non-zero for success. 0 for error (document or page not found).\n Note:\n          Prefer FPDF_GetPageSizeByIndexF() above. This will be deprecated in\n          the future."]
    pub fn FPDF_GetPageSizeByIndex(
        document: FPDF_DOCUMENT,
        page_index: ::std::os::raw::c_int,
        width: *mut f64,
        height: *mut f64,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Struct for color scheme.\n Each should be a 32-bit value specifying the color, in 8888 ARGB format."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_COLORSCHEME_ {
    pub path_fill_color: FPDF_DWORD,
    pub path_stroke_color: FPDF_DWORD,
    pub text_fill_color: FPDF_DWORD,
    pub text_stroke_color: FPDF_DWORD,
}
#[test]
fn bindgen_test_layout_FPDF_COLORSCHEME_() {
    const UNINIT: ::std::mem::MaybeUninit<FPDF_COLORSCHEME_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FPDF_COLORSCHEME_>(),
        32usize,
        concat!("Size of: ", stringify!(FPDF_COLORSCHEME_))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_COLORSCHEME_>(),
        8usize,
        concat!("Alignment of ", stringify!(FPDF_COLORSCHEME_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_fill_color) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_COLORSCHEME_),
            "::",
            stringify!(path_fill_color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_stroke_color) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_COLORSCHEME_),
            "::",
            stringify!(path_stroke_color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text_fill_color) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_COLORSCHEME_),
            "::",
            stringify!(text_fill_color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text_stroke_color) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_COLORSCHEME_),
            "::",
            stringify!(text_stroke_color)
        )
    );
}
#[doc = " Struct for color scheme.\n Each should be a 32-bit value specifying the color, in 8888 ARGB format."]
pub type FPDF_COLORSCHEME = FPDF_COLORSCHEME_;
extern "C" {
    #[doc = " Function: FPDF_RenderPageBitmap\n          Render contents of a page to a device independent bitmap.\n Parameters:\n          bitmap      -   Handle to the device independent bitmap (as the\n                          output buffer). The bitmap handle can be created\n                          by FPDFBitmap_Create or retrieved from an image\n                          object by FPDFImageObj_GetBitmap.\n          page        -   Handle to the page. Returned by FPDF_LoadPage\n          start_x     -   Left pixel position of the display area in\n                          bitmap coordinates.\n          start_y     -   Top pixel position of the display area in bitmap\n                          coordinates.\n          size_x      -   Horizontal size (in pixels) for displaying the page.\n          size_y      -   Vertical size (in pixels) for displaying the page.\n          rotate      -   Page orientation:\n                            0 (normal)\n                            1 (rotated 90 degrees clockwise)\n                            2 (rotated 180 degrees)\n                            3 (rotated 90 degrees counter-clockwise)\n          flags       -   0 for normal display, or combination of the Page\n                          Rendering flags defined above. With the FPDF_ANNOT\n                          flag, it renders all annotations that do not require\n                          user-interaction, which are all annotations except\n                          widget and popup annotations.\n Return value:\n          None."]
    pub fn FPDF_RenderPageBitmap(
        bitmap: FPDF_BITMAP,
        page: FPDF_PAGE,
        start_x: ::std::os::raw::c_int,
        start_y: ::std::os::raw::c_int,
        size_x: ::std::os::raw::c_int,
        size_y: ::std::os::raw::c_int,
        rotate: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Function: FPDF_RenderPageBitmapWithMatrix\n          Render contents of a page to a device independent bitmap.\n Parameters:\n          bitmap      -   Handle to the device independent bitmap (as the\n                          output buffer). The bitmap handle can be created\n                          by FPDFBitmap_Create or retrieved by\n                          FPDFImageObj_GetBitmap.\n          page        -   Handle to the page. Returned by FPDF_LoadPage.\n          matrix      -   The transform matrix, which must be invertible.\n                          See PDF Reference 1.7, 4.2.2 Common Transformations.\n          clipping    -   The rect to clip to in device coords.\n          flags       -   0 for normal display, or combination of the Page\n                          Rendering flags defined above. With the FPDF_ANNOT\n                          flag, it renders all annotations that do not require\n                          user-interaction, which are all annotations except\n                          widget and popup annotations.\n Return value:\n          None. Note that behavior is undefined if det of |matrix| is 0."]
    pub fn FPDF_RenderPageBitmapWithMatrix(
        bitmap: FPDF_BITMAP,
        page: FPDF_PAGE,
        matrix: *const FS_MATRIX,
        clipping: *const FS_RECTF,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Function: FPDF_ClosePage\n          Close a loaded PDF page.\n Parameters:\n          page        -   Handle to the loaded page.\n Return value:\n          None."]
    pub fn FPDF_ClosePage(page: FPDF_PAGE);
}
extern "C" {
    #[doc = " Function: FPDF_CloseDocument\n          Close a loaded PDF document.\n Parameters:\n          document    -   Handle to the loaded document.\n Return value:\n          None."]
    pub fn FPDF_CloseDocument(document: FPDF_DOCUMENT);
}
extern "C" {
    #[doc = " Function: FPDF_DeviceToPage\n          Convert the screen coordinates of a point to page coordinates.\n Parameters:\n          page        -   Handle to the page. Returned by FPDF_LoadPage.\n          start_x     -   Left pixel position of the display area in\n                          device coordinates.\n          start_y     -   Top pixel position of the display area in device\n                          coordinates.\n          size_x      -   Horizontal size (in pixels) for displaying the page.\n          size_y      -   Vertical size (in pixels) for displaying the page.\n          rotate      -   Page orientation:\n                            0 (normal)\n                            1 (rotated 90 degrees clockwise)\n                            2 (rotated 180 degrees)\n                            3 (rotated 90 degrees counter-clockwise)\n          device_x    -   X value in device coordinates to be converted.\n          device_y    -   Y value in device coordinates to be converted.\n          page_x      -   A pointer to a double receiving the converted X\n                          value in page coordinates.\n          page_y      -   A pointer to a double receiving the converted Y\n                          value in page coordinates.\n Return value:\n          Returns true if the conversion succeeds, and |page_x| and |page_y|\n          successfully receives the converted coordinates.\n Comments:\n          The page coordinate system has its origin at the left-bottom corner\n          of the page, with the X-axis on the bottom going to the right, and\n          the Y-axis on the left side going up.\n\n          NOTE: this coordinate system can be altered when you zoom, scroll,\n          or rotate a page, however, a point on the page should always have\n          the same coordinate values in the page coordinate system.\n\n          The device coordinate system is device dependent. For screen device,\n          its origin is at the left-top corner of the window. However this\n          origin can be altered by the Windows coordinate transformation\n          utilities.\n\n          You must make sure the start_x, start_y, size_x, size_y\n          and rotate parameters have exactly same values as you used in\n          the FPDF_RenderPage() function call."]
    pub fn FPDF_DeviceToPage(
        page: FPDF_PAGE,
        start_x: ::std::os::raw::c_int,
        start_y: ::std::os::raw::c_int,
        size_x: ::std::os::raw::c_int,
        size_y: ::std::os::raw::c_int,
        rotate: ::std::os::raw::c_int,
        device_x: ::std::os::raw::c_int,
        device_y: ::std::os::raw::c_int,
        page_x: *mut f64,
        page_y: *mut f64,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDF_PageToDevice\n          Convert the page coordinates of a point to screen coordinates.\n Parameters:\n          page        -   Handle to the page. Returned by FPDF_LoadPage.\n          start_x     -   Left pixel position of the display area in\n                          device coordinates.\n          start_y     -   Top pixel position of the display area in device\n                          coordinates.\n          size_x      -   Horizontal size (in pixels) for displaying the page.\n          size_y      -   Vertical size (in pixels) for displaying the page.\n          rotate      -   Page orientation:\n                            0 (normal)\n                            1 (rotated 90 degrees clockwise)\n                            2 (rotated 180 degrees)\n                            3 (rotated 90 degrees counter-clockwise)\n          page_x      -   X value in page coordinates.\n          page_y      -   Y value in page coordinate.\n          device_x    -   A pointer to an integer receiving the result X\n                          value in device coordinates.\n          device_y    -   A pointer to an integer receiving the result Y\n                          value in device coordinates.\n Return value:\n          Returns true if the conversion succeeds, and |device_x| and\n          |device_y| successfully receives the converted coordinates.\n Comments:\n          See comments for FPDF_DeviceToPage()."]
    pub fn FPDF_PageToDevice(
        page: FPDF_PAGE,
        start_x: ::std::os::raw::c_int,
        start_y: ::std::os::raw::c_int,
        size_x: ::std::os::raw::c_int,
        size_y: ::std::os::raw::c_int,
        rotate: ::std::os::raw::c_int,
        page_x: f64,
        page_y: f64,
        device_x: *mut ::std::os::raw::c_int,
        device_y: *mut ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDFBitmap_Create\n          Create a device independent bitmap (FXDIB).\n Parameters:\n          width       -   The number of pixels in width for the bitmap.\n                          Must be greater than 0.\n          height      -   The number of pixels in height for the bitmap.\n                          Must be greater than 0.\n          alpha       -   A flag indicating whether the alpha channel is used.\n                          Non-zero for using alpha, zero for not using.\n Return value:\n          The created bitmap handle, or NULL if a parameter error or out of\n          memory.\n Comments:\n          The bitmap always uses 4 bytes per pixel. The first byte is always\n          double word aligned.\n\n          The byte order is BGRx (the last byte unused if no alpha channel) or\n          BGRA.\n\n          The pixels in a horizontal line are stored side by side, with the\n          left most pixel stored first (with lower memory address).\n          Each line uses width * 4 bytes.\n\n          Lines are stored one after another, with the top most line stored\n          first. There is no gap between adjacent lines.\n\n          This function allocates enough memory for holding all pixels in the\n          bitmap, but it doesn't initialize the buffer. Applications can use\n          FPDFBitmap_FillRect() to fill the bitmap using any color. If the OS\n          allows it, this function can allocate up to 4 GB of memory."]
    pub fn FPDFBitmap_Create(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        alpha: ::std::os::raw::c_int,
    ) -> FPDF_BITMAP;
}
extern "C" {
    #[doc = " Function: FPDFBitmap_CreateEx\n          Create a device independent bitmap (FXDIB)\n Parameters:\n          width       -   The number of pixels in width for the bitmap.\n                          Must be greater than 0.\n          height      -   The number of pixels in height for the bitmap.\n                          Must be greater than 0.\n          format      -   A number indicating for bitmap format, as defined\n                          above.\n          first_scan  -   A pointer to the first byte of the first line if\n                          using an external buffer. If this parameter is NULL,\n                          then the a new buffer will be created.\n          stride      -   Number of bytes for each scan line, for external\n                          buffer only.\n Return value:\n          The bitmap handle, or NULL if parameter error or out of memory.\n Comments:\n          Similar to FPDFBitmap_Create function, but allows for more formats\n          and an external buffer is supported. The bitmap created by this\n          function can be used in any place that a FPDF_BITMAP handle is\n          required.\n\n          If an external buffer is used, then the application should destroy\n          the buffer by itself. FPDFBitmap_Destroy function will not destroy\n          the buffer."]
    pub fn FPDFBitmap_CreateEx(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        format: ::std::os::raw::c_int,
        first_scan: *mut ::std::os::raw::c_void,
        stride: ::std::os::raw::c_int,
    ) -> FPDF_BITMAP;
}
extern "C" {
    #[doc = " Function: FPDFBitmap_GetFormat\n          Get the format of the bitmap.\n Parameters:\n          bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create\n                          or FPDFImageObj_GetBitmap.\n Return value:\n          The format of the bitmap.\n Comments:\n          Only formats supported by FPDFBitmap_CreateEx are supported by this\n          function; see the list of such formats above."]
    pub fn FPDFBitmap_GetFormat(bitmap: FPDF_BITMAP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDFBitmap_FillRect\n          Fill a rectangle in a bitmap.\n Parameters:\n          bitmap      -   The handle to the bitmap. Returned by\n                          FPDFBitmap_Create.\n          left        -   The left position. Starting from 0 at the\n                          left-most pixel.\n          top         -   The top position. Starting from 0 at the\n                          top-most line.\n          width       -   Width in pixels to be filled.\n          height      -   Height in pixels to be filled.\n          color       -   A 32-bit value specifing the color, in 8888 ARGB\n                          format.\n Return value:\n          None.\n Comments:\n          This function sets the color and (optionally) alpha value in the\n          specified region of the bitmap.\n\n          NOTE: If the alpha channel is used, this function does NOT\n          composite the background with the source color, instead the\n          background will be replaced by the source color and the alpha.\n\n          If the alpha channel is not used, the alpha parameter is ignored."]
    pub fn FPDFBitmap_FillRect(
        bitmap: FPDF_BITMAP,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        color: FPDF_DWORD,
    );
}
extern "C" {
    #[doc = " Function: FPDFBitmap_GetBuffer\n          Get data buffer of a bitmap.\n Parameters:\n          bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create\n                          or FPDFImageObj_GetBitmap.\n Return value:\n          The pointer to the first byte of the bitmap buffer.\n Comments:\n          The stride may be more than width * number of bytes per pixel\n\n          Applications can use this function to get the bitmap buffer pointer,\n          then manipulate any color and/or alpha values for any pixels in the\n          bitmap.\n\n          The data is in BGRA format. Where the A maybe unused if alpha was\n          not specified."]
    pub fn FPDFBitmap_GetBuffer(bitmap: FPDF_BITMAP) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Function: FPDFBitmap_GetWidth\n          Get width of a bitmap.\n Parameters:\n          bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create\n                          or FPDFImageObj_GetBitmap.\n Return value:\n          The width of the bitmap in pixels."]
    pub fn FPDFBitmap_GetWidth(bitmap: FPDF_BITMAP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDFBitmap_GetHeight\n          Get height of a bitmap.\n Parameters:\n          bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create\n                          or FPDFImageObj_GetBitmap.\n Return value:\n          The height of the bitmap in pixels."]
    pub fn FPDFBitmap_GetHeight(bitmap: FPDF_BITMAP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDFBitmap_GetStride\n          Get number of bytes for each line in the bitmap buffer.\n Parameters:\n          bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create\n                          or FPDFImageObj_GetBitmap.\n Return value:\n          The number of bytes for each line in the bitmap buffer.\n Comments:\n          The stride may be more than width * number of bytes per pixel."]
    pub fn FPDFBitmap_GetStride(bitmap: FPDF_BITMAP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDFBitmap_Destroy\n          Destroy a bitmap and release all related buffers.\n Parameters:\n          bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create\n                          or FPDFImageObj_GetBitmap.\n Return value:\n          None.\n Comments:\n          This function will not destroy any external buffers provided when\n          the bitmap was created."]
    pub fn FPDFBitmap_Destroy(bitmap: FPDF_BITMAP);
}
extern "C" {
    #[doc = " Function: FPDF_VIEWERREF_GetPrintScaling\n          Whether the PDF document prefers to be scaled or not.\n Parameters:\n          document    -   Handle to the loaded document.\n Return value:\n          None."]
    pub fn FPDF_VIEWERREF_GetPrintScaling(document: FPDF_DOCUMENT) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDF_VIEWERREF_GetNumCopies\n          Returns the number of copies to be printed.\n Parameters:\n          document    -   Handle to the loaded document.\n Return value:\n          The number of copies to be printed."]
    pub fn FPDF_VIEWERREF_GetNumCopies(document: FPDF_DOCUMENT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDF_VIEWERREF_GetPrintPageRange\n          Page numbers to initialize print dialog box when file is printed.\n Parameters:\n          document    -   Handle to the loaded document.\n Return value:\n          The print page range to be used for printing."]
    pub fn FPDF_VIEWERREF_GetPrintPageRange(document: FPDF_DOCUMENT) -> FPDF_PAGERANGE;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDF_VIEWERREF_GetPrintPageRangeCount\n          Returns the number of elements in a FPDF_PAGERANGE.\n Parameters:\n          pagerange   -   Handle to the page range.\n Return value:\n          The number of elements in the page range. Returns 0 on error."]
    pub fn FPDF_VIEWERREF_GetPrintPageRangeCount(pagerange: FPDF_PAGERANGE) -> usize;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDF_VIEWERREF_GetPrintPageRangeElement\n          Returns an element from a FPDF_PAGERANGE.\n Parameters:\n          pagerange   -   Handle to the page range.\n          index       -   Index of the element.\n Return value:\n          The value of the element in the page range at a given index.\n          Returns -1 on error."]
    pub fn FPDF_VIEWERREF_GetPrintPageRangeElement(
        pagerange: FPDF_PAGERANGE,
        index: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDF_VIEWERREF_GetDuplex\n          Returns the paper handling option to be used when printing from\n          the print dialog.\n Parameters:\n          document    -   Handle to the loaded document.\n Return value:\n          The paper handling option to be used when printing."]
    pub fn FPDF_VIEWERREF_GetDuplex(document: FPDF_DOCUMENT) -> FPDF_DUPLEXTYPE;
}
extern "C" {
    #[doc = " Function: FPDF_VIEWERREF_GetName\n          Gets the contents for a viewer ref, with a given key. The value must\n          be of type \"name\".\n Parameters:\n          document    -   Handle to the loaded document.\n          key         -   Name of the key in the viewer pref dictionary,\n                          encoded in UTF-8.\n          buffer      -   A string to write the contents of the key to.\n          length      -   Length of the buffer.\n Return value:\n          The number of bytes in the contents, including the NULL terminator.\n          Thus if the return value is 0, then that indicates an error, such\n          as when |document| is invalid or |buffer| is NULL. If |length| is\n          less than the returned length, or |buffer| is NULL, |buffer| will\n          not be modified."]
    pub fn FPDF_VIEWERREF_GetName(
        document: FPDF_DOCUMENT,
        key: FPDF_BYTESTRING,
        buffer: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Function: FPDF_CountNamedDests\n          Get the count of named destinations in the PDF document.\n Parameters:\n          document    -   Handle to a document\n Return value:\n          The count of named destinations."]
    pub fn FPDF_CountNamedDests(document: FPDF_DOCUMENT) -> FPDF_DWORD;
}
extern "C" {
    #[doc = " Function: FPDF_GetNamedDestByName\n          Get a the destination handle for the given name.\n Parameters:\n          document    -   Handle to the loaded document.\n          name        -   The name of a destination.\n Return value:\n          The handle to the destination."]
    pub fn FPDF_GetNamedDestByName(document: FPDF_DOCUMENT, name: FPDF_BYTESTRING) -> FPDF_DEST;
}
extern "C" {
    #[doc = " Function: FPDF_GetNamedDest\n          Get the named destination by index.\n Parameters:\n          document        -   Handle to a document\n          index           -   The index of a named destination.\n          buffer          -   The buffer to store the destination name,\n                              used as wchar_t*.\n          buflen [in/out] -   Size of the buffer in bytes on input,\n                              length of the result in bytes on output\n                              or -1 if the buffer is too small.\n Return value:\n          The destination handle for a given index, or NULL if there is no\n          named destination corresponding to |index|.\n Comments:\n          Call this function twice to get the name of the named destination:\n            1) First time pass in |buffer| as NULL and get buflen.\n            2) Second time pass in allocated |buffer| and buflen to retrieve\n               |buffer|, which should be used as wchar_t*.\n\n         If buflen is not sufficiently large, it will be set to -1 upon\n         return."]
    pub fn FPDF_GetNamedDest(
        document: FPDF_DOCUMENT,
        index: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        buflen: *mut ::std::os::raw::c_long,
    ) -> FPDF_DEST;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDF_GetXFAPacketCount\n          Get the number of valid packets in the XFA entry.\n Parameters:\n          document - Handle to the document.\n Return value:\n          The number of valid packets, or -1 on error."]
    pub fn FPDF_GetXFAPacketCount(document: FPDF_DOCUMENT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDF_GetXFAPacketName\n          Get the name of a packet in the XFA array.\n Parameters:\n          document - Handle to the document.\n          index    - Index number of the packet. 0 for the first packet.\n          buffer   - Buffer for holding the name of the XFA packet.\n          buflen   - Length of |buffer| in bytes.\n Return value:\n          The length of the packet name in bytes, or 0 on error.\n\n |document| must be valid and |index| must be in the range [0, N), where N is\n the value returned by FPDF_GetXFAPacketCount().\n |buffer| is only modified if it is non-NULL and |buflen| is greater than or\n equal to the length of the packet name. The packet name includes a\n terminating NUL character. |buffer| is unmodified on error."]
    pub fn FPDF_GetXFAPacketName(
        document: FPDF_DOCUMENT,
        index: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDF_GetXFAPacketContent\n          Get the content of a packet in the XFA array.\n Parameters:\n          document   - Handle to the document.\n          index      - Index number of the packet. 0 for the first packet.\n          buffer     - Buffer for holding the content of the XFA packet.\n          buflen     - Length of |buffer| in bytes.\n          out_buflen - Pointer to the variable that will receive the minimum\n                       buffer size needed to contain the content of the XFA\n                       packet.\n Return value:\n          Whether the operation succeeded or not.\n\n |document| must be valid and |index| must be in the range [0, N), where N is\n the value returned by FPDF_GetXFAPacketCount(). |out_buflen| must not be\n NULL. When the aforementioned arguments are valid, the operation succeeds,\n and |out_buflen| receives the content size. |buffer| is only modified if\n |buffer| is non-null and long enough to contain the content. Callers must\n check both the return value and the input |buflen| is no less than the\n returned |out_buflen| before using the data in |buffer|."]
    pub fn FPDF_GetXFAPacketContent(
        document: FPDF_DOCUMENT,
        index: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
        out_buflen: *mut ::std::os::raw::c_ulong,
    ) -> FPDF_BOOL;
}
pub const FPDF_FILEIDTYPE_FILEIDTYPE_PERMANENT: FPDF_FILEIDTYPE = 0;
pub const FPDF_FILEIDTYPE_FILEIDTYPE_CHANGING: FPDF_FILEIDTYPE = 1;
#[doc = " The file identifier entry type. See section 14.4 \"File Identifiers\" of the\n ISO 32000-1:2008 spec."]
pub type FPDF_FILEIDTYPE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_QUADPOINTSF {
    pub x1: FS_FLOAT,
    pub y1: FS_FLOAT,
    pub x2: FS_FLOAT,
    pub y2: FS_FLOAT,
    pub x3: FS_FLOAT,
    pub y3: FS_FLOAT,
    pub x4: FS_FLOAT,
    pub y4: FS_FLOAT,
}
#[test]
fn bindgen_test_layout__FS_QUADPOINTSF() {
    const UNINIT: ::std::mem::MaybeUninit<_FS_QUADPOINTSF> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FS_QUADPOINTSF>(),
        32usize,
        concat!("Size of: ", stringify!(_FS_QUADPOINTSF))
    );
    assert_eq!(
        ::std::mem::align_of::<_FS_QUADPOINTSF>(),
        4usize,
        concat!("Alignment of ", stringify!(_FS_QUADPOINTSF))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_QUADPOINTSF),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_QUADPOINTSF),
            "::",
            stringify!(y1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_QUADPOINTSF),
            "::",
            stringify!(x2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y2) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_QUADPOINTSF),
            "::",
            stringify!(y2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_QUADPOINTSF),
            "::",
            stringify!(x3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y3) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_QUADPOINTSF),
            "::",
            stringify!(y3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x4) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_QUADPOINTSF),
            "::",
            stringify!(x4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y4) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_QUADPOINTSF),
            "::",
            stringify!(y4)
        )
    );
}
pub type FS_QUADPOINTSF = _FS_QUADPOINTSF;
extern "C" {
    #[doc = " Get the first child of |bookmark|, or the first top-level bookmark item.\n\n   document - handle to the document.\n   bookmark - handle to the current bookmark. Pass NULL for the first top\n              level item.\n\n Returns a handle to the first child of |bookmark| or the first top-level\n bookmark item. NULL if no child or top-level bookmark found."]
    pub fn FPDFBookmark_GetFirstChild(
        document: FPDF_DOCUMENT,
        bookmark: FPDF_BOOKMARK,
    ) -> FPDF_BOOKMARK;
}
extern "C" {
    #[doc = " Get the next sibling of |bookmark|.\n\n   document - handle to the document.\n   bookmark - handle to the current bookmark.\n\n Returns a handle to the next sibling of |bookmark|, or NULL if this is the\n last bookmark at this level.\n\n Note that the caller is responsible for handling circular bookmark\n references, as may arise from malformed documents."]
    pub fn FPDFBookmark_GetNextSibling(
        document: FPDF_DOCUMENT,
        bookmark: FPDF_BOOKMARK,
    ) -> FPDF_BOOKMARK;
}
extern "C" {
    #[doc = " Get the title of |bookmark|.\n\n   bookmark - handle to the bookmark.\n   buffer   - buffer for the title. May be NULL.\n   buflen   - the length of the buffer in bytes. May be 0.\n\n Returns the number of bytes in the title, including the terminating NUL\n character. The number of bytes is returned regardless of the |buffer| and\n |buflen| parameters.\n\n Regardless of the platform, the |buffer| is always in UTF-16LE encoding. The\n string is terminated by a UTF16 NUL character. If |buflen| is less than the\n required length, or |buffer| is NULL, |buffer| will not be modified."]
    pub fn FPDFBookmark_GetTitle(
        bookmark: FPDF_BOOKMARK,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Find the bookmark with |title| in |document|.\n\n   document - handle to the document.\n   title    - the UTF-16LE encoded Unicode title for which to search.\n\n Returns the handle to the bookmark, or NULL if |title| can't be found.\n\n FPDFBookmark_Find() will always return the first bookmark found even if\n multiple bookmarks have the same |title|."]
    pub fn FPDFBookmark_Find(document: FPDF_DOCUMENT, title: FPDF_WIDESTRING) -> FPDF_BOOKMARK;
}
extern "C" {
    #[doc = " Get the destination associated with |bookmark|.\n\n   document - handle to the document.\n   bookmark - handle to the bookmark.\n\n Returns the handle to the destination data, or NULL if no destination is\n associated with |bookmark|."]
    pub fn FPDFBookmark_GetDest(document: FPDF_DOCUMENT, bookmark: FPDF_BOOKMARK) -> FPDF_DEST;
}
extern "C" {
    #[doc = " Get the action associated with |bookmark|.\n\n   bookmark - handle to the bookmark.\n\n Returns the handle to the action data, or NULL if no action is associated\n with |bookmark|.\n If this function returns a valid handle, it is valid as long as |bookmark| is\n valid.\n If this function returns NULL, FPDFBookmark_GetDest() should be called to get\n the |bookmark| destination data."]
    pub fn FPDFBookmark_GetAction(bookmark: FPDF_BOOKMARK) -> FPDF_ACTION;
}
extern "C" {
    #[doc = " Get the type of |action|.\n\n   action - handle to the action.\n\n Returns one of:\n   PDFACTION_UNSUPPORTED\n   PDFACTION_GOTO\n   PDFACTION_REMOTEGOTO\n   PDFACTION_URI\n   PDFACTION_LAUNCH"]
    pub fn FPDFAction_GetType(action: FPDF_ACTION) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Get the destination of |action|.\n\n   document - handle to the document.\n   action   - handle to the action. |action| must be a |PDFACTION_GOTO| or\n              |PDFACTION_REMOTEGOTO|.\n\n Returns a handle to the destination data, or NULL on error, typically\n because the arguments were bad or the action was of the wrong type.\n\n In the case of |PDFACTION_REMOTEGOTO|, you must first call\n FPDFAction_GetFilePath(), then load the document at that path, then pass\n the document handle from that document as |document| to FPDFAction_GetDest()."]
    pub fn FPDFAction_GetDest(document: FPDF_DOCUMENT, action: FPDF_ACTION) -> FPDF_DEST;
}
extern "C" {
    #[doc = " Get the file path of |action|.\n\n   action - handle to the action. |action| must be a |PDFACTION_LAUNCH| or\n            |PDFACTION_REMOTEGOTO|.\n   buffer - a buffer for output the path string. May be NULL.\n   buflen - the length of the buffer, in bytes. May be 0.\n\n Returns the number of bytes in the file path, including the trailing NUL\n character, or 0 on error, typically because the arguments were bad or the\n action was of the wrong type.\n\n Regardless of the platform, the |buffer| is always in UTF-8 encoding.\n If |buflen| is less than the returned length, or |buffer| is NULL, |buffer|\n will not be modified."]
    pub fn FPDFAction_GetFilePath(
        action: FPDF_ACTION,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Get the URI path of |action|.\n\n   document - handle to the document.\n   action   - handle to the action. Must be a |PDFACTION_URI|.\n   buffer   - a buffer for the path string. May be NULL.\n   buflen   - the length of the buffer, in bytes. May be 0.\n\n Returns the number of bytes in the URI path, including the trailing NUL\n character, or 0 on error, typically because the arguments were bad or the\n action was of the wrong type.\n\n The |buffer| is always encoded in 7-bit ASCII. If |buflen| is less than the\n returned length, or |buffer| is NULL, |buffer| will not be modified."]
    pub fn FPDFAction_GetURIPath(
        document: FPDF_DOCUMENT,
        action: FPDF_ACTION,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Get the page index of |dest|.\n\n   document - handle to the document.\n   dest     - handle to the destination.\n\n Returns the 0-based page index containing |dest|. Returns -1 on error."]
    pub fn FPDFDest_GetDestPageIndex(
        document: FPDF_DOCUMENT,
        dest: FPDF_DEST,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Get the view (fit type) specified by |dest|.\n\n   dest         - handle to the destination.\n   pNumParams   - receives the number of view parameters, which is at most 4.\n   pParams      - buffer to write the view parameters. Must be at least 4\n                  FS_FLOATs long.\n Returns one of the PDFDEST_VIEW_* constants, PDFDEST_VIEW_UNKNOWN_MODE if\n |dest| does not specify a view."]
    pub fn FPDFDest_GetView(
        dest: FPDF_DEST,
        pNumParams: *mut ::std::os::raw::c_ulong,
        pParams: *mut FS_FLOAT,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Get the (x, y, zoom) location of |dest| in the destination page, if the\n destination is in [page /XYZ x y zoom] syntax.\n\n   dest       - handle to the destination.\n   hasXVal    - out parameter; true if the x value is not null\n   hasYVal    - out parameter; true if the y value is not null\n   hasZoomVal - out parameter; true if the zoom value is not null\n   x          - out parameter; the x coordinate, in page coordinates.\n   y          - out parameter; the y coordinate, in page coordinates.\n   zoom       - out parameter; the zoom value.\n Returns TRUE on successfully reading the /XYZ value.\n\n Note the [x, y, zoom] values are only set if the corresponding hasXVal,\n hasYVal or hasZoomVal flags are true."]
    pub fn FPDFDest_GetLocationInPage(
        dest: FPDF_DEST,
        hasXVal: *mut FPDF_BOOL,
        hasYVal: *mut FPDF_BOOL,
        hasZoomVal: *mut FPDF_BOOL,
        x: *mut FS_FLOAT,
        y: *mut FS_FLOAT,
        zoom: *mut FS_FLOAT,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Find a link at point (|x|,|y|) on |page|.\n\n   page - handle to the document page.\n   x    - the x coordinate, in the page coordinate system.\n   y    - the y coordinate, in the page coordinate system.\n\n Returns a handle to the link, or NULL if no link found at the given point.\n\n You can convert coordinates from screen coordinates to page coordinates using\n FPDF_DeviceToPage()."]
    pub fn FPDFLink_GetLinkAtPoint(page: FPDF_PAGE, x: f64, y: f64) -> FPDF_LINK;
}
extern "C" {
    #[doc = " Find the Z-order of link at point (|x|,|y|) on |page|.\n\n   page - handle to the document page.\n   x    - the x coordinate, in the page coordinate system.\n   y    - the y coordinate, in the page coordinate system.\n\n Returns the Z-order of the link, or -1 if no link found at the given point.\n Larger Z-order numbers are closer to the front.\n\n You can convert coordinates from screen coordinates to page coordinates using\n FPDF_DeviceToPage()."]
    pub fn FPDFLink_GetLinkZOrderAtPoint(page: FPDF_PAGE, x: f64, y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get destination info for |link|.\n\n   document - handle to the document.\n   link     - handle to the link.\n\n Returns a handle to the destination, or NULL if there is no destination\n associated with the link. In this case, you should call FPDFLink_GetAction()\n to retrieve the action associated with |link|."]
    pub fn FPDFLink_GetDest(document: FPDF_DOCUMENT, link: FPDF_LINK) -> FPDF_DEST;
}
extern "C" {
    #[doc = " Get action info for |link|.\n\n   link - handle to the link.\n\n Returns a handle to the action associated to |link|, or NULL if no action.\n If this function returns a valid handle, it is valid as long as |link| is\n valid."]
    pub fn FPDFLink_GetAction(link: FPDF_LINK) -> FPDF_ACTION;
}
extern "C" {
    #[doc = " Enumerates all the link annotations in |page|.\n\n   page       - handle to the page.\n   start_pos  - the start position, should initially be 0 and is updated with\n                the next start position on return.\n   link_annot - the link handle for |startPos|.\n\n Returns TRUE on success."]
    pub fn FPDFLink_Enumerate(
        page: FPDF_PAGE,
        start_pos: *mut ::std::os::raw::c_int,
        link_annot: *mut FPDF_LINK,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Gets FPDF_ANNOTATION object for |link_annot|.\n\n   page       - handle to the page in which FPDF_LINK object is present.\n   link_annot - handle to link annotation.\n\n Returns FPDF_ANNOTATION from the FPDF_LINK and NULL on failure,\n if the input link annot or page is NULL."]
    pub fn FPDFLink_GetAnnot(page: FPDF_PAGE, link_annot: FPDF_LINK) -> FPDF_ANNOTATION;
}
extern "C" {
    #[doc = " Get the rectangle for |link_annot|.\n\n   link_annot - handle to the link annotation.\n   rect       - the annotation rectangle.\n\n Returns true on success."]
    pub fn FPDFLink_GetAnnotRect(link_annot: FPDF_LINK, rect: *mut FS_RECTF) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get the count of quadrilateral points to the |link_annot|.\n\n   link_annot - handle to the link annotation.\n\n Returns the count of quadrilateral points."]
    pub fn FPDFLink_CountQuadPoints(link_annot: FPDF_LINK) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the quadrilateral points for the specified |quad_index| in |link_annot|.\n\n   link_annot  - handle to the link annotation.\n   quad_index  - the specified quad point index.\n   quad_points - receives the quadrilateral points.\n\n Returns true on success."]
    pub fn FPDFLink_GetQuadPoints(
        link_annot: FPDF_LINK,
        quad_index: ::std::os::raw::c_int,
        quad_points: *mut FS_QUADPOINTSF,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API\n Gets an additional-action from |page|.\n\n   page      - handle to the page, as returned by FPDF_LoadPage().\n   aa_type   - the type of the page object's addtional-action, defined\n               in public/fpdf_formfill.h\n\n   Returns the handle to the action data, or NULL if there is no\n   additional-action of type |aa_type|.\n   If this function returns a valid handle, it is valid as long as |page| is\n   valid."]
    pub fn FPDF_GetPageAAction(page: FPDF_PAGE, aa_type: ::std::os::raw::c_int) -> FPDF_ACTION;
}
extern "C" {
    #[doc = " Experimental API.\n Get the file identifer defined in the trailer of |document|.\n\n   document - handle to the document.\n   id_type  - the file identifier type to retrieve.\n   buffer   - a buffer for the file identifier. May be NULL.\n   buflen   - the length of the buffer, in bytes. May be 0.\n\n Returns the number of bytes in the file identifier, including the NUL\n terminator.\n\n The |buffer| is always a byte string. The |buffer| is followed by a NUL\n terminator.  If |buflen| is less than the returned length, or |buffer| is\n NULL, |buffer| will not be modified."]
    pub fn FPDF_GetFileIdentifier(
        document: FPDF_DOCUMENT,
        id_type: FPDF_FILEIDTYPE,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Get meta-data |tag| content from |document|.\n\n   document - handle to the document.\n   tag      - the tag to retrieve. The tag can be one of:\n                Title, Author, Subject, Keywords, Creator, Producer,\n                CreationDate, or ModDate.\n              For detailed explanations of these tags and their respective\n              values, please refer to PDF Reference 1.6, section 10.2.1,\n              'Document Information Dictionary'.\n   buffer   - a buffer for the tag. May be NULL.\n   buflen   - the length of the buffer, in bytes. May be 0.\n\n Returns the number of bytes in the tag, including trailing zeros.\n\n The |buffer| is always encoded in UTF-16LE. The |buffer| is followed by two\n bytes of zeros indicating the end of the string.  If |buflen| is less than\n the returned length, or |buffer| is NULL, |buffer| will not be modified.\n\n For linearized files, FPDFAvail_IsFormAvail must be called before this, and\n it must have returned PDF_FORM_AVAIL or PDF_FORM_NOTEXIST. Before that, there\n is no guarantee the metadata has been loaded."]
    pub fn FPDF_GetMetaText(
        document: FPDF_DOCUMENT,
        tag: FPDF_BYTESTRING,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Get the page label for |page_index| from |document|.\n\n   document    - handle to the document.\n   page_index  - the 0-based index of the page.\n   buffer      - a buffer for the page label. May be NULL.\n   buflen      - the length of the buffer, in bytes. May be 0.\n\n Returns the number of bytes in the page label, including trailing zeros.\n\n The |buffer| is always encoded in UTF-16LE. The |buffer| is followed by two\n bytes of zeros indicating the end of the string.  If |buflen| is less than\n the returned length, or |buffer| is NULL, |buffer| will not be modified."]
    pub fn FPDF_GetPageLabel(
        document: FPDF_DOCUMENT,
        page_index: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPDF_JsPlatform {
    #[doc = " Version number of the interface. Currently must be 2."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Method: app_alert\n       Pop up a dialog to show warning or hint.\n Interface Version:\n       1\n Implementation Required:\n       yes\n Parameters:\n       pThis       -   Pointer to the interface structure itself.\n       Msg         -   A string containing the message to be displayed.\n       Title       -   The title of the dialog.\n       Type        -   The type of button group, one of the\n                       JSPLATFORM_ALERT_BUTTON_* values above.\n       nIcon       -   The type of the icon, one of the\n                       JSPLATFORM_ALERT_ICON_* above.\n Return Value:\n       Option selected by user in dialogue, one of the\n       JSPLATFORM_ALERT_RETURN_* values above."]
    pub app_alert: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _IPDF_JsPlatform,
            Msg: FPDF_WIDESTRING,
            Title: FPDF_WIDESTRING,
            Type: ::std::os::raw::c_int,
            Icon: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: app_beep\n       Causes the system to play a sound.\n Interface Version:\n       1\n Implementation Required:\n       yes\n Parameters:\n       pThis       -   Pointer to the interface structure itself\n       nType       -   The sound type, see JSPLATFORM_BEEP_TYPE_*\n                       above.\n Return Value:\n       None"]
    pub app_beep: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _IPDF_JsPlatform, nType: ::std::os::raw::c_int),
    >,
    #[doc = " Method: app_response\n       Displays a dialog box containing a question and an entry field for\n       the user to reply to the question.\n Interface Version:\n       1\n Implementation Required:\n       yes\n Parameters:\n       pThis       -   Pointer to the interface structure itself\n       Question    -   The question to be posed to the user.\n       Title       -   The title of the dialog box.\n       Default     -   A default value for the answer to the question. If\n                       not specified, no default value is presented.\n       cLabel      -   A short string to appear in front of and on the\n                       same line as the edit text field.\n       bPassword   -   If true, indicates that the user's response should\n                       be shown as asterisks (*) or bullets (?) to mask\n                       the response, which might be sensitive information.\n       response    -   A string buffer allocated by PDFium, to receive the\n                       user's response.\n       length      -   The length of the buffer in bytes. Currently, it is\n                       always 2048.\n Return Value:\n       Number of bytes the complete user input would actually require, not\n       including trailing zeros, regardless of the value of the length\n       parameter or the presence of the response buffer.\n Comments:\n       No matter on what platform, the response buffer should be always\n       written using UTF-16LE encoding. If a response buffer is\n       present and the size of the user input exceeds the capacity of the\n       buffer as specified by the length parameter, only the\n       first \"length\" bytes of the user input are to be written to the\n       buffer."]
    pub app_response: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _IPDF_JsPlatform,
            Question: FPDF_WIDESTRING,
            Title: FPDF_WIDESTRING,
            Default: FPDF_WIDESTRING,
            cLabel: FPDF_WIDESTRING,
            bPassword: FPDF_BOOL,
            response: *mut ::std::os::raw::c_void,
            length: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: Doc_getFilePath\n       Get the file path of the current document.\n Interface Version:\n       1\n Implementation Required:\n       yes\n Parameters:\n       pThis       -   Pointer to the interface structure itself\n       filePath    -   The string buffer to receive the file path. Can\n                       be NULL.\n       length      -   The length of the buffer, number of bytes. Can\n                       be 0.\n Return Value:\n       Number of bytes the filePath consumes, including trailing zeros.\n Comments:\n       The filePath should always be provided in the local encoding.\n       The return value always indicated number of bytes required for\n       the buffer, even when there is no buffer specified, or the buffer\n       size is less than required. In this case, the buffer will not\n       be modified."]
    pub Doc_getFilePath: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _IPDF_JsPlatform,
            filePath: *mut ::std::os::raw::c_void,
            length: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: Doc_mail\n       Mails the data buffer as an attachment to all recipients, with or\n       without user interaction.\n Interface Version:\n       1\n Implementation Required:\n       yes\n Parameters:\n       pThis       -   Pointer to the interface structure itself\n       mailData    -   Pointer to the data buffer to be sent. Can be NULL.\n       length      -   The size,in bytes, of the buffer pointed by\n                       mailData parameter. Can be 0.\n       bUI         -   If true, the rest of the parameters are used in a\n                       compose-new-message window that is displayed to the\n                       user. If false, the cTo parameter is required and\n                       all others are optional.\n       To          -   A semicolon-delimited list of recipients for the\n                       message.\n       Subject     -   The subject of the message. The length limit is\n                       64 KB.\n       CC          -   A semicolon-delimited list of CC recipients for\n                       the message.\n       BCC         -   A semicolon-delimited list of BCC recipients for\n                       the message.\n       Msg         -   The content of the message. The length limit is\n                       64 KB.\n Return Value:\n       None.\n Comments:\n       If the parameter mailData is NULL or length is 0, the current\n       document will be mailed as an attachment to all recipients."]
    pub Doc_mail: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _IPDF_JsPlatform,
            mailData: *mut ::std::os::raw::c_void,
            length: ::std::os::raw::c_int,
            bUI: FPDF_BOOL,
            To: FPDF_WIDESTRING,
            Subject: FPDF_WIDESTRING,
            CC: FPDF_WIDESTRING,
            BCC: FPDF_WIDESTRING,
            Msg: FPDF_WIDESTRING,
        ),
    >,
    #[doc = " Method: Doc_print\n       Prints all or a specific number of pages of the document.\n Interface Version:\n       1\n Implementation Required:\n       yes\n Parameters:\n       pThis         -   Pointer to the interface structure itself.\n       bUI           -   If true, will cause a UI to be presented to the\n                         user to obtain printing information and confirm\n                         the action.\n       nStart        -   A 0-based index that defines the start of an\n                         inclusive range of pages.\n       nEnd          -   A 0-based index that defines the end of an\n                         inclusive page range.\n       bSilent       -   If true, suppresses the cancel dialog box while\n                         the document is printing. The default is false.\n       bShrinkToFit  -   If true, the page is shrunk (if necessary) to\n                         fit within the imageable area of the printed page.\n       bPrintAsImage -   If true, print pages as an image.\n       bReverse      -   If true, print from nEnd to nStart.\n       bAnnotations  -   If true (the default), annotations are\n                         printed.\n Return Value:\n       None."]
    pub Doc_print: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _IPDF_JsPlatform,
            bUI: FPDF_BOOL,
            nStart: ::std::os::raw::c_int,
            nEnd: ::std::os::raw::c_int,
            bSilent: FPDF_BOOL,
            bShrinkToFit: FPDF_BOOL,
            bPrintAsImage: FPDF_BOOL,
            bReverse: FPDF_BOOL,
            bAnnotations: FPDF_BOOL,
        ),
    >,
    #[doc = " Method: Doc_submitForm\n       Send the form data to a specified URL.\n Interface Version:\n       1\n Implementation Required:\n       yes\n Parameters:\n       pThis       -   Pointer to the interface structure itself\n       formData    -   Pointer to the data buffer to be sent.\n       length      -   The size,in bytes, of the buffer pointed by\n                       formData parameter.\n       URL         -   The URL to send to.\n Return Value:\n       None."]
    pub Doc_submitForm: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _IPDF_JsPlatform,
            formData: *mut ::std::os::raw::c_void,
            length: ::std::os::raw::c_int,
            URL: FPDF_WIDESTRING,
        ),
    >,
    #[doc = " Method: Doc_gotoPage\n       Jump to a specified page.\n Interface Version:\n       1\n Implementation Required:\n       yes\n Parameters:\n       pThis       -   Pointer to the interface structure itself\n       nPageNum    -   The specified page number, zero for the first page.\n Return Value:\n       None.\n"]
    pub Doc_gotoPage: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _IPDF_JsPlatform, nPageNum: ::std::os::raw::c_int),
    >,
    #[doc = " Method: Field_browse\n       Show a file selection dialog, and return the selected file path.\n Interface Version:\n       1\n Implementation Required:\n       yes\n Parameters:\n       pThis       -   Pointer to the interface structure itself.\n       filePath    -   Pointer to the data buffer to receive the file\n                       path. Can be NULL.\n       length      -   The length of the buffer, in bytes. Can be 0.\n Return Value:\n       Number of bytes the filePath consumes, including trailing zeros.\n Comments:\n       The filePath shoule always be provided in local encoding."]
    pub Field_browse: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _IPDF_JsPlatform,
            filePath: *mut ::std::os::raw::c_void,
            length: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Pointer to FPDF_FORMFILLINFO interface."]
    pub m_pFormfillinfo: *mut ::std::os::raw::c_void,
    #[doc = " Unused in v3, retain for compatibility."]
    pub m_isolate: *mut ::std::os::raw::c_void,
    #[doc = " Unused in v3, retain for compatibility."]
    pub m_v8EmbedderSlot: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__IPDF_JsPlatform() {
    const UNINIT: ::std::mem::MaybeUninit<_IPDF_JsPlatform> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IPDF_JsPlatform>(),
        104usize,
        concat!("Size of: ", stringify!(_IPDF_JsPlatform))
    );
    assert_eq!(
        ::std::mem::align_of::<_IPDF_JsPlatform>(),
        8usize,
        concat!("Alignment of ", stringify!(_IPDF_JsPlatform))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).app_alert) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(app_alert)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).app_beep) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(app_beep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).app_response) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(app_response)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Doc_getFilePath) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(Doc_getFilePath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Doc_mail) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(Doc_mail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Doc_print) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(Doc_print)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Doc_submitForm) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(Doc_submitForm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Doc_gotoPage) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(Doc_gotoPage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Field_browse) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(Field_browse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pFormfillinfo) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(m_pFormfillinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_isolate) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(m_isolate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_v8EmbedderSlot) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(m_v8EmbedderSlot)
        )
    );
}
pub type IPDF_JSPLATFORM = _IPDF_JsPlatform;
#[doc = " Function signature for the callback function passed to the FFI_SetTimer\n method.\n Parameters:\n          idEvent     -   Identifier of the timer.\n Return value:\n          None."]
pub type TimerCallback =
    ::std::option::Option<unsafe extern "C" fn(idEvent: ::std::os::raw::c_int)>;
#[doc = " Declares of a struct type to the local system time."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FPDF_SYSTEMTIME {
    #[doc = " years since 1900"]
    pub wYear: ::std::os::raw::c_ushort,
    #[doc = " months since January - [0,11]"]
    pub wMonth: ::std::os::raw::c_ushort,
    #[doc = " days since Sunday - [0,6]"]
    pub wDayOfWeek: ::std::os::raw::c_ushort,
    #[doc = " day of the month - [1,31]"]
    pub wDay: ::std::os::raw::c_ushort,
    #[doc = " hours since midnight - [0,23]"]
    pub wHour: ::std::os::raw::c_ushort,
    #[doc = " minutes after the hour - [0,59]"]
    pub wMinute: ::std::os::raw::c_ushort,
    #[doc = " seconds after the minute - [0,59]"]
    pub wSecond: ::std::os::raw::c_ushort,
    #[doc = " milliseconds after the second - [0,999]"]
    pub wMilliseconds: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__FPDF_SYSTEMTIME() {
    const UNINIT: ::std::mem::MaybeUninit<_FPDF_SYSTEMTIME> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FPDF_SYSTEMTIME>(),
        16usize,
        concat!("Size of: ", stringify!(_FPDF_SYSTEMTIME))
    );
    assert_eq!(
        ::std::mem::align_of::<_FPDF_SYSTEMTIME>(),
        2usize,
        concat!("Alignment of ", stringify!(_FPDF_SYSTEMTIME))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wYear) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSTEMTIME),
            "::",
            stringify!(wYear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wMonth) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSTEMTIME),
            "::",
            stringify!(wMonth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wDayOfWeek) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSTEMTIME),
            "::",
            stringify!(wDayOfWeek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wDay) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSTEMTIME),
            "::",
            stringify!(wDay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wHour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSTEMTIME),
            "::",
            stringify!(wHour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wMinute) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSTEMTIME),
            "::",
            stringify!(wMinute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wSecond) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSTEMTIME),
            "::",
            stringify!(wSecond)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wMilliseconds) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSTEMTIME),
            "::",
            stringify!(wMilliseconds)
        )
    );
}
#[doc = " Declares of a struct type to the local system time."]
pub type FPDF_SYSTEMTIME = _FPDF_SYSTEMTIME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FPDF_FORMFILLINFO {
    #[doc = " Version number of the interface.\n Version 1 contains stable interfaces. Version 2 has additional\n experimental interfaces.\n When PDFium is built without the XFA module, version can be 1 or 2.\n With version 1, only stable interfaces are called. With version 2,\n additional experimental interfaces are also called.\n When PDFium is built with the XFA module, version must be 2.\n All the XFA related interfaces are experimental. If PDFium is built with\n the XFA module and version 1 then none of the XFA related interfaces\n would be called. When PDFium is built with XFA module then the version\n must be 2."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Version 1. */\n/*\n Method: Release\n       Give the implementation a chance to release any resources after the\n       interface is no longer used.\n Interface Version:\n       1\n Implementation Required:\n       No\n Comments:\n       Called by PDFium during the final cleanup process.\n Parameters:\n       pThis       -   Pointer to the interface structure itself\n Return Value:\n       None"]
    pub Release: ::std::option::Option<unsafe extern "C" fn(pThis: *mut _FPDF_FORMFILLINFO)>,
    #[doc = " Method: FFI_Invalidate\n       Invalidate the client area within the specified rectangle.\n Interface Version:\n       1\n Implementation Required:\n       yes\n Parameters:\n       pThis       -   Pointer to the interface structure itself.\n       page        -   Handle to the page. Returned by FPDF_LoadPage().\n       left        -   Left position of the client area in PDF page\n                       coordinates.\n       top         -   Top position of the client area in PDF page\n                       coordinates.\n       right       -   Right position of the client area in PDF page\n                       coordinates.\n       bottom      -   Bottom position of the client area in PDF page\n                       coordinates.\n Return Value:\n       None.\n Comments:\n       All positions are measured in PDF \"user space\".\n       Implementation should call FPDF_RenderPageBitmap() for repainting\n       the specified page area."]
    pub FFI_Invalidate: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            page: FPDF_PAGE,
            left: f64,
            top: f64,
            right: f64,
            bottom: f64,
        ),
    >,
    #[doc = " Method: FFI_OutputSelectedRect\n       When the user selects text in form fields with the mouse, this\n       callback function will be invoked with the selected areas.\n Interface Version:\n       1\n Implementation Required:\n       No\n Parameters:\n       pThis       -   Pointer to the interface structure itself.\n       page        -   Handle to the page. Returned by FPDF_LoadPage()/\n       left        -   Left position of the client area in PDF page\n                       coordinates.\n       top         -   Top position of the client area in PDF page\n                       coordinates.\n       right       -   Right position of the client area in PDF page\n                       coordinates.\n       bottom      -   Bottom position of the client area in PDF page\n                       coordinates.\n Return Value:\n       None.\n Comments:\n       This callback function is useful for implementing special text\n       selection effects. An implementation should first record the\n       returned rectangles, then draw them one by one during the next\n       painting period. Lastly, it should remove all the recorded\n       rectangles when finished painting."]
    pub FFI_OutputSelectedRect: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            page: FPDF_PAGE,
            left: f64,
            top: f64,
            right: f64,
            bottom: f64,
        ),
    >,
    #[doc = " Method: FFI_SetCursor\n       Set the Cursor shape.\n Interface Version:\n       1\n Implementation Required:\n       yes\n Parameters:\n       pThis       -   Pointer to the interface structure itself.\n       nCursorType -   Cursor type, see Flags for Cursor type for details.\n Return value:\n       None."]
    pub FFI_SetCursor: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FPDF_FORMFILLINFO, nCursorType: ::std::os::raw::c_int),
    >,
    #[doc = " Method: FFI_SetTimer\n       This method installs a system timer. An interval value is specified,\n       and every time that interval elapses, the system must call into the\n       callback function with the timer ID as returned by this function.\n Interface Version:\n       1\n Implementation Required:\n       yes\n Parameters:\n       pThis       -   Pointer to the interface structure itself.\n       uElapse     -   Specifies the time-out value, in milliseconds.\n       lpTimerFunc -   A pointer to the callback function-TimerCallback.\n Return value:\n       The timer identifier of the new timer if the function is successful.\n       An application passes this value to the FFI_KillTimer method to kill\n       the timer. Nonzero if it is successful; otherwise, it is zero."]
    pub FFI_SetTimer: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            uElapse: ::std::os::raw::c_int,
            lpTimerFunc: TimerCallback,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: FFI_KillTimer\n       This method uninstalls a system timer, as set by an earlier call to\n       FFI_SetTimer.\n Interface Version:\n       1\n Implementation Required:\n       yes\n Parameters:\n       pThis       -   Pointer to the interface structure itself.\n       nTimerID    -   The timer ID returned by FFI_SetTimer function.\n Return value:\n       None."]
    pub FFI_KillTimer: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FPDF_FORMFILLINFO, nTimerID: ::std::os::raw::c_int),
    >,
    #[doc = " Method: FFI_GetLocalTime\n       This method receives the current local time on the system.\n Interface Version:\n       1\n Implementation Required:\n       yes\n Parameters:\n       pThis       -   Pointer to the interface structure itself.\n Return value:\n       The local time. See FPDF_SYSTEMTIME above for details.\n Note: Unused."]
    pub FFI_GetLocalTime: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FPDF_FORMFILLINFO) -> FPDF_SYSTEMTIME,
    >,
    #[doc = " Method: FFI_OnChange\n       This method will be invoked to notify the implementation when the\n       value of any FormField on the document had been changed.\n Interface Version:\n       1\n Implementation Required:\n       no\n Parameters:\n       pThis       -   Pointer to the interface structure itself.\n Return value:\n       None."]
    pub FFI_OnChange: ::std::option::Option<unsafe extern "C" fn(pThis: *mut _FPDF_FORMFILLINFO)>,
    #[doc = " Method: FFI_GetPage\n       This method receives the page handle associated with a specified\n       page index.\n Interface Version:\n       1\n Implementation Required:\n       yes\n Parameters:\n       pThis       -   Pointer to the interface structure itself.\n       document    -   Handle to document. Returned by FPDF_LoadDocument().\n       nPageIndex  -   Index number of the page. 0 for the first page.\n Return value:\n       Handle to the page, as previously returned to the implementation by\n       FPDF_LoadPage().\n Comments:\n       The implementation is expected to keep track of the page handles it\n       receives from PDFium, and their mappings to page numbers. In some\n       cases, the document-level JavaScript action may refer to a page\n       which hadn't been loaded yet. To successfully run the Javascript\n       action, the implementation needs to load the page."]
    pub FFI_GetPage: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            document: FPDF_DOCUMENT,
            nPageIndex: ::std::os::raw::c_int,
        ) -> FPDF_PAGE,
    >,
    #[doc = " Method: FFI_GetCurrentPage\n       This method receives the handle to the current page.\n Interface Version:\n       1\n Implementation Required:\n       Yes when V8 support is present, otherwise unused.\n Parameters:\n       pThis       -   Pointer to the interface structure itself.\n       document    -   Handle to document. Returned by FPDF_LoadDocument().\n Return value:\n       Handle to the page. Returned by FPDF_LoadPage().\n Comments:\n       PDFium doesn't keep keep track of the \"current page\" (e.g. the one\n       that is most visible on screen), so it must ask the embedder for\n       this information."]
    pub FFI_GetCurrentPage: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FPDF_FORMFILLINFO, document: FPDF_DOCUMENT) -> FPDF_PAGE,
    >,
    #[doc = " Method: FFI_GetRotation\n       This method receives currently rotation of the page view.\n Interface Version:\n       1\n Implementation Required:\n       yes\n Parameters:\n       pThis       -   Pointer to the interface structure itself.\n       page        -   Handle to page, as returned by FPDF_LoadPage().\n Return value:\n       A number to indicate the page rotation in 90 degree increments\n       in a clockwise direction:\n         0 - 0 degrees\n         1 - 90 degrees\n         2 - 180 degrees\n         3 - 270 degrees\n Note: Unused."]
    pub FFI_GetRotation: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            page: FPDF_PAGE,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: FFI_ExecuteNamedAction\n       This method will execute a named action.\n Interface Version:\n       1\n Implementation Required:\n       yes\n Parameters:\n       pThis           -   Pointer to the interface structure itself.\n       namedAction     -   A byte string which indicates the named action,\n                           terminated by 0.\n Return value:\n       None.\n Comments:\n       See the named actions description of <<PDF Reference, version 1.7>>\n       for more details."]
    pub FFI_ExecuteNamedAction: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FPDF_FORMFILLINFO, namedAction: FPDF_BYTESTRING),
    >,
    #[doc = " Method: FFI_SetTextFieldFocus\n       Called when a text field is getting or losing focus.\n Interface Version:\n       1\n Implementation Required:\n       no\n Parameters:\n       pThis           -   Pointer to the interface structure itself.\n       value           -   The string value of the form field, in UTF-16LE\n                           format.\n       valueLen        -   The length of the string value. This is the\n                           number of characters, not bytes.\n       is_focus        -   True if the form field is getting focus, false\n                           if the form field is losing focus.\n Return value:\n       None.\n Comments:\n       Only supports text fields and combobox fields."]
    pub FFI_SetTextFieldFocus: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            value: FPDF_WIDESTRING,
            valueLen: FPDF_DWORD,
            is_focus: FPDF_BOOL,
        ),
    >,
    #[doc = " Method: FFI_DoURIAction\n       Ask the implementation to navigate to a uniform resource identifier.\n Interface Version:\n       1\n Implementation Required:\n       No\n Parameters:\n       pThis           -   Pointer to the interface structure itself.\n       bsURI           -   A byte string which indicates the uniform\n                           resource identifier, terminated by 0.\n Return value:\n       None.\n Comments:\n       If the embedder is version 2 or higher and have implementation for\n       FFI_DoURIActionWithKeyboardModifier, then\n       FFI_DoURIActionWithKeyboardModifier takes precedence over\n       FFI_DoURIAction.\n       See the URI actions description of <<PDF Reference, version 1.7>>\n       for more details."]
    pub FFI_DoURIAction: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FPDF_FORMFILLINFO, bsURI: FPDF_BYTESTRING),
    >,
    #[doc = " Method: FFI_DoGoToAction\n       This action changes the view to a specified destination.\n Interface Version:\n       1\n Implementation Required:\n       No\n Parameters:\n       pThis           -   Pointer to the interface structure itself.\n       nPageIndex      -   The index of the PDF page.\n       zoomMode        -   The zoom mode for viewing page. See below.\n       fPosArray       -   The float array which carries the position info.\n       sizeofArray     -   The size of float array.\n PDFZoom values:\n         - XYZ = 1\n         - FITPAGE = 2\n         - FITHORZ = 3\n         - FITVERT = 4\n         - FITRECT = 5\n         - FITBBOX = 6\n         - FITBHORZ = 7\n         - FITBVERT = 8\n Return value:\n       None.\n Comments:\n       See the Destinations description of <<PDF Reference, version 1.7>>\n       in 8.2.1 for more details."]
    pub FFI_DoGoToAction: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            nPageIndex: ::std::os::raw::c_int,
            zoomMode: ::std::os::raw::c_int,
            fPosArray: *mut f32,
            sizeofArray: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Pointer to IPDF_JSPLATFORM interface.\n Unused if PDFium is built without V8 support. Otherwise, if NULL, then\n JavaScript will be prevented from executing while rendering the document."]
    pub m_pJsPlatform: *mut IPDF_JSPLATFORM,
    #[doc = " Version 2 - Experimental. */\n/*\n Whether the XFA module is disabled when built with the XFA module.\n Interface Version:\n       Ignored if |version| < 2."]
    pub xfa_disabled: FPDF_BOOL,
    #[doc = " Method: FFI_DisplayCaret\n       This method will show the caret at specified position.\n Interface Version:\n       Ignored if |version| < 2.\n Implementation Required:\n       Required for XFA, otherwise set to NULL.\n Parameters:\n       pThis           -   Pointer to the interface structure itself.\n       page            -   Handle to page. Returned by FPDF_LoadPage().\n       left            -   Left position of the client area in PDF page\n                           coordinates.\n       top             -   Top position of the client area in PDF page\n                           coordinates.\n       right           -   Right position of the client area in PDF page\n                           coordinates.\n       bottom          -   Bottom position of the client area in PDF page\n                           coordinates.\n Return value:\n       None."]
    pub FFI_DisplayCaret: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            page: FPDF_PAGE,
            bVisible: FPDF_BOOL,
            left: f64,
            top: f64,
            right: f64,
            bottom: f64,
        ),
    >,
    #[doc = " Method: FFI_GetCurrentPageIndex\n       This method will get the current page index.\n Interface Version:\n       Ignored if |version| < 2.\n Implementation Required:\n       Required for XFA, otherwise set to NULL.\n Parameters:\n       pThis           -   Pointer to the interface structure itself.\n       document        -   Handle to document from FPDF_LoadDocument().\n Return value:\n       The index of current page."]
    pub FFI_GetCurrentPageIndex: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            document: FPDF_DOCUMENT,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: FFI_SetCurrentPage\n       This method will set the current page.\n Interface Version:\n       Ignored if |version| < 2.\n Implementation Required:\n       Required for XFA, otherwise set to NULL.\n Parameters:\n       pThis           -   Pointer to the interface structure itself.\n       document        -   Handle to document from FPDF_LoadDocument().\n       iCurPage        -   The index of the PDF page.\n Return value:\n       None."]
    pub FFI_SetCurrentPage: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            document: FPDF_DOCUMENT,
            iCurPage: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Method: FFI_GotoURL\n       This method will navigate to the specified URL.\n Interface Version:\n       Ignored if |version| < 2.\n Implementation Required:\n       Required for XFA, otherwise set to NULL.\n Parameters:\n       pThis            -   Pointer to the interface structure itself.\n       document         -   Handle to document from FPDF_LoadDocument().\n       wsURL            -   The string value of the URL, in UTF-16LE format.\n Return value:\n       None."]
    pub FFI_GotoURL: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            document: FPDF_DOCUMENT,
            wsURL: FPDF_WIDESTRING,
        ),
    >,
    #[doc = " Method: FFI_GetPageViewRect\n       This method will get the current page view rectangle.\n Interface Version:\n       Ignored if |version| < 2.\n Implementation Required:\n       Required for XFA, otherwise set to NULL.\n Parameters:\n       pThis           -   Pointer to the interface structure itself.\n       page            -   Handle to page. Returned by FPDF_LoadPage().\n       left            -   The pointer to receive left position of the page\n                           view area in PDF page coordinates.\n       top             -   The pointer to receive top position of the page\n                           view area in PDF page coordinates.\n       right           -   The pointer to receive right position of the\n                           page view area in PDF page coordinates.\n       bottom          -   The pointer to receive bottom position of the\n                           page view area in PDF page coordinates.\n Return value:\n     None."]
    pub FFI_GetPageViewRect: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            page: FPDF_PAGE,
            left: *mut f64,
            top: *mut f64,
            right: *mut f64,
            bottom: *mut f64,
        ),
    >,
    #[doc = " Method: FFI_PageEvent\n       This method fires when pages have been added to or deleted from\n       the XFA document.\n Interface Version:\n       Ignored if |version| < 2.\n Implementation Required:\n       Required for XFA, otherwise set to NULL.\n Parameters:\n       pThis           -   Pointer to the interface structure itself.\n       page_count      -   The number of pages to be added or deleted.\n       event_type      -   See FXFA_PAGEVIEWEVENT_* above.\n Return value:\n       None.\n Comments:\n       The pages to be added or deleted always start from the last page\n       of document. This means that if parameter page_count is 2 and\n       event type is FXFA_PAGEVIEWEVENT_POSTADDED, 2 new pages have been\n       appended to the tail of document; If page_count is 2 and\n       event type is FXFA_PAGEVIEWEVENT_POSTREMOVED, the last 2 pages\n       have been deleted."]
    pub FFI_PageEvent: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            page_count: ::std::os::raw::c_int,
            event_type: FPDF_DWORD,
        ),
    >,
    #[doc = " Method: FFI_PopupMenu\n       This method will track the right context menu for XFA fields.\n Interface Version:\n       Ignored if |version| < 2.\n Implementation Required:\n       Required for XFA, otherwise set to NULL.\n Parameters:\n       pThis           -   Pointer to the interface structure itself.\n       page            -   Handle to page. Returned by FPDF_LoadPage().\n       hWidget         -   Always null, exists for compatibility.\n       menuFlag        -   The menu flags. Please refer to macro definition\n                           of FXFA_MENU_XXX and this can be one or a\n                           combination of these macros.\n       x               -   X position of the client area in PDF page\n                           coordinates.\n       y               -   Y position of the client area in PDF page\n                           coordinates.\n Return value:\n       TRUE indicates success; otherwise false."]
    pub FFI_PopupMenu: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            page: FPDF_PAGE,
            hWidget: FPDF_WIDGET,
            menuFlag: ::std::os::raw::c_int,
            x: f32,
            y: f32,
        ) -> FPDF_BOOL,
    >,
    #[doc = " Method: FFI_OpenFile\n       This method will open the specified file with the specified mode.\n Interface Version:\n       Ignored if |version| < 2.\n Implementation Required:\n       Required for XFA, otherwise set to NULL.\n Parameters:\n       pThis           -   Pointer to the interface structure itself.\n       fileFlag        -   The file flag. Please refer to macro definition\n                           of FXFA_SAVEAS_XXX and use one of these macros.\n       wsURL           -   The string value of the file URL, in UTF-16LE\n                           format.\n       mode            -   The mode for open file, e.g. \"rb\" or \"wb\".\n Return value:\n       The handle to FPDF_FILEHANDLER."]
    pub FFI_OpenFile: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            fileFlag: ::std::os::raw::c_int,
            wsURL: FPDF_WIDESTRING,
            mode: *const ::std::os::raw::c_char,
        ) -> *mut FPDF_FILEHANDLER,
    >,
    #[doc = " Method: FFI_EmailTo\n       This method will email the specified file stream to the specified\n       contact.\n Interface Version:\n       Ignored if |version| < 2.\n Implementation Required:\n       Required for XFA, otherwise set to NULL.\n Parameters:\n       pThis           -   Pointer to the interface structure itself.\n       pFileHandler    -   Handle to the FPDF_FILEHANDLER.\n       pTo             -   A semicolon-delimited list of recipients for the\n                           message,in UTF-16LE format.\n       pSubject        -   The subject of the message,in UTF-16LE format.\n       pCC             -   A semicolon-delimited list of CC recipients for\n                           the message,in UTF-16LE format.\n       pBcc            -   A semicolon-delimited list of BCC recipients for\n                           the message,in UTF-16LE format.\n       pMsg            -   Pointer to the data buffer to be sent.Can be\n                           NULL,in UTF-16LE format.\n Return value:\n       None."]
    pub FFI_EmailTo: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            fileHandler: *mut FPDF_FILEHANDLER,
            pTo: FPDF_WIDESTRING,
            pSubject: FPDF_WIDESTRING,
            pCC: FPDF_WIDESTRING,
            pBcc: FPDF_WIDESTRING,
            pMsg: FPDF_WIDESTRING,
        ),
    >,
    #[doc = " Method: FFI_UploadTo\n       This method will upload the specified file stream to the\n       specified URL.\n Interface Version:\n       Ignored if |version| < 2.\n Implementation Required:\n       Required for XFA, otherwise set to NULL.\n Parameters:\n       pThis           -   Pointer to the interface structure itself.\n       pFileHandler    -   Handle to the FPDF_FILEHANDLER.\n       fileFlag        -   The file flag. Please refer to macro definition\n                           of FXFA_SAVEAS_XXX and use one of these macros.\n       uploadTo        -   Pointer to the URL path, in UTF-16LE format.\n Return value:\n       None."]
    pub FFI_UploadTo: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            fileHandler: *mut FPDF_FILEHANDLER,
            fileFlag: ::std::os::raw::c_int,
            uploadTo: FPDF_WIDESTRING,
        ),
    >,
    #[doc = " Method: FFI_GetPlatform\n       This method will get the current platform.\n Interface Version:\n       Ignored if |version| < 2.\n Implementation Required:\n       Required for XFA, otherwise set to NULL.\n Parameters:\n       pThis           -   Pointer to the interface structure itself.\n       platform        -   Pointer to the data buffer to receive the\n                           platform,in UTF-16LE format. Can be NULL.\n       length          -   The length of the buffer in bytes. Can be\n                           0 to query the required size.\n Return value:\n       The length of the buffer, number of bytes."]
    pub FFI_GetPlatform: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            platform: *mut ::std::os::raw::c_void,
            length: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: FFI_GetLanguage\n       This method will get the current language.\n Interface Version:\n       Ignored if |version| < 2.\n Implementation Required:\n       Required for XFA, otherwise set to NULL.\n Parameters:\n       pThis           -   Pointer to the interface structure itself.\n       language        -   Pointer to the data buffer to receive the\n                           current language. Can be NULL.\n       length          -   The length of the buffer in bytes. Can be\n                           0 to query the required size.\n Return value:\n       The length of the buffer, number of bytes."]
    pub FFI_GetLanguage: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            language: *mut ::std::os::raw::c_void,
            length: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: FFI_DownloadFromURL\n       This method will download the specified file from the URL.\n Interface Version:\n       Ignored if |version| < 2.\n Implementation Required:\n       Required for XFA, otherwise set to NULL.\n Parameters:\n       pThis           -   Pointer to the interface structure itself.\n       URL             -   The string value of the file URL, in UTF-16LE\n                           format.\n Return value:\n       The handle to FPDF_FILEHANDLER."]
    pub FFI_DownloadFromURL: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            URL: FPDF_WIDESTRING,
        ) -> *mut FPDF_FILEHANDLER,
    >,
    #[doc = " Method: FFI_PostRequestURL\n       This method will post the request to the server URL.\n Interface Version:\n       Ignored if |version| < 2.\n Implementation Required:\n       Required for XFA, otherwise set to NULL.\n Parameters:\n       pThis           -   Pointer to the interface structure itself.\n       wsURL           -   The string value of the server URL, in UTF-16LE\n                           format.\n       wsData          -   The post data,in UTF-16LE format.\n       wsContentType   -   The content type of the request data, in\n                           UTF-16LE format.\n       wsEncode        -   The encode type, in UTF-16LE format.\n       wsHeader        -   The request header,in UTF-16LE format.\n       response        -   Pointer to the FPDF_BSTR to receive the response\n                           data from the server, in UTF-16LE format.\n Return value:\n       TRUE indicates success, otherwise FALSE."]
    pub FFI_PostRequestURL: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            wsURL: FPDF_WIDESTRING,
            wsData: FPDF_WIDESTRING,
            wsContentType: FPDF_WIDESTRING,
            wsEncode: FPDF_WIDESTRING,
            wsHeader: FPDF_WIDESTRING,
            response: *mut FPDF_BSTR,
        ) -> FPDF_BOOL,
    >,
    #[doc = " Method: FFI_PutRequestURL\n       This method will put the request to the server URL.\n Interface Version:\n       Ignored if |version| < 2.\n Implementation Required:\n       Required for XFA, otherwise set to NULL.\n Parameters:\n       pThis           -   Pointer to the interface structure itself.\n       wsURL           -   The string value of the server URL, in UTF-16LE\n                           format.\n       wsData          -   The put data, in UTF-16LE format.\n       wsEncode        -   The encode type, in UTR-16LE format.\n Return value:\n       TRUE indicates success, otherwise FALSE."]
    pub FFI_PutRequestURL: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            wsURL: FPDF_WIDESTRING,
            wsData: FPDF_WIDESTRING,
            wsEncode: FPDF_WIDESTRING,
        ) -> FPDF_BOOL,
    >,
    #[doc = " Method: FFI_OnFocusChange\n     Called when the focused annotation is updated.\n Interface Version:\n     Ignored if |version| < 2.\n Implementation Required:\n     No\n Parameters:\n     param           -   Pointer to the interface structure itself.\n     annot           -   The focused annotation.\n     page_index      -   Index number of the page which contains the\n                         focused annotation. 0 for the first page.\n Return value:\n     None.\n Comments:\n     This callback function is useful for implementing any view based\n     action such as scrolling the annotation rect into view. The\n     embedder should not copy and store the annot as its scope is\n     limited to this call only."]
    pub FFI_OnFocusChange: ::std::option::Option<
        unsafe extern "C" fn(
            param: *mut _FPDF_FORMFILLINFO,
            annot: FPDF_ANNOTATION,
            page_index: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Method: FFI_DoURIActionWithKeyboardModifier\n       Ask the implementation to navigate to a uniform resource identifier\n       with the specified modifiers.\n Interface Version:\n       Ignored if |version| < 2.\n Implementation Required:\n       No\n Parameters:\n       param           -   Pointer to the interface structure itself.\n       uri             -   A byte string which indicates the uniform\n                           resource identifier, terminated by 0.\n       modifiers       -   Keyboard modifier that indicates which of\n                           the virtual keys are down, if any.\n Return value:\n       None.\n Comments:\n       If the embedder who is version 2 and does not implement this API,\n       then a call will be redirected to FFI_DoURIAction.\n       See the URI actions description of <<PDF Reference, version 1.7>>\n       for more details."]
    pub FFI_DoURIActionWithKeyboardModifier: ::std::option::Option<
        unsafe extern "C" fn(
            param: *mut _FPDF_FORMFILLINFO,
            uri: FPDF_BYTESTRING,
            modifiers: ::std::os::raw::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout__FPDF_FORMFILLINFO() {
    const UNINIT: ::std::mem::MaybeUninit<_FPDF_FORMFILLINFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FPDF_FORMFILLINFO>(),
        280usize,
        concat!("Size of: ", stringify!(_FPDF_FORMFILLINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_FPDF_FORMFILLINFO>(),
        8usize,
        concat!("Alignment of ", stringify!(_FPDF_FORMFILLINFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Release) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(Release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_Invalidate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_Invalidate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_OutputSelectedRect) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_OutputSelectedRect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_SetCursor) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_SetCursor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_SetTimer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_SetTimer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_KillTimer) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_KillTimer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_GetLocalTime) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GetLocalTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_OnChange) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_OnChange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_GetPage) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GetPage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_GetCurrentPage) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GetCurrentPage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_GetRotation) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GetRotation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_ExecuteNamedAction) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_ExecuteNamedAction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_SetTextFieldFocus) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_SetTextFieldFocus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_DoURIAction) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_DoURIAction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_DoGoToAction) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_DoGoToAction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pJsPlatform) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(m_pJsPlatform)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xfa_disabled) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(xfa_disabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_DisplayCaret) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_DisplayCaret)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_GetCurrentPageIndex) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GetCurrentPageIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_SetCurrentPage) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_SetCurrentPage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_GotoURL) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GotoURL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_GetPageViewRect) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GetPageViewRect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_PageEvent) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_PageEvent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_PopupMenu) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_PopupMenu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_OpenFile) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_OpenFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_EmailTo) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_EmailTo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_UploadTo) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_UploadTo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_GetPlatform) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GetPlatform)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_GetLanguage) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GetLanguage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_DownloadFromURL) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_DownloadFromURL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_PostRequestURL) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_PostRequestURL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_PutRequestURL) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_PutRequestURL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FFI_OnFocusChange) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_OnFocusChange)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).FFI_DoURIActionWithKeyboardModifier) as usize - ptr as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_DoURIActionWithKeyboardModifier)
        )
    );
}
pub type FPDF_FORMFILLINFO = _FPDF_FORMFILLINFO;
extern "C" {
    #[doc = " Function: FPDFDOC_InitFormFillEnvironment\n       Initialize form fill environment.\n Parameters:\n       document        -   Handle to document from FPDF_LoadDocument().\n       pFormFillInfo   -   Pointer to a FPDF_FORMFILLINFO structure.\n Return Value:\n       Handle to the form fill module, or NULL on failure.\n Comments:\n       This function should be called before any form fill operation."]
    pub fn FPDFDOC_InitFormFillEnvironment(
        document: FPDF_DOCUMENT,
        formInfo: *mut FPDF_FORMFILLINFO,
    ) -> FPDF_FORMHANDLE;
}
extern "C" {
    #[doc = " Function: FPDFDOC_ExitFormFillEnvironment\n       Take ownership of |hHandle| and exit form fill environment.\n Parameters:\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n Return Value:\n       None.\n Comments:\n       This function is a no-op when |hHandle| is null."]
    pub fn FPDFDOC_ExitFormFillEnvironment(hHandle: FPDF_FORMHANDLE);
}
extern "C" {
    #[doc = " Function: FORM_OnAfterLoadPage\n       This method is required for implementing all the form related\n       functions. Should be invoked after user successfully loaded a\n       PDF page, and FPDFDOC_InitFormFillEnvironment() has been invoked.\n Parameters:\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n Return Value:\n       None."]
    pub fn FORM_OnAfterLoadPage(page: FPDF_PAGE, hHandle: FPDF_FORMHANDLE);
}
extern "C" {
    #[doc = " Function: FORM_OnBeforeClosePage\n       This method is required for implementing all the form related\n       functions. Should be invoked before user closes the PDF page.\n Parameters:\n        page        -   Handle to the page, as returned by FPDF_LoadPage().\n        hHandle     -   Handle to the form fill module, as returned by\n                        FPDFDOC_InitFormFillEnvironment().\n Return Value:\n        None."]
    pub fn FORM_OnBeforeClosePage(page: FPDF_PAGE, hHandle: FPDF_FORMHANDLE);
}
extern "C" {
    #[doc = " Function: FORM_DoDocumentJSAction\n       This method is required for performing document-level JavaScript\n       actions. It should be invoked after the PDF document has been loaded.\n Parameters:\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n Return Value:\n       None.\n Comments:\n       If there is document-level JavaScript action embedded in the\n       document, this method will execute the JavaScript action. Otherwise,\n       the method will do nothing."]
    pub fn FORM_DoDocumentJSAction(hHandle: FPDF_FORMHANDLE);
}
extern "C" {
    #[doc = " Function: FORM_DoDocumentOpenAction\n       This method is required for performing open-action when the document\n       is opened.\n Parameters:\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n Return Value:\n       None.\n Comments:\n       This method will do nothing if there are no open-actions embedded\n       in the document."]
    pub fn FORM_DoDocumentOpenAction(hHandle: FPDF_FORMHANDLE);
}
extern "C" {
    #[doc = " Function: FORM_DoDocumentAAction\n       This method is required for performing the document's\n       additional-action.\n Parameters:\n       hHandle     -   Handle to the form fill module. Returned by\n                       FPDFDOC_InitFormFillEnvironment.\n       aaType      -   The type of the additional-actions which defined\n                       above.\n Return Value:\n       None.\n Comments:\n       This method will do nothing if there is no document\n       additional-action corresponding to the specified |aaType|."]
    pub fn FORM_DoDocumentAAction(hHandle: FPDF_FORMHANDLE, aaType: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Function: FORM_DoPageAAction\n       This method is required for performing the page object's\n       additional-action when opened or closed.\n Parameters:\n       page        -   Handle to the page, as returned by FPDF_LoadPage().\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n       aaType      -   The type of the page object's additional-actions\n                       which defined above.\n Return Value:\n       None.\n Comments:\n       This method will do nothing if no additional-action corresponding\n       to the specified |aaType| exists."]
    pub fn FORM_DoPageAAction(
        page: FPDF_PAGE,
        hHandle: FPDF_FORMHANDLE,
        aaType: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Function: FORM_OnMouseMove\n       Call this member function when the mouse cursor moves.\n Parameters:\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n       page        -   Handle to the page, as returned by FPDF_LoadPage().\n       modifier    -   Indicates whether various virtual keys are down.\n       page_x      -   Specifies the x-coordinate of the cursor in PDF user\n                       space.\n       page_y      -   Specifies the y-coordinate of the cursor in PDF user\n                       space.\n Return Value:\n       True indicates success; otherwise false."]
    pub fn FORM_OnMouseMove(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        modifier: ::std::os::raw::c_int,
        page_x: f64,
        page_y: f64,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API\n Function: FORM_OnMouseWheel\n       Call this member function when the user scrolls the mouse wheel.\n Parameters:\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n       page        -   Handle to the page, as returned by FPDF_LoadPage().\n       modifier    -   Indicates whether various virtual keys are down.\n       page_coord  -   Specifies the coordinates of the cursor in PDF user\n                       space.\n       delta_x     -   Specifies the amount of wheel movement on the x-axis,\n                       in units of platform-agnostic wheel deltas. Negative\n                       values mean left.\n       delta_y     -   Specifies the amount of wheel movement on the y-axis,\n                       in units of platform-agnostic wheel deltas. Negative\n                       values mean down.\n Return Value:\n       True indicates success; otherwise false.\n Comments:\n       For |delta_x| and |delta_y|, the caller must normalize\n       platform-specific wheel deltas. e.g. On Windows, a delta value of 240\n       for a WM_MOUSEWHEEL event normalizes to 2, since Windows defines\n       WHEEL_DELTA as 120."]
    pub fn FORM_OnMouseWheel(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        modifier: ::std::os::raw::c_int,
        page_coord: *const FS_POINTF,
        delta_x: ::std::os::raw::c_int,
        delta_y: ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_OnFocus\n       This function focuses the form annotation at a given point. If the\n       annotation at the point already has focus, nothing happens. If there\n       is no annotation at the point, removes form focus.\n Parameters:\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n       page        -   Handle to the page, as returned by FPDF_LoadPage().\n       modifier    -   Indicates whether various virtual keys are down.\n       page_x      -   Specifies the x-coordinate of the cursor in PDF user\n                       space.\n       page_y      -   Specifies the y-coordinate of the cursor in PDF user\n                       space.\n Return Value:\n       True if there is an annotation at the given point and it has focus."]
    pub fn FORM_OnFocus(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        modifier: ::std::os::raw::c_int,
        page_x: f64,
        page_y: f64,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_OnLButtonDown\n       Call this member function when the user presses the left\n       mouse button.\n Parameters:\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n       page        -   Handle to the page, as returned by FPDF_LoadPage().\n       modifier    -   Indicates whether various virtual keys are down.\n       page_x      -   Specifies the x-coordinate of the cursor in PDF user\n                       space.\n       page_y      -   Specifies the y-coordinate of the cursor in PDF user\n                       space.\n Return Value:\n       True indicates success; otherwise false."]
    pub fn FORM_OnLButtonDown(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        modifier: ::std::os::raw::c_int,
        page_x: f64,
        page_y: f64,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_OnRButtonDown\n       Same as above, execpt for the right mouse button.\n Comments:\n       At the present time, has no effect except in XFA builds, but is\n       included for the sake of symmetry."]
    pub fn FORM_OnRButtonDown(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        modifier: ::std::os::raw::c_int,
        page_x: f64,
        page_y: f64,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_OnLButtonUp\n       Call this member function when the user releases the left\n       mouse button.\n Parameters:\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n       page        -   Handle to the page, as returned by FPDF_LoadPage().\n       modifier    -   Indicates whether various virtual keys are down.\n       page_x      -   Specifies the x-coordinate of the cursor in device.\n       page_y      -   Specifies the y-coordinate of the cursor in device.\n Return Value:\n       True indicates success; otherwise false."]
    pub fn FORM_OnLButtonUp(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        modifier: ::std::os::raw::c_int,
        page_x: f64,
        page_y: f64,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_OnRButtonUp\n       Same as above, execpt for the right mouse button.\n Comments:\n       At the present time, has no effect except in XFA builds, but is\n       included for the sake of symmetry."]
    pub fn FORM_OnRButtonUp(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        modifier: ::std::os::raw::c_int,
        page_x: f64,
        page_y: f64,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_OnLButtonDoubleClick\n       Call this member function when the user double clicks the\n       left mouse button.\n Parameters:\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n       page        -   Handle to the page, as returned by FPDF_LoadPage().\n       modifier    -   Indicates whether various virtual keys are down.\n       page_x      -   Specifies the x-coordinate of the cursor in PDF user\n                       space.\n       page_y      -   Specifies the y-coordinate of the cursor in PDF user\n                       space.\n Return Value:\n       True indicates success; otherwise false."]
    pub fn FORM_OnLButtonDoubleClick(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        modifier: ::std::os::raw::c_int,
        page_x: f64,
        page_y: f64,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_OnKeyDown\n       Call this member function when a nonsystem key is pressed.\n Parameters:\n       hHandle     -   Handle to the form fill module, aseturned by\n                       FPDFDOC_InitFormFillEnvironment().\n       page        -   Handle to the page, as returned by FPDF_LoadPage().\n       nKeyCode    -   The virtual-key code of the given key (see\n                       fpdf_fwlevent.h for virtual key codes).\n       modifier    -   Mask of key flags (see fpdf_fwlevent.h for key\n                       flag values).\n Return Value:\n       True indicates success; otherwise false."]
    pub fn FORM_OnKeyDown(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        nKeyCode: ::std::os::raw::c_int,
        modifier: ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_OnKeyUp\n       Call this member function when a nonsystem key is released.\n Parameters:\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n       page        -   Handle to the page, as returned by FPDF_LoadPage().\n       nKeyCode    -   The virtual-key code of the given key (see\n                       fpdf_fwlevent.h for virtual key codes).\n       modifier    -   Mask of key flags (see fpdf_fwlevent.h for key\n                       flag values).\n Return Value:\n       True indicates success; otherwise false."]
    pub fn FORM_OnKeyUp(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        nKeyCode: ::std::os::raw::c_int,
        modifier: ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_OnChar\n       Call this member function when a keystroke translates to a\n       nonsystem character.\n Parameters:\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n       page        -   Handle to the page, as returned by FPDF_LoadPage().\n       nChar       -   The character code value itself.\n       modifier    -   Mask of key flags (see fpdf_fwlevent.h for key\n                       flag values).\n Return Value:\n       True indicates success; otherwise false."]
    pub fn FORM_OnChar(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        nChar: ::std::os::raw::c_int,
        modifier: ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API\n Function: FORM_GetFocusedText\n       Call this function to obtain the text within the current focused\n       field, if any.\n Parameters:\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n       page        -   Handle to the page, as returned by FPDF_LoadPage().\n       buffer      -   Buffer for holding the form text, encoded in\n                       UTF-16LE. If NULL, |buffer| is not modified.\n       buflen      -   Length of |buffer| in bytes. If |buflen| is less\n                       than the length of the form text string, |buffer| is\n                       not modified.\n Return Value:\n       Length in bytes for the text in the focused field."]
    pub fn FORM_GetFocusedText(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Function: FORM_GetSelectedText\n       Call this function to obtain selected text within a form text\n       field or form combobox text field.\n Parameters:\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n       page        -   Handle to the page, as returned by FPDF_LoadPage().\n       buffer      -   Buffer for holding the selected text, encoded in\n                       UTF-16LE. If NULL, |buffer| is not modified.\n       buflen      -   Length of |buffer| in bytes. If |buflen| is less\n                       than the length of the selected text string,\n                       |buffer| is not modified.\n Return Value:\n       Length in bytes of selected text in form text field or form combobox\n       text field."]
    pub fn FORM_GetSelectedText(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Function: FORM_ReplaceSelection\n       Call this function to replace the selected text in a form\n       text field or user-editable form combobox text field with another\n       text string (which can be empty or non-empty). If there is no\n       selected text, this function will append the replacement text after\n       the current caret position.\n Parameters:\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n       page        -   Handle to the page, as Returned by FPDF_LoadPage().\n       wsText      -   The text to be inserted, in UTF-16LE format.\n Return Value:\n       None."]
    pub fn FORM_ReplaceSelection(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        wsText: FPDF_WIDESTRING,
    );
}
extern "C" {
    #[doc = " Experimental API\n Function: FORM_SelectAllText\n       Call this function to select all the text within the currently focused\n       form text field or form combobox text field.\n Parameters:\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n       page        -   Handle to the page, as returned by FPDF_LoadPage().\n Return Value:\n       Whether the operation succeeded or not."]
    pub fn FORM_SelectAllText(hHandle: FPDF_FORMHANDLE, page: FPDF_PAGE) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_CanUndo\n       Find out if it is possible for the current focused widget in a given\n       form to perform an undo operation.\n Parameters:\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n       page        -   Handle to the page, as returned by FPDF_LoadPage().\n Return Value:\n       True if it is possible to undo."]
    pub fn FORM_CanUndo(hHandle: FPDF_FORMHANDLE, page: FPDF_PAGE) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_CanRedo\n       Find out if it is possible for the current focused widget in a given\n       form to perform a redo operation.\n Parameters:\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n       page        -   Handle to the page, as returned by FPDF_LoadPage().\n Return Value:\n       True if it is possible to redo."]
    pub fn FORM_CanRedo(hHandle: FPDF_FORMHANDLE, page: FPDF_PAGE) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_Undo\n       Make the current focussed widget perform an undo operation.\n Parameters:\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n       page        -   Handle to the page, as returned by FPDF_LoadPage().\n Return Value:\n       True if the undo operation succeeded."]
    pub fn FORM_Undo(hHandle: FPDF_FORMHANDLE, page: FPDF_PAGE) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_Redo\n       Make the current focussed widget perform a redo operation.\n Parameters:\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n       page        -   Handle to the page, as returned by FPDF_LoadPage().\n Return Value:\n       True if the redo operation succeeded."]
    pub fn FORM_Redo(hHandle: FPDF_FORMHANDLE, page: FPDF_PAGE) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_ForceToKillFocus.\n       Call this member function to force to kill the focus of the form\n       field which has focus. If it would kill the focus of a form field,\n       save the value of form field if was changed by theuser.\n Parameters:\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n Return Value:\n       True indicates success; otherwise false."]
    pub fn FORM_ForceToKillFocus(hHandle: FPDF_FORMHANDLE) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FORM_GetFocusedAnnot.\n       Call this member function to get the currently focused annotation.\n Parameters:\n       handle      -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n       page_index  -   Buffer to hold the index number of the page which\n                       contains the focused annotation. 0 for the first page.\n                       Can't be NULL.\n       annot       -   Buffer to hold the focused annotation. Can't be NULL.\n Return Value:\n       On success, return true and write to the out parameters. Otherwise return\n       false and leave the out parameters unmodified.\n Comments:\n       Not currently supported for XFA forms - will report no focused\n       annotation.\n       Must call FPDFPage_CloseAnnot() when the annotation returned in |annot|\n       by this function is no longer needed.\n       This will return true and set |page_index| to -1 and |annot| to NULL, if\n       there is no focused annotation."]
    pub fn FORM_GetFocusedAnnot(
        handle: FPDF_FORMHANDLE,
        page_index: *mut ::std::os::raw::c_int,
        annot: *mut FPDF_ANNOTATION,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FORM_SetFocusedAnnot.\n       Call this member function to set the currently focused annotation.\n Parameters:\n       handle      -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n       annot       -   Handle to an annotation.\n Return Value:\n       True indicates success; otherwise false.\n Comments:\n       |annot| can't be NULL. To kill focus, use FORM_ForceToKillFocus()\n       instead."]
    pub fn FORM_SetFocusedAnnot(handle: FPDF_FORMHANDLE, annot: FPDF_ANNOTATION) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDFPage_HasFormFieldAtPoint\n     Get the form field type by point.\n Parameters:\n     hHandle     -   Handle to the form fill module. Returned by\n                     FPDFDOC_InitFormFillEnvironment().\n     page        -   Handle to the page. Returned by FPDF_LoadPage().\n     page_x      -   X position in PDF \"user space\".\n     page_y      -   Y position in PDF \"user space\".\n Return Value:\n     Return the type of the form field; -1 indicates no field.\n     See field types above."]
    pub fn FPDFPage_HasFormFieldAtPoint(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        page_x: f64,
        page_y: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDFPage_FormFieldZOrderAtPoint\n     Get the form field z-order by point.\n Parameters:\n     hHandle     -   Handle to the form fill module. Returned by\n                     FPDFDOC_InitFormFillEnvironment().\n     page        -   Handle to the page. Returned by FPDF_LoadPage().\n     page_x      -   X position in PDF \"user space\".\n     page_y      -   Y position in PDF \"user space\".\n Return Value:\n     Return the z-order of the form field; -1 indicates no field.\n     Higher numbers are closer to the front."]
    pub fn FPDFPage_FormFieldZOrderAtPoint(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        page_x: f64,
        page_y: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDF_SetFormFieldHighlightColor\n       Set the highlight color of the specified (or all) form fields\n       in the document.\n Parameters:\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n       doc         -   Handle to the document, as returned by\n                       FPDF_LoadDocument().\n       fieldType   -   A 32-bit integer indicating the type of a form\n                       field (defined above).\n       color       -   The highlight color of the form field. Constructed by\n                       0xxxrrggbb.\n Return Value:\n       None.\n Comments:\n       When the parameter fieldType is set to FPDF_FORMFIELD_UNKNOWN, the\n       highlight color will be applied to all the form fields in the\n       document.\n       Please refresh the client window to show the highlight immediately\n       if necessary."]
    pub fn FPDF_SetFormFieldHighlightColor(
        hHandle: FPDF_FORMHANDLE,
        fieldType: ::std::os::raw::c_int,
        color: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    #[doc = " Function: FPDF_SetFormFieldHighlightAlpha\n       Set the transparency of the form field highlight color in the\n       document.\n Parameters:\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n       doc         -   Handle to the document, as returaned by\n                       FPDF_LoadDocument().\n       alpha       -   The transparency of the form field highlight color,\n                       between 0-255.\n Return Value:\n       None."]
    pub fn FPDF_SetFormFieldHighlightAlpha(
        hHandle: FPDF_FORMHANDLE,
        alpha: ::std::os::raw::c_uchar,
    );
}
extern "C" {
    #[doc = " Function: FPDF_RemoveFormFieldHighlight\n       Remove the form field highlight color in the document.\n Parameters:\n       hHandle     -   Handle to the form fill module, as returned by\n                       FPDFDOC_InitFormFillEnvironment().\n Return Value:\n       None.\n Comments:\n       Please refresh the client window to remove the highlight immediately\n       if necessary."]
    pub fn FPDF_RemoveFormFieldHighlight(hHandle: FPDF_FORMHANDLE);
}
extern "C" {
    #[doc = " Function: FPDF_FFLDraw\n       Render FormFields and popup window on a page to a device independent\n       bitmap.\n Parameters:\n       hHandle      -   Handle to the form fill module, as returned by\n                        FPDFDOC_InitFormFillEnvironment().\n       bitmap       -   Handle to the device independent bitmap (as the\n                        output buffer). Bitmap handles can be created by\n                        FPDFBitmap_Create().\n       page         -   Handle to the page, as returned by FPDF_LoadPage().\n       start_x      -   Left pixel position of the display area in the\n                        device coordinates.\n       start_y      -   Top pixel position of the display area in the device\n                        coordinates.\n       size_x       -   Horizontal size (in pixels) for displaying the page.\n       size_y       -   Vertical size (in pixels) for displaying the page.\n       rotate       -   Page orientation: 0 (normal), 1 (rotated 90 degrees\n                        clockwise), 2 (rotated 180 degrees), 3 (rotated 90\n                        degrees counter-clockwise).\n       flags        -   0 for normal display, or combination of flags\n                        defined above.\n Return Value:\n       None.\n Comments:\n       This function is designed to render annotations that are\n       user-interactive, which are widget annotations (for FormFields) and\n       popup annotations.\n       With the FPDF_ANNOT flag, this function will render a popup annotation\n       when users mouse-hover on a non-widget annotation. Regardless of\n       FPDF_ANNOT flag, this function will always render widget annotations\n       for FormFields.\n       In order to implement the FormFill functions, implementation should\n       call this function after rendering functions, such as\n       FPDF_RenderPageBitmap() or FPDF_RenderPageBitmap_Start(), have\n       finished rendering the page contents."]
    pub fn FPDF_FFLDraw(
        hHandle: FPDF_FORMHANDLE,
        bitmap: FPDF_BITMAP,
        page: FPDF_PAGE,
        start_x: ::std::os::raw::c_int,
        start_y: ::std::os::raw::c_int,
        size_x: ::std::os::raw::c_int,
        size_y: ::std::os::raw::c_int,
        rotate: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Experimental API\n Function: FPDF_GetFormType\n           Returns the type of form contained in the PDF document.\n Parameters:\n           document - Handle to document.\n Return Value:\n           Integer value representing one of the FORMTYPE_ values.\n Comments:\n           If |document| is NULL, then the return value is FORMTYPE_NONE."]
    pub fn FPDF_GetFormType(document: FPDF_DOCUMENT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API\n Function: FORM_SetIndexSelected\n           Selects/deselects the value at the given |index| of the focused\n           annotation.\n Parameters:\n           hHandle     -   Handle to the form fill module. Returned by\n                           FPDFDOC_InitFormFillEnvironment.\n           page        -   Handle to the page. Returned by FPDF_LoadPage\n           index       -   0-based index of value to be set as\n                           selected/unselected\n           selected    -   true to select, false to deselect\n Return Value:\n           TRUE if the operation succeeded.\n           FALSE if the operation failed or widget is not a supported type.\n Comments:\n           Intended for use with listbox/combobox widget types. Comboboxes\n           have at most a single value selected at a time which cannot be\n           deselected. Deselect on a combobox is a no-op that returns false.\n           Default implementation is a no-op that will return false for\n           other types.\n           Not currently supported for XFA forms - will return false."]
    pub fn FORM_SetIndexSelected(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        index: ::std::os::raw::c_int,
        selected: FPDF_BOOL,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API\n Function: FORM_IsIndexSelected\n           Returns whether or not the value at |index| of the focused\n           annotation is currently selected.\n Parameters:\n           hHandle     -   Handle to the form fill module. Returned by\n                           FPDFDOC_InitFormFillEnvironment.\n           page        -   Handle to the page. Returned by FPDF_LoadPage\n           index       -   0-based Index of value to check\n Return Value:\n           TRUE if value at |index| is currently selected.\n           FALSE if value at |index| is not selected or widget is not a\n           supported type.\n Comments:\n           Intended for use with listbox/combobox widget types. Default\n           implementation is a no-op that will return false for other types.\n           Not currently supported for XFA forms - will return false."]
    pub fn FORM_IsIndexSelected(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        index: ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDF_LoadXFA\n          If the document consists of XFA fields, call this method to\n          attempt to load XFA fields.\n Parameters:\n          document     -   Handle to document from FPDF_LoadDocument().\n Return Value:\n          TRUE upon success, otherwise FALSE. If XFA support is not built\n          into PDFium, performs no action and always returns FALSE."]
    pub fn FPDF_LoadXFA(document: FPDF_DOCUMENT) -> FPDF_BOOL;
}
pub const FPDFANNOT_COLORTYPE_FPDFANNOT_COLORTYPE_Color: FPDFANNOT_COLORTYPE = 0;
pub const FPDFANNOT_COLORTYPE_FPDFANNOT_COLORTYPE_InteriorColor: FPDFANNOT_COLORTYPE = 1;
pub type FPDFANNOT_COLORTYPE = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Experimental API.\n Check if an annotation subtype is currently supported for creation.\n Currently supported subtypes:\n    - circle\n    - freetext\n    - highlight\n    - ink\n    - link\n    - popup\n    - square,\n    - squiggly\n    - stamp\n    - strikeout\n    - text\n    - underline\n\n   subtype   - the subtype to be checked.\n\n Returns true if this subtype supported."]
    pub fn FPDFAnnot_IsSupportedSubtype(subtype: FPDF_ANNOTATION_SUBTYPE) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Create an annotation in |page| of the subtype |subtype|. If the specified\n subtype is illegal or unsupported, then a new annotation will not be created.\n Must call FPDFPage_CloseAnnot() when the annotation returned by this\n function is no longer needed.\n\n   page      - handle to a page.\n   subtype   - the subtype of the new annotation.\n\n Returns a handle to the new annotation object, or NULL on failure."]
    pub fn FPDFPage_CreateAnnot(
        page: FPDF_PAGE,
        subtype: FPDF_ANNOTATION_SUBTYPE,
    ) -> FPDF_ANNOTATION;
}
extern "C" {
    #[doc = " Experimental API.\n Get the number of annotations in |page|.\n\n   page   - handle to a page.\n\n Returns the number of annotations in |page|."]
    pub fn FPDFPage_GetAnnotCount(page: FPDF_PAGE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Get annotation in |page| at |index|. Must call FPDFPage_CloseAnnot() when the\n annotation returned by this function is no longer needed.\n\n   page  - handle to a page.\n   index - the index of the annotation.\n\n Returns a handle to the annotation object, or NULL on failure."]
    pub fn FPDFPage_GetAnnot(page: FPDF_PAGE, index: ::std::os::raw::c_int) -> FPDF_ANNOTATION;
}
extern "C" {
    #[doc = " Experimental API.\n Get the index of |annot| in |page|. This is the opposite of\n FPDFPage_GetAnnot().\n\n   page  - handle to the page that the annotation is on.\n   annot - handle to an annotation.\n\n Returns the index of |annot|, or -1 on failure."]
    pub fn FPDFPage_GetAnnotIndex(page: FPDF_PAGE, annot: FPDF_ANNOTATION)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Close an annotation. Must be called when the annotation returned by\n FPDFPage_CreateAnnot() or FPDFPage_GetAnnot() is no longer needed. This\n function does not remove the annotation from the document.\n\n   annot  - handle to an annotation."]
    pub fn FPDFPage_CloseAnnot(annot: FPDF_ANNOTATION);
}
extern "C" {
    #[doc = " Experimental API.\n Remove the annotation in |page| at |index|.\n\n   page  - handle to a page.\n   index - the index of the annotation.\n\n Returns true if successful."]
    pub fn FPDFPage_RemoveAnnot(page: FPDF_PAGE, index: ::std::os::raw::c_int) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the subtype of an annotation.\n\n   annot  - handle to an annotation.\n\n Returns the annotation subtype."]
    pub fn FPDFAnnot_GetSubtype(annot: FPDF_ANNOTATION) -> FPDF_ANNOTATION_SUBTYPE;
}
extern "C" {
    #[doc = " Experimental API.\n Check if an annotation subtype is currently supported for object extraction,\n update, and removal.\n Currently supported subtypes: ink and stamp.\n\n   subtype   - the subtype to be checked.\n\n Returns true if this subtype supported."]
    pub fn FPDFAnnot_IsObjectSupportedSubtype(subtype: FPDF_ANNOTATION_SUBTYPE) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Update |obj| in |annot|. |obj| must be in |annot| already and must have\n been retrieved by FPDFAnnot_GetObject(). Currently, only ink and stamp\n annotations are supported by this API. Also note that only path, image, and\n text objects have APIs for modification; see FPDFPath_*(), FPDFText_*(), and\n FPDFImageObj_*().\n\n   annot  - handle to an annotation.\n   obj    - handle to the object that |annot| needs to update.\n\n Return true if successful."]
    pub fn FPDFAnnot_UpdateObject(annot: FPDF_ANNOTATION, obj: FPDF_PAGEOBJECT) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Add a new InkStroke, represented by an array of points, to the InkList of\n |annot|. The API creates an InkList if one doesn't already exist in |annot|.\n This API works only for ink annotations. Please refer to ISO 32000-1:2008\n spec, section 12.5.6.13.\n\n   annot       - handle to an annotation.\n   points      - pointer to a FS_POINTF array representing input points.\n   point_count - number of elements in |points| array. This should not exceed\n                 the maximum value that can be represented by an int32_t).\n\n Returns the 0-based index at which the new InkStroke is added in the InkList\n of the |annot|. Returns -1 on failure."]
    pub fn FPDFAnnot_AddInkStroke(
        annot: FPDF_ANNOTATION,
        points: *const FS_POINTF,
        point_count: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Removes an InkList in |annot|.\n This API works only for ink annotations.\n\n   annot  - handle to an annotation.\n\n Return true on successful removal of /InkList entry from context of the\n non-null ink |annot|. Returns false on failure."]
    pub fn FPDFAnnot_RemoveInkList(annot: FPDF_ANNOTATION) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Add |obj| to |annot|. |obj| must have been created by\n FPDFPageObj_CreateNew{Path|Rect}() or FPDFPageObj_New{Text|Image}Obj(), and\n will be owned by |annot|. Note that an |obj| cannot belong to more than one\n |annot|. Currently, only ink and stamp annotations are supported by this API.\n Also note that only path, image, and text objects have APIs for creation.\n\n   annot  - handle to an annotation.\n   obj    - handle to the object that is to be added to |annot|.\n\n Return true if successful."]
    pub fn FPDFAnnot_AppendObject(annot: FPDF_ANNOTATION, obj: FPDF_PAGEOBJECT) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the total number of objects in |annot|, including path objects, text\n objects, external objects, image objects, and shading objects.\n\n   annot  - handle to an annotation.\n\n Returns the number of objects in |annot|."]
    pub fn FPDFAnnot_GetObjectCount(annot: FPDF_ANNOTATION) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Get the object in |annot| at |index|.\n\n   annot  - handle to an annotation.\n   index  - the index of the object.\n\n Return a handle to the object, or NULL on failure."]
    pub fn FPDFAnnot_GetObject(
        annot: FPDF_ANNOTATION,
        index: ::std::os::raw::c_int,
    ) -> FPDF_PAGEOBJECT;
}
extern "C" {
    #[doc = " Experimental API.\n Remove the object in |annot| at |index|.\n\n   annot  - handle to an annotation.\n   index  - the index of the object to be removed.\n\n Return true if successful."]
    pub fn FPDFAnnot_RemoveObject(
        annot: FPDF_ANNOTATION,
        index: ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Set the color of an annotation. Fails when called on annotations with\n appearance streams already defined; instead use\n FPDFPath_Set{Stroke|Fill}Color().\n\n   annot    - handle to an annotation.\n   type     - type of the color to be set.\n   R, G, B  - buffer to hold the RGB value of the color. Ranges from 0 to 255.\n   A        - buffer to hold the opacity. Ranges from 0 to 255.\n\n Returns true if successful."]
    pub fn FPDFAnnot_SetColor(
        annot: FPDF_ANNOTATION,
        type_: FPDFANNOT_COLORTYPE,
        R: ::std::os::raw::c_uint,
        G: ::std::os::raw::c_uint,
        B: ::std::os::raw::c_uint,
        A: ::std::os::raw::c_uint,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the color of an annotation. If no color is specified, default to yellow\n for highlight annotation, black for all else. Fails when called on\n annotations with appearance streams already defined; instead use\n FPDFPath_Get{Stroke|Fill}Color().\n\n   annot    - handle to an annotation.\n   type     - type of the color requested.\n   R, G, B  - buffer to hold the RGB value of the color. Ranges from 0 to 255.\n   A        - buffer to hold the opacity. Ranges from 0 to 255.\n\n Returns true if successful."]
    pub fn FPDFAnnot_GetColor(
        annot: FPDF_ANNOTATION,
        type_: FPDFANNOT_COLORTYPE,
        R: *mut ::std::os::raw::c_uint,
        G: *mut ::std::os::raw::c_uint,
        B: *mut ::std::os::raw::c_uint,
        A: *mut ::std::os::raw::c_uint,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Check if the annotation is of a type that has attachment points\n (i.e. quadpoints). Quadpoints are the vertices of the rectangle that\n encompasses the texts affected by the annotation. They provide the\n coordinates in the page where the annotation is attached. Only text markup\n annotations (i.e. highlight, strikeout, squiggly, and underline) and link\n annotations have quadpoints.\n\n   annot  - handle to an annotation.\n\n Returns true if the annotation is of a type that has quadpoints, false\n otherwise."]
    pub fn FPDFAnnot_HasAttachmentPoints(annot: FPDF_ANNOTATION) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Replace the attachment points (i.e. quadpoints) set of an annotation at\n |quad_index|. This index needs to be within the result of\n FPDFAnnot_CountAttachmentPoints().\n If the annotation's appearance stream is defined and this annotation is of a\n type with quadpoints, then update the bounding box too if the new quadpoints\n define a bigger one.\n\n   annot       - handle to an annotation.\n   quad_index  - index of the set of quadpoints.\n   quad_points - the quadpoints to be set.\n\n Returns true if successful."]
    pub fn FPDFAnnot_SetAttachmentPoints(
        annot: FPDF_ANNOTATION,
        quad_index: usize,
        quad_points: *const FS_QUADPOINTSF,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Append to the list of attachment points (i.e. quadpoints) of an annotation.\n If the annotation's appearance stream is defined and this annotation is of a\n type with quadpoints, then update the bounding box too if the new quadpoints\n define a bigger one.\n\n   annot       - handle to an annotation.\n   quad_points - the quadpoints to be set.\n\n Returns true if successful."]
    pub fn FPDFAnnot_AppendAttachmentPoints(
        annot: FPDF_ANNOTATION,
        quad_points: *const FS_QUADPOINTSF,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the number of sets of quadpoints of an annotation.\n\n   annot  - handle to an annotation.\n\n Returns the number of sets of quadpoints, or 0 on failure."]
    pub fn FPDFAnnot_CountAttachmentPoints(annot: FPDF_ANNOTATION) -> usize;
}
extern "C" {
    #[doc = " Experimental API.\n Get the attachment points (i.e. quadpoints) of an annotation.\n\n   annot       - handle to an annotation.\n   quad_index  - index of the set of quadpoints.\n   quad_points - receives the quadpoints; must not be NULL.\n\n Returns true if successful."]
    pub fn FPDFAnnot_GetAttachmentPoints(
        annot: FPDF_ANNOTATION,
        quad_index: usize,
        quad_points: *mut FS_QUADPOINTSF,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Set the annotation rectangle defining the location of the annotation. If the\n annotation's appearance stream is defined and this annotation is of a type\n without quadpoints, then update the bounding box too if the new rectangle\n defines a bigger one.\n\n   annot  - handle to an annotation.\n   rect   - the annotation rectangle to be set.\n\n Returns true if successful."]
    pub fn FPDFAnnot_SetRect(annot: FPDF_ANNOTATION, rect: *const FS_RECTF) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the annotation rectangle defining the location of the annotation.\n\n   annot  - handle to an annotation.\n   rect   - receives the rectangle; must not be NULL.\n\n Returns true if successful."]
    pub fn FPDFAnnot_GetRect(annot: FPDF_ANNOTATION, rect: *mut FS_RECTF) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the vertices of a polygon or polyline annotation. |buffer| is an array of\n points of the annotation. If |length| is less than the returned length, or\n |annot| or |buffer| is NULL, |buffer| will not be modified.\n\n   annot  - handle to an annotation, as returned by e.g. FPDFPage_GetAnnot()\n   buffer - buffer for holding the points.\n   length - length of the buffer in points.\n\n Returns the number of points if the annotation is of type polygon or\n polyline, 0 otherwise."]
    pub fn FPDFAnnot_GetVertices(
        annot: FPDF_ANNOTATION,
        buffer: *mut FS_POINTF,
        length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Get the number of paths in the ink list of an ink annotation.\n\n   annot  - handle to an annotation, as returned by e.g. FPDFPage_GetAnnot()\n\n Returns the number of paths in the ink list if the annotation is of type ink,\n 0 otherwise."]
    pub fn FPDFAnnot_GetInkListCount(annot: FPDF_ANNOTATION) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Get a path in the ink list of an ink annotation. |buffer| is an array of\n points of the path. If |length| is less than the returned length, or |annot|\n or |buffer| is NULL, |buffer| will not be modified.\n\n   annot  - handle to an annotation, as returned by e.g. FPDFPage_GetAnnot()\n   path_index - index of the path\n   buffer - buffer for holding the points.\n   length - length of the buffer in points.\n\n Returns the number of points of the path if the annotation is of type ink, 0\n otherwise."]
    pub fn FPDFAnnot_GetInkListPath(
        annot: FPDF_ANNOTATION,
        path_index: ::std::os::raw::c_ulong,
        buffer: *mut FS_POINTF,
        length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Get the starting and ending coordinates of a line annotation.\n\n   annot  - handle to an annotation, as returned by e.g. FPDFPage_GetAnnot()\n   start - starting point\n   end - ending point\n\n Returns true if the annotation is of type line, |start| and |end| are not\n NULL, false otherwise."]
    pub fn FPDFAnnot_GetLine(
        annot: FPDF_ANNOTATION,
        start: *mut FS_POINTF,
        end: *mut FS_POINTF,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Set the characteristics of the annotation's border (rounded rectangle).\n\n   annot              - handle to an annotation\n   horizontal_radius  - horizontal corner radius, in default user space units\n   vertical_radius    - vertical corner radius, in default user space units\n   border_width       - border width, in default user space units\n\n Returns true if setting the border for |annot| succeeds, false otherwise.\n\n If |annot| contains an appearance stream that overrides the border values,\n then the appearance stream will be removed on success."]
    pub fn FPDFAnnot_SetBorder(
        annot: FPDF_ANNOTATION,
        horizontal_radius: f32,
        vertical_radius: f32,
        border_width: f32,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the characteristics of the annotation's border (rounded rectangle).\n\n   annot              - handle to an annotation\n   horizontal_radius  - horizontal corner radius, in default user space units\n   vertical_radius    - vertical corner radius, in default user space units\n   border_width       - border width, in default user space units\n\n Returns true if |horizontal_radius|, |vertical_radius| and |border_width| are\n not NULL, false otherwise."]
    pub fn FPDFAnnot_GetBorder(
        annot: FPDF_ANNOTATION,
        horizontal_radius: *mut f32,
        vertical_radius: *mut f32,
        border_width: *mut f32,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Check if |annot|'s dictionary has |key| as a key.\n\n   annot  - handle to an annotation.\n   key    - the key to look for, encoded in UTF-8.\n\n Returns true if |key| exists."]
    pub fn FPDFAnnot_HasKey(annot: FPDF_ANNOTATION, key: FPDF_BYTESTRING) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the type of the value corresponding to |key| in |annot|'s dictionary.\n\n   annot  - handle to an annotation.\n   key    - the key to look for, encoded in UTF-8.\n\n Returns the type of the dictionary value."]
    pub fn FPDFAnnot_GetValueType(annot: FPDF_ANNOTATION, key: FPDF_BYTESTRING)
        -> FPDF_OBJECT_TYPE;
}
extern "C" {
    #[doc = " Experimental API.\n Set the string value corresponding to |key| in |annot|'s dictionary,\n overwriting the existing value if any. The value type would be\n FPDF_OBJECT_STRING after this function call succeeds.\n\n   annot  - handle to an annotation.\n   key    - the key to the dictionary entry to be set, encoded in UTF-8.\n   value  - the string value to be set, encoded in UTF-16LE.\n\n Returns true if successful."]
    pub fn FPDFAnnot_SetStringValue(
        annot: FPDF_ANNOTATION,
        key: FPDF_BYTESTRING,
        value: FPDF_WIDESTRING,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the string value corresponding to |key| in |annot|'s dictionary. |buffer|\n is only modified if |buflen| is longer than the length of contents. Note that\n if |key| does not exist in the dictionary or if |key|'s corresponding value\n in the dictionary is not a string (i.e. the value is not of type\n FPDF_OBJECT_STRING or FPDF_OBJECT_NAME), then an empty string would be copied\n to |buffer| and the return value would be 2. On other errors, nothing would\n be added to |buffer| and the return value would be 0.\n\n   annot  - handle to an annotation.\n   key    - the key to the requested dictionary entry, encoded in UTF-8.\n   buffer - buffer for holding the value string, encoded in UTF-16LE.\n   buflen - length of the buffer in bytes.\n\n Returns the length of the string value in bytes."]
    pub fn FPDFAnnot_GetStringValue(
        annot: FPDF_ANNOTATION,
        key: FPDF_BYTESTRING,
        buffer: *mut FPDF_WCHAR,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Get the float value corresponding to |key| in |annot|'s dictionary. Writes\n value to |value| and returns True if |key| exists in the dictionary and\n |key|'s corresponding value is a number (FPDF_OBJECT_NUMBER), False\n otherwise.\n\n   annot  - handle to an annotation.\n   key    - the key to the requested dictionary entry, encoded in UTF-8.\n   value  - receives the value, must not be NULL.\n\n Returns True if value found, False otherwise."]
    pub fn FPDFAnnot_GetNumberValue(
        annot: FPDF_ANNOTATION,
        key: FPDF_BYTESTRING,
        value: *mut f32,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Set the AP (appearance string) in |annot|'s dictionary for a given\n |appearanceMode|.\n\n   annot          - handle to an annotation.\n   appearanceMode - the appearance mode (normal, rollover or down) for which\n                    to get the AP.\n   value          - the string value to be set, encoded in UTF-16LE. If\n                    nullptr is passed, the AP is cleared for that mode. If the\n                    mode is Normal, APs for all modes are cleared.\n\n Returns true if successful."]
    pub fn FPDFAnnot_SetAP(
        annot: FPDF_ANNOTATION,
        appearanceMode: FPDF_ANNOT_APPEARANCEMODE,
        value: FPDF_WIDESTRING,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the AP (appearance string) from |annot|'s dictionary for a given\n |appearanceMode|.\n |buffer| is only modified if |buflen| is large enough to hold the whole AP\n string. If |buflen| is smaller, the total size of the AP is still returned,\n but nothing is copied.\n If there is no appearance stream for |annot| in |appearanceMode|, an empty\n string is written to |buf| and 2 is returned.\n On other errors, nothing is written to |buffer| and 0 is returned.\n\n   annot          - handle to an annotation.\n   appearanceMode - the appearance mode (normal, rollover or down) for which\n                    to get the AP.\n   buffer         - buffer for holding the value string, encoded in UTF-16LE.\n   buflen         - length of the buffer in bytes.\n\n Returns the length of the string value in bytes."]
    pub fn FPDFAnnot_GetAP(
        annot: FPDF_ANNOTATION,
        appearanceMode: FPDF_ANNOT_APPEARANCEMODE,
        buffer: *mut FPDF_WCHAR,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Get the annotation corresponding to |key| in |annot|'s dictionary. Common\n keys for linking annotations include \"IRT\" and \"Popup\". Must call\n FPDFPage_CloseAnnot() when the annotation returned by this function is no\n longer needed.\n\n   annot  - handle to an annotation.\n   key    - the key to the requested dictionary entry, encoded in UTF-8.\n\n Returns a handle to the linked annotation object, or NULL on failure."]
    pub fn FPDFAnnot_GetLinkedAnnot(
        annot: FPDF_ANNOTATION,
        key: FPDF_BYTESTRING,
    ) -> FPDF_ANNOTATION;
}
extern "C" {
    #[doc = " Experimental API.\n Get the annotation flags of |annot|.\n\n   annot    - handle to an annotation.\n\n Returns the annotation flags."]
    pub fn FPDFAnnot_GetFlags(annot: FPDF_ANNOTATION) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Set the |annot|'s flags to be of the value |flags|.\n\n   annot      - handle to an annotation.\n   flags      - the flag values to be set.\n\n Returns true if successful."]
    pub fn FPDFAnnot_SetFlags(annot: FPDF_ANNOTATION, flags: ::std::os::raw::c_int) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the annotation flags of |annot|.\n\n    hHandle     -   handle to the form fill module, returned by\n                    FPDFDOC_InitFormFillEnvironment().\n    annot       -   handle to an interactive form annotation.\n\n Returns the annotation flags specific to interactive forms."]
    pub fn FPDFAnnot_GetFormFieldFlags(
        handle: FPDF_FORMHANDLE,
        annot: FPDF_ANNOTATION,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Retrieves an interactive form annotation whose rectangle contains a given\n point on a page. Must call FPDFPage_CloseAnnot() when the annotation returned\n is no longer needed.\n\n\n    hHandle     -   handle to the form fill module, returned by\n                    FPDFDOC_InitFormFillEnvironment().\n    page        -   handle to the page, returned by FPDF_LoadPage function.\n    point       -   position in PDF \"user space\".\n\n Returns the interactive form annotation whose rectangle contains the given\n coordinates on the page. If there is no such annotation, return NULL."]
    pub fn FPDFAnnot_GetFormFieldAtPoint(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        point: *const FS_POINTF,
    ) -> FPDF_ANNOTATION;
}
extern "C" {
    #[doc = " Experimental API.\n Gets the name of |annot|, which is an interactive form annotation.\n |buffer| is only modified if |buflen| is longer than the length of contents.\n In case of error, nothing will be added to |buffer| and the return value will\n be 0. Note that return value of empty string is 2 for \"\\0\\0\".\n\n    hHandle     -   handle to the form fill module, returned by\n                    FPDFDOC_InitFormFillEnvironment().\n    annot       -   handle to an interactive form annotation.\n    buffer      -   buffer for holding the name string, encoded in UTF-16LE.\n    buflen      -   length of the buffer in bytes.\n\n Returns the length of the string value in bytes."]
    pub fn FPDFAnnot_GetFormFieldName(
        hHandle: FPDF_FORMHANDLE,
        annot: FPDF_ANNOTATION,
        buffer: *mut FPDF_WCHAR,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Gets the form field type of |annot|, which is an interactive form annotation.\n\n    hHandle     -   handle to the form fill module, returned by\n                    FPDFDOC_InitFormFillEnvironment().\n    annot       -   handle to an interactive form annotation.\n\n Returns the type of the form field (one of the FPDF_FORMFIELD_* values) on\n success. Returns -1 on error.\n See field types in fpdf_formfill.h."]
    pub fn FPDFAnnot_GetFormFieldType(
        hHandle: FPDF_FORMHANDLE,
        annot: FPDF_ANNOTATION,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Gets the value of |annot|, which is an interactive form annotation.\n |buffer| is only modified if |buflen| is longer than the length of contents.\n In case of error, nothing will be added to |buffer| and the return value will\n be 0. Note that return value of empty string is 2 for \"\\0\\0\".\n\n    hHandle     -   handle to the form fill module, returned by\n                    FPDFDOC_InitFormFillEnvironment().\n    annot       -   handle to an interactive form annotation.\n    buffer      -   buffer for holding the value string, encoded in UTF-16LE.\n    buflen      -   length of the buffer in bytes.\n\n Returns the length of the string value in bytes."]
    pub fn FPDFAnnot_GetFormFieldValue(
        hHandle: FPDF_FORMHANDLE,
        annot: FPDF_ANNOTATION,
        buffer: *mut FPDF_WCHAR,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Get the number of options in the |annot|'s \"Opt\" dictionary. Intended for\n use with listbox and combobox widget annotations.\n\n   hHandle - handle to the form fill module, returned by\n             FPDFDOC_InitFormFillEnvironment.\n   annot   - handle to an annotation.\n\n Returns the number of options in \"Opt\" dictionary on success. Return value\n will be -1 if annotation does not have an \"Opt\" dictionary or other error."]
    pub fn FPDFAnnot_GetOptionCount(
        hHandle: FPDF_FORMHANDLE,
        annot: FPDF_ANNOTATION,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Get the string value for the label of the option at |index| in |annot|'s\n \"Opt\" dictionary. Intended for use with listbox and combobox widget\n annotations. |buffer| is only modified if |buflen| is longer than the length\n of contents. If index is out of range or in case of other error, nothing\n will be added to |buffer| and the return value will be 0. Note that\n return value of empty string is 2 for \"\\0\\0\".\n\n   hHandle - handle to the form fill module, returned by\n             FPDFDOC_InitFormFillEnvironment.\n   annot   - handle to an annotation.\n   index   - numeric index of the option in the \"Opt\" array\n   buffer  - buffer for holding the value string, encoded in UTF-16LE.\n   buflen  - length of the buffer in bytes.\n\n Returns the length of the string value in bytes.\n If |annot| does not have an \"Opt\" array, |index| is out of range or if any\n other error occurs, returns 0."]
    pub fn FPDFAnnot_GetOptionLabel(
        hHandle: FPDF_FORMHANDLE,
        annot: FPDF_ANNOTATION,
        index: ::std::os::raw::c_int,
        buffer: *mut FPDF_WCHAR,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Determine whether or not the option at |index| in |annot|'s \"Opt\" dictionary\n is selected. Intended for use with listbox and combobox widget annotations.\n\n   handle  - handle to the form fill module, returned by\n             FPDFDOC_InitFormFillEnvironment.\n   annot   - handle to an annotation.\n   index   - numeric index of the option in the \"Opt\" array.\n\n Returns true if the option at |index| in |annot|'s \"Opt\" dictionary is\n selected, false otherwise."]
    pub fn FPDFAnnot_IsOptionSelected(
        handle: FPDF_FORMHANDLE,
        annot: FPDF_ANNOTATION,
        index: ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the float value of the font size for an |annot| with variable text.\n If 0, the font is to be auto-sized: its size is computed as a function of\n the height of the annotation rectangle.\n\n   hHandle - handle to the form fill module, returned by\n             FPDFDOC_InitFormFillEnvironment.\n   annot   - handle to an annotation.\n   value   - Required. Float which will be set to font size on success.\n\n Returns true if the font size was set in |value|, false on error or if\n |value| not provided."]
    pub fn FPDFAnnot_GetFontSize(
        hHandle: FPDF_FORMHANDLE,
        annot: FPDF_ANNOTATION,
        value: *mut f32,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Determine if |annot| is a form widget that is checked. Intended for use with\n checkbox and radio button widgets.\n\n   hHandle - handle to the form fill module, returned by\n             FPDFDOC_InitFormFillEnvironment.\n   annot   - handle to an annotation.\n\n Returns true if |annot| is a form widget and is checked, false otherwise."]
    pub fn FPDFAnnot_IsChecked(hHandle: FPDF_FORMHANDLE, annot: FPDF_ANNOTATION) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Set the list of focusable annotation subtypes. Annotations of subtype\n FPDF_ANNOT_WIDGET are by default focusable. New subtypes set using this API\n will override the existing subtypes.\n\n   hHandle  - handle to the form fill module, returned by\n              FPDFDOC_InitFormFillEnvironment.\n   subtypes - list of annotation subtype which can be tabbed over.\n   count    - total number of annotation subtype in list.\n Returns true if list of annotation subtype is set successfully, false\n otherwise."]
    pub fn FPDFAnnot_SetFocusableSubtypes(
        hHandle: FPDF_FORMHANDLE,
        subtypes: *const FPDF_ANNOTATION_SUBTYPE,
        count: usize,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the count of focusable annotation subtypes as set by host\n for a |hHandle|.\n\n   hHandle  - handle to the form fill module, returned by\n              FPDFDOC_InitFormFillEnvironment.\n Returns the count of focusable annotation subtypes or -1 on error.\n Note : Annotations of type FPDF_ANNOT_WIDGET are by default focusable."]
    pub fn FPDFAnnot_GetFocusableSubtypesCount(hHandle: FPDF_FORMHANDLE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Get the list of focusable annotation subtype as set by host.\n\n   hHandle  - handle to the form fill module, returned by\n              FPDFDOC_InitFormFillEnvironment.\n   subtypes - receives the list of annotation subtype which can be tabbed\n              over. Caller must have allocated |subtypes| more than or\n              equal to the count obtained from\n              FPDFAnnot_GetFocusableSubtypesCount() API.\n   count    - size of |subtypes|.\n Returns true on success and set list of annotation subtype to |subtypes|,\n false otherwise.\n Note : Annotations of type FPDF_ANNOT_WIDGET are by default focusable."]
    pub fn FPDFAnnot_GetFocusableSubtypes(
        hHandle: FPDF_FORMHANDLE,
        subtypes: *mut FPDF_ANNOTATION_SUBTYPE,
        count: usize,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Gets FPDF_LINK object for |annot|. Intended to use for link annotations.\n\n   annot   - handle to an annotation.\n\n Returns FPDF_LINK from the FPDF_ANNOTATION and NULL on failure,\n if the input annot is NULL or input annot's subtype is not link."]
    pub fn FPDFAnnot_GetLink(annot: FPDF_ANNOTATION) -> FPDF_LINK;
}
extern "C" {
    #[doc = " Experimental API.\n Gets the count of annotations in the |annot|'s control group.\n A group of interactive form annotations is collectively called a form\n control group. Here, |annot|, an interactive form annotation, should be\n either a radio button or a checkbox.\n\n   hHandle - handle to the form fill module, returned by\n             FPDFDOC_InitFormFillEnvironment.\n   annot   - handle to an annotation.\n\n Returns number of controls in its control group or -1 on error."]
    pub fn FPDFAnnot_GetFormControlCount(
        hHandle: FPDF_FORMHANDLE,
        annot: FPDF_ANNOTATION,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Gets the index of |annot| in |annot|'s control group.\n A group of interactive form annotations is collectively called a form\n control group. Here, |annot|, an interactive form annotation, should be\n either a radio button or a checkbox.\n\n   hHandle - handle to the form fill module, returned by\n             FPDFDOC_InitFormFillEnvironment.\n   annot   - handle to an annotation.\n\n Returns index of a given |annot| in its control group or -1 on error."]
    pub fn FPDFAnnot_GetFormControlIndex(
        hHandle: FPDF_FORMHANDLE,
        annot: FPDF_ANNOTATION,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Gets the export value of |annot| which is an interactive form annotation.\n Intended for use with radio button and checkbox widget annotations.\n |buffer| is only modified if |buflen| is longer than the length of contents.\n In case of error, nothing will be added to |buffer| and the return value\n will be 0. Note that return value of empty string is 2 for \"\\0\\0\".\n\n    hHandle     -   handle to the form fill module, returned by\n                    FPDFDOC_InitFormFillEnvironment().\n    annot       -   handle to an interactive form annotation.\n    buffer      -   buffer for holding the value string, encoded in UTF-16LE.\n    buflen      -   length of the buffer in bytes.\n\n Returns the length of the string value in bytes."]
    pub fn FPDFAnnot_GetFormFieldExportValue(
        hHandle: FPDF_FORMHANDLE,
        annot: FPDF_ANNOTATION,
        buffer: *mut FPDF_WCHAR,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Add a URI action to |annot|, overwriting the existing action, if any.\n\n   annot  - handle to a link annotation.\n   uri    - the URI to be set, encoded in 7-bit ASCII.\n\n Returns true if successful."]
    pub fn FPDFAnnot_SetURI(
        annot: FPDF_ANNOTATION,
        uri: *const ::std::os::raw::c_char,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the number of embedded files in |document|.\n\n   document - handle to a document.\n\n Returns the number of embedded files in |document|."]
    pub fn FPDFDoc_GetAttachmentCount(document: FPDF_DOCUMENT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Add an embedded file with |name| in |document|. If |name| is empty, or if\n |name| is the name of a existing embedded file in |document|, or if\n |document|'s embedded file name tree is too deep (i.e. |document| has too\n many embedded files already), then a new attachment will not be added.\n\n   document - handle to a document.\n   name     - name of the new attachment.\n\n Returns a handle to the new attachment object, or NULL on failure."]
    pub fn FPDFDoc_AddAttachment(document: FPDF_DOCUMENT, name: FPDF_WIDESTRING)
        -> FPDF_ATTACHMENT;
}
extern "C" {
    #[doc = " Experimental API.\n Get the embedded attachment at |index| in |document|. Note that the returned\n attachment handle is only valid while |document| is open.\n\n   document - handle to a document.\n   index    - the index of the requested embedded file.\n\n Returns the handle to the attachment object, or NULL on failure."]
    pub fn FPDFDoc_GetAttachment(
        document: FPDF_DOCUMENT,
        index: ::std::os::raw::c_int,
    ) -> FPDF_ATTACHMENT;
}
extern "C" {
    #[doc = " Experimental API.\n Delete the embedded attachment at |index| in |document|. Note that this does\n not remove the attachment data from the PDF file; it simply removes the\n file's entry in the embedded files name tree so that it does not appear in\n the attachment list. This behavior may change in the future.\n\n   document - handle to a document.\n   index    - the index of the embedded file to be deleted.\n\n Returns true if successful."]
    pub fn FPDFDoc_DeleteAttachment(
        document: FPDF_DOCUMENT,
        index: ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the name of the |attachment| file. |buffer| is only modified if |buflen|\n is longer than the length of the file name. On errors, |buffer| is unmodified\n and the returned length is 0.\n\n   attachment - handle to an attachment.\n   buffer     - buffer for holding the file name, encoded in UTF-16LE.\n   buflen     - length of the buffer in bytes.\n\n Returns the length of the file name in bytes."]
    pub fn FPDFAttachment_GetName(
        attachment: FPDF_ATTACHMENT,
        buffer: *mut FPDF_WCHAR,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Check if the params dictionary of |attachment| has |key| as a key.\n\n   attachment - handle to an attachment.\n   key        - the key to look for, encoded in UTF-8.\n\n Returns true if |key| exists."]
    pub fn FPDFAttachment_HasKey(attachment: FPDF_ATTACHMENT, key: FPDF_BYTESTRING) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the type of the value corresponding to |key| in the params dictionary of\n the embedded |attachment|.\n\n   attachment - handle to an attachment.\n   key        - the key to look for, encoded in UTF-8.\n\n Returns the type of the dictionary value."]
    pub fn FPDFAttachment_GetValueType(
        attachment: FPDF_ATTACHMENT,
        key: FPDF_BYTESTRING,
    ) -> FPDF_OBJECT_TYPE;
}
extern "C" {
    #[doc = " Experimental API.\n Set the string value corresponding to |key| in the params dictionary of the\n embedded file |attachment|, overwriting the existing value if any. The value\n type should be FPDF_OBJECT_STRING after this function call succeeds.\n\n   attachment - handle to an attachment.\n   key        - the key to the dictionary entry, encoded in UTF-8.\n   value      - the string value to be set, encoded in UTF-16LE.\n\n Returns true if successful."]
    pub fn FPDFAttachment_SetStringValue(
        attachment: FPDF_ATTACHMENT,
        key: FPDF_BYTESTRING,
        value: FPDF_WIDESTRING,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the string value corresponding to |key| in the params dictionary of the\n embedded file |attachment|. |buffer| is only modified if |buflen| is longer\n than the length of the string value. Note that if |key| does not exist in the\n dictionary or if |key|'s corresponding value in the dictionary is not a\n string (i.e. the value is not of type FPDF_OBJECT_STRING or\n FPDF_OBJECT_NAME), then an empty string would be copied to |buffer| and the\n return value would be 2. On other errors, nothing would be added to |buffer|\n and the return value would be 0.\n\n   attachment - handle to an attachment.\n   key        - the key to the requested string value, encoded in UTF-8.\n   buffer     - buffer for holding the string value encoded in UTF-16LE.\n   buflen     - length of the buffer in bytes.\n\n Returns the length of the dictionary value string in bytes."]
    pub fn FPDFAttachment_GetStringValue(
        attachment: FPDF_ATTACHMENT,
        key: FPDF_BYTESTRING,
        buffer: *mut FPDF_WCHAR,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Set the file data of |attachment|, overwriting the existing file data if any.\n The creation date and checksum will be updated, while all other dictionary\n entries will be deleted. Note that only contents with |len| smaller than\n INT_MAX is supported.\n\n   attachment - handle to an attachment.\n   contents   - buffer holding the file data to write to |attachment|.\n   len        - length of file data in bytes.\n\n Returns true if successful."]
    pub fn FPDFAttachment_SetFile(
        attachment: FPDF_ATTACHMENT,
        document: FPDF_DOCUMENT,
        contents: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_ulong,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the file data of |attachment|.\n When the attachment file data is readable, true is returned, and |out_buflen|\n is updated to indicate the file data size. |buffer| is only modified if\n |buflen| is non-null and long enough to contain the entire file data. Callers\n must check both the return value and the input |buflen| is no less than the\n returned |out_buflen| before using the data.\n\n Otherwise, when the attachment file data is unreadable or when |out_buflen|\n is null, false is returned and |buffer| and |out_buflen| remain unmodified.\n\n   attachment - handle to an attachment.\n   buffer     - buffer for holding the file data from |attachment|.\n   buflen     - length of the buffer in bytes.\n   out_buflen - pointer to the variable that will receive the minimum buffer\n                size to contain the file data of |attachment|.\n\n Returns true on success, false otherwise."]
    pub fn FPDFAttachment_GetFile(
        attachment: FPDF_ATTACHMENT,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
        out_buflen: *mut ::std::os::raw::c_ulong,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n\n Determine if |document| represents a tagged PDF.\n\n For the definition of tagged PDF, See (see 10.7 \"Tagged PDF\" in PDF\n Reference 1.7).\n\n   document - handle to a document.\n\n Returns |true| iff |document| is a tagged PDF."]
    pub fn FPDFCatalog_IsTagged(document: FPDF_DOCUMENT) -> FPDF_BOOL;
}
#[doc = " Interface for checking whether sections of the file are available."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FX_FILEAVAIL {
    #[doc = " Version number of the interface. Must be 1."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Reports if the specified data section is currently available. A section is\n available if all bytes in the section are available.\n\n Interface Version: 1\n Implementation Required: Yes\n\n   pThis  - pointer to the interface structure.\n   offset - the offset of the data section in the file.\n   size   - the size of the data section.\n\n Returns true if the specified data section at |offset| of |size|\n is available."]
    pub IsDataAvail: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FX_FILEAVAIL, offset: usize, size: usize) -> FPDF_BOOL,
    >,
}
#[test]
fn bindgen_test_layout__FX_FILEAVAIL() {
    const UNINIT: ::std::mem::MaybeUninit<_FX_FILEAVAIL> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FX_FILEAVAIL>(),
        16usize,
        concat!("Size of: ", stringify!(_FX_FILEAVAIL))
    );
    assert_eq!(
        ::std::mem::align_of::<_FX_FILEAVAIL>(),
        8usize,
        concat!("Alignment of ", stringify!(_FX_FILEAVAIL))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FX_FILEAVAIL),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsDataAvail) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FX_FILEAVAIL),
            "::",
            stringify!(IsDataAvail)
        )
    );
}
#[doc = " Interface for checking whether sections of the file are available."]
pub type FX_FILEAVAIL = _FX_FILEAVAIL;
extern "C" {
    #[doc = " Create a document availability provider.\n\n   file_avail - pointer to file availability interface.\n   file       - pointer to a file access interface.\n\n Returns a handle to the document availability provider, or NULL on error.\n\n FPDFAvail_Destroy() must be called when done with the availability provider."]
    pub fn FPDFAvail_Create(
        file_avail: *mut FX_FILEAVAIL,
        file: *mut FPDF_FILEACCESS,
    ) -> FPDF_AVAIL;
}
extern "C" {
    #[doc = " Destroy the |avail| document availability provider.\n\n   avail - handle to document availability provider to be destroyed."]
    pub fn FPDFAvail_Destroy(avail: FPDF_AVAIL);
}
#[doc = " Download hints interface. Used to receive hints for further downloading."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FX_DOWNLOADHINTS {
    #[doc = " Version number of the interface. Must be 1."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Add a section to be downloaded.\n\n Interface Version: 1\n Implementation Required: Yes\n\n   pThis  - pointer to the interface structure.\n   offset - the offset of the hint reported to be downloaded.\n   size   - the size of the hint reported to be downloaded.\n\n The |offset| and |size| of the section may not be unique. Part of the\n section might be already available. The download manager must deal with\n overlapping sections."]
    pub AddSegment: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FX_DOWNLOADHINTS, offset: usize, size: usize),
    >,
}
#[test]
fn bindgen_test_layout__FX_DOWNLOADHINTS() {
    const UNINIT: ::std::mem::MaybeUninit<_FX_DOWNLOADHINTS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FX_DOWNLOADHINTS>(),
        16usize,
        concat!("Size of: ", stringify!(_FX_DOWNLOADHINTS))
    );
    assert_eq!(
        ::std::mem::align_of::<_FX_DOWNLOADHINTS>(),
        8usize,
        concat!("Alignment of ", stringify!(_FX_DOWNLOADHINTS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FX_DOWNLOADHINTS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AddSegment) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FX_DOWNLOADHINTS),
            "::",
            stringify!(AddSegment)
        )
    );
}
#[doc = " Download hints interface. Used to receive hints for further downloading."]
pub type FX_DOWNLOADHINTS = _FX_DOWNLOADHINTS;
extern "C" {
    #[doc = " Checks if the document is ready for loading, if not, gets download hints.\n\n   avail - handle to document availability provider.\n   hints - pointer to a download hints interface.\n\n Returns one of:\n   PDF_DATA_ERROR: A common error is returned. Data availability unknown.\n   PDF_DATA_NOTAVAIL: Data not yet available.\n   PDF_DATA_AVAIL: Data available.\n\n Applications should call this function whenever new data arrives, and process\n all the generated download hints, if any, until the function returns\n |PDF_DATA_ERROR| or |PDF_DATA_AVAIL|.\n if hints is nullptr, the function just check current document availability.\n\n Once all data is available, call FPDFAvail_GetDocument() to get a document\n handle."]
    pub fn FPDFAvail_IsDocAvail(
        avail: FPDF_AVAIL,
        hints: *mut FX_DOWNLOADHINTS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get document from the availability provider.\n\n   avail    - handle to document availability provider.\n   password - password for decrypting the PDF file. Optional.\n\n Returns a handle to the document.\n\n When FPDFAvail_IsDocAvail() returns TRUE, call FPDFAvail_GetDocument() to\n retrieve the document handle.\n See the comments for FPDF_LoadDocument() regarding the encoding for\n |password|."]
    pub fn FPDFAvail_GetDocument(avail: FPDF_AVAIL, password: FPDF_BYTESTRING) -> FPDF_DOCUMENT;
}
extern "C" {
    #[doc = " Get the page number for the first available page in a linearized PDF.\n\n   doc - document handle.\n\n Returns the zero-based index for the first available page.\n\n For most linearized PDFs, the first available page will be the first page,\n however, some PDFs might make another page the first available page.\n For non-linearized PDFs, this function will always return zero."]
    pub fn FPDFAvail_GetFirstPageNum(doc: FPDF_DOCUMENT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if |page_index| is ready for loading, if not, get the\n |FX_DOWNLOADHINTS|.\n\n   avail      - handle to document availability provider.\n   page_index - index number of the page. Zero for the first page.\n   hints      - pointer to a download hints interface. Populated if\n                |page_index| is not available.\n\n Returns one of:\n   PDF_DATA_ERROR: A common error is returned. Data availability unknown.\n   PDF_DATA_NOTAVAIL: Data not yet available.\n   PDF_DATA_AVAIL: Data available.\n\n This function can be called only after FPDFAvail_GetDocument() is called.\n Applications should call this function whenever new data arrives and process\n all the generated download |hints|, if any, until this function returns\n |PDF_DATA_ERROR| or |PDF_DATA_AVAIL|. Applications can then perform page\n loading.\n if hints is nullptr, the function just check current availability of\n specified page."]
    pub fn FPDFAvail_IsPageAvail(
        avail: FPDF_AVAIL,
        page_index: ::std::os::raw::c_int,
        hints: *mut FX_DOWNLOADHINTS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if form data is ready for initialization, if not, get the\n |FX_DOWNLOADHINTS|.\n\n   avail - handle to document availability provider.\n   hints - pointer to a download hints interface. Populated if form is not\n           ready for initialization.\n\n Returns one of:\n   PDF_FORM_ERROR: A common eror, in general incorrect parameters.\n   PDF_FORM_NOTAVAIL: Data not available.\n   PDF_FORM_AVAIL: Data available.\n   PDF_FORM_NOTEXIST: No form data.\n\n This function can be called only after FPDFAvail_GetDocument() is called.\n The application should call this function whenever new data arrives and\n process all the generated download |hints|, if any, until the function\n |PDF_FORM_ERROR|, |PDF_FORM_AVAIL| or |PDF_FORM_NOTEXIST|.\n if hints is nullptr, the function just check current form availability.\n\n Applications can then perform page loading. It is recommend to call\n FPDFDOC_InitFormFillEnvironment() when |PDF_FORM_AVAIL| is returned."]
    pub fn FPDFAvail_IsFormAvail(
        avail: FPDF_AVAIL,
        hints: *mut FX_DOWNLOADHINTS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check whether a document is a linearized PDF.\n\n   avail - handle to document availability provider.\n\n Returns one of:\n   PDF_LINEARIZED\n   PDF_NOT_LINEARIZED\n   PDF_LINEARIZATION_UNKNOWN\n\n FPDFAvail_IsLinearized() will return |PDF_LINEARIZED| or |PDF_NOT_LINEARIZED|\n when we have 1k  of data. If the files size less than 1k, it returns\n |PDF_LINEARIZATION_UNKNOWN| as there is insufficient information to determine\n if the PDF is linearlized."]
    pub fn FPDFAvail_IsLinearized(avail: FPDF_AVAIL) -> ::std::os::raw::c_int;
}
#[doc = " Convenience types."]
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
#[doc = " Fixed-size types, underlying types depend on word size and compiler."]
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
#[doc = " Smallest types with at least a given width."]
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
#[doc = " These few don't really vary by system, they always correspond\nto one of the other defined types."]
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
#[doc = " C99: An integer type that can be accessed as an atomic entity,\neven in the presence of asynchronous interrupts.\nIt is not currently necessary for this to be machine-specific."]
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[doc = " Signed."]
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
#[doc = " Unsigned."]
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
#[doc = " Signed."]
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
#[doc = " Unsigned."]
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
#[doc = " Largest integral types."]
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_IMAGEOBJ_METADATA {
    #[doc = " The image width in pixels."]
    pub width: ::std::os::raw::c_uint,
    #[doc = " The image height in pixels."]
    pub height: ::std::os::raw::c_uint,
    #[doc = " The image's horizontal pixel-per-inch."]
    pub horizontal_dpi: f32,
    #[doc = " The image's vertical pixel-per-inch."]
    pub vertical_dpi: f32,
    #[doc = " The number of bits used to represent each pixel."]
    pub bits_per_pixel: ::std::os::raw::c_uint,
    #[doc = " The image's colorspace. See above for the list of FPDF_COLORSPACE_*."]
    pub colorspace: ::std::os::raw::c_int,
    #[doc = " The image's marked content ID. Useful for pairing with associated alt-text.\n A value of -1 indicates no ID."]
    pub marked_content_id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_FPDF_IMAGEOBJ_METADATA() {
    const UNINIT: ::std::mem::MaybeUninit<FPDF_IMAGEOBJ_METADATA> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FPDF_IMAGEOBJ_METADATA>(),
        28usize,
        concat!("Size of: ", stringify!(FPDF_IMAGEOBJ_METADATA))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_IMAGEOBJ_METADATA>(),
        4usize,
        concat!("Alignment of ", stringify!(FPDF_IMAGEOBJ_METADATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_IMAGEOBJ_METADATA),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_IMAGEOBJ_METADATA),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).horizontal_dpi) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_IMAGEOBJ_METADATA),
            "::",
            stringify!(horizontal_dpi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vertical_dpi) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_IMAGEOBJ_METADATA),
            "::",
            stringify!(vertical_dpi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits_per_pixel) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_IMAGEOBJ_METADATA),
            "::",
            stringify!(bits_per_pixel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorspace) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_IMAGEOBJ_METADATA),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).marked_content_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_IMAGEOBJ_METADATA),
            "::",
            stringify!(marked_content_id)
        )
    );
}
extern "C" {
    #[doc = " Create a new PDF document.\n\n Returns a handle to a new document, or NULL on failure."]
    pub fn FPDF_CreateNewDocument() -> FPDF_DOCUMENT;
}
extern "C" {
    #[doc = " Create a new PDF page.\n\n   document   - handle to document.\n   page_index - suggested 0-based index of the page to create. If it is larger\n                than document's current last index(L), the created page index\n                is the next available index -- L+1.\n   width      - the page width in points.\n   height     - the page height in points.\n\n Returns the handle to the new page or NULL on failure.\n\n The page should be closed with FPDF_ClosePage() when finished as\n with any other page in the document."]
    pub fn FPDFPage_New(
        document: FPDF_DOCUMENT,
        page_index: ::std::os::raw::c_int,
        width: f64,
        height: f64,
    ) -> FPDF_PAGE;
}
extern "C" {
    #[doc = " Delete the page at |page_index|.\n\n   document   - handle to document.\n   page_index - the index of the page to delete."]
    pub fn FPDFPage_Delete(document: FPDF_DOCUMENT, page_index: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Get the rotation of |page|.\n\n   page - handle to a page\n\n Returns one of the following indicating the page rotation:\n   0 - No rotation.\n   1 - Rotated 90 degrees clockwise.\n   2 - Rotated 180 degrees clockwise.\n   3 - Rotated 270 degrees clockwise."]
    pub fn FPDFPage_GetRotation(page: FPDF_PAGE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set rotation for |page|.\n\n   page   - handle to a page.\n   rotate - the rotation value, one of:\n              0 - No rotation.\n              1 - Rotated 90 degrees clockwise.\n              2 - Rotated 180 degrees clockwise.\n              3 - Rotated 270 degrees clockwise."]
    pub fn FPDFPage_SetRotation(page: FPDF_PAGE, rotate: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Insert |page_obj| into |page|.\n\n   page     - handle to a page\n   page_obj - handle to a page object. The |page_obj| will be automatically\n              freed."]
    pub fn FPDFPage_InsertObject(page: FPDF_PAGE, page_obj: FPDF_PAGEOBJECT);
}
extern "C" {
    #[doc = " Experimental API.\n Remove |page_obj| from |page|.\n\n   page     - handle to a page\n   page_obj - handle to a page object to be removed.\n\n Returns TRUE on success.\n\n Ownership is transferred to the caller. Call FPDFPageObj_Destroy() to free\n it."]
    pub fn FPDFPage_RemoveObject(page: FPDF_PAGE, page_obj: FPDF_PAGEOBJECT) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get number of page objects inside |page|.\n\n   page - handle to a page.\n\n Returns the number of objects in |page|."]
    pub fn FPDFPage_CountObjects(page: FPDF_PAGE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get object in |page| at |index|.\n\n   page  - handle to a page.\n   index - the index of a page object.\n\n Returns the handle to the page object, or NULL on failed."]
    pub fn FPDFPage_GetObject(page: FPDF_PAGE, index: ::std::os::raw::c_int) -> FPDF_PAGEOBJECT;
}
extern "C" {
    #[doc = " Checks if |page| contains transparency.\n\n   page - handle to a page.\n\n Returns TRUE if |page| contains transparency."]
    pub fn FPDFPage_HasTransparency(page: FPDF_PAGE) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Generate the content of |page|.\n\n   page - handle to a page.\n\n Returns TRUE on success.\n\n Before you save the page to a file, or reload the page, you must call\n |FPDFPage_GenerateContent| or any changes to |page| will be lost."]
    pub fn FPDFPage_GenerateContent(page: FPDF_PAGE) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Destroy |page_obj| by releasing its resources. |page_obj| must have been\n created by FPDFPageObj_CreateNew{Path|Rect}() or\n FPDFPageObj_New{Text|Image}Obj(). This function must be called on\n newly-created objects if they are not added to a page through\n FPDFPage_InsertObject() or to an annotation through FPDFAnnot_AppendObject().\n\n   page_obj - handle to a page object."]
    pub fn FPDFPageObj_Destroy(page_obj: FPDF_PAGEOBJECT);
}
extern "C" {
    #[doc = " Checks if |page_object| contains transparency.\n\n   page_object - handle to a page object.\n\n Returns TRUE if |page_object| contains transparency."]
    pub fn FPDFPageObj_HasTransparency(page_object: FPDF_PAGEOBJECT) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get type of |page_object|.\n\n   page_object - handle to a page object.\n\n Returns one of the FPDF_PAGEOBJ_* values on success, FPDF_PAGEOBJ_UNKNOWN on\n error."]
    pub fn FPDFPageObj_GetType(page_object: FPDF_PAGEOBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Transform |page_object| by the given matrix.\n\n   page_object - handle to a page object.\n   a           - matrix value.\n   b           - matrix value.\n   c           - matrix value.\n   d           - matrix value.\n   e           - matrix value.\n   f           - matrix value.\n\n The matrix is composed as:\n   |a c e|\n   |b d f|\n and can be used to scale, rotate, shear and translate the |page_object|."]
    pub fn FPDFPageObj_Transform(
        page_object: FPDF_PAGEOBJECT,
        a: f64,
        b: f64,
        c: f64,
        d: f64,
        e: f64,
        f: f64,
    );
}
extern "C" {
    #[doc = " Experimental API.\n Get the transform matrix of a page object.\n\n   page_object - handle to a page object.\n   matrix      - pointer to struct to receive the matrix value.\n\n The matrix is composed as:\n   |a c e|\n   |b d f|\n and used to scale, rotate, shear and translate the page object.\n\n Returns TRUE on success."]
    pub fn FPDFPageObj_GetMatrix(page_object: FPDF_PAGEOBJECT, matrix: *mut FS_MATRIX)
        -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Set the transform matrix of a page object.\n\n   page_object - handle to a page object.\n   matrix      - pointer to struct with the matrix value.\n\n The matrix is composed as:\n   |a c e|\n   |b d f|\n and can be used to scale, rotate, shear and translate the page object.\n\n Returns TRUE on success."]
    pub fn FPDFPageObj_SetMatrix(path: FPDF_PAGEOBJECT, matrix: *const FS_MATRIX) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Transform all annotations in |page|.\n\n   page - handle to a page.\n   a    - matrix value.\n   b    - matrix value.\n   c    - matrix value.\n   d    - matrix value.\n   e    - matrix value.\n   f    - matrix value.\n\n The matrix is composed as:\n   |a c e|\n   |b d f|\n and can be used to scale, rotate, shear and translate the |page| annotations."]
    pub fn FPDFPage_TransformAnnots(
        page: FPDF_PAGE,
        a: f64,
        b: f64,
        c: f64,
        d: f64,
        e: f64,
        f: f64,
    );
}
extern "C" {
    #[doc = " Create a new image object.\n\n   document - handle to a document.\n\n Returns a handle to a new image object."]
    pub fn FPDFPageObj_NewImageObj(document: FPDF_DOCUMENT) -> FPDF_PAGEOBJECT;
}
extern "C" {
    #[doc = " Experimental API.\n Get number of content marks in |page_object|.\n\n   page_object - handle to a page object.\n\n Returns the number of content marks in |page_object|, or -1 in case of\n failure."]
    pub fn FPDFPageObj_CountMarks(page_object: FPDF_PAGEOBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Get content mark in |page_object| at |index|.\n\n   page_object - handle to a page object.\n   index       - the index of a page object.\n\n Returns the handle to the content mark, or NULL on failure. The handle is\n still owned by the library, and it should not be freed directly. It becomes\n invalid if the page object is destroyed, either directly or indirectly by\n unloading the page."]
    pub fn FPDFPageObj_GetMark(
        page_object: FPDF_PAGEOBJECT,
        index: ::std::os::raw::c_ulong,
    ) -> FPDF_PAGEOBJECTMARK;
}
extern "C" {
    #[doc = " Experimental API.\n Add a new content mark to a |page_object|.\n\n   page_object - handle to a page object.\n   name        - the name (tag) of the mark.\n\n Returns the handle to the content mark, or NULL on failure. The handle is\n still owned by the library, and it should not be freed directly. It becomes\n invalid if the page object is destroyed, either directly or indirectly by\n unloading the page."]
    pub fn FPDFPageObj_AddMark(
        page_object: FPDF_PAGEOBJECT,
        name: FPDF_BYTESTRING,
    ) -> FPDF_PAGEOBJECTMARK;
}
extern "C" {
    #[doc = " Experimental API.\n Removes a content |mark| from a |page_object|.\n The mark handle will be invalid after the removal.\n\n   page_object - handle to a page object.\n   mark        - handle to a content mark in that object to remove.\n\n Returns TRUE if the operation succeeded, FALSE if it failed."]
    pub fn FPDFPageObj_RemoveMark(
        page_object: FPDF_PAGEOBJECT,
        mark: FPDF_PAGEOBJECTMARK,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the name of a content mark.\n\n   mark       - handle to a content mark.\n   buffer     - buffer for holding the returned name in UTF-16LE. This is only\n                modified if |buflen| is longer than the length of the name.\n                Optional, pass null to just retrieve the size of the buffer\n                needed.\n   buflen     - length of the buffer.\n   out_buflen - pointer to variable that will receive the minimum buffer size\n                to contain the name. Not filled if FALSE is returned.\n\n Returns TRUE if the operation succeeded, FALSE if it failed."]
    pub fn FPDFPageObjMark_GetName(
        mark: FPDF_PAGEOBJECTMARK,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
        out_buflen: *mut ::std::os::raw::c_ulong,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the number of key/value pair parameters in |mark|.\n\n   mark   - handle to a content mark.\n\n Returns the number of key/value pair parameters |mark|, or -1 in case of\n failure."]
    pub fn FPDFPageObjMark_CountParams(mark: FPDF_PAGEOBJECTMARK) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Get the key of a property in a content mark.\n\n   mark       - handle to a content mark.\n   index      - index of the property.\n   buffer     - buffer for holding the returned key in UTF-16LE. This is only\n                modified if |buflen| is longer than the length of the key.\n                Optional, pass null to just retrieve the size of the buffer\n                needed.\n   buflen     - length of the buffer.\n   out_buflen - pointer to variable that will receive the minimum buffer size\n                to contain the key. Not filled if FALSE is returned.\n\n Returns TRUE if the operation was successful, FALSE otherwise."]
    pub fn FPDFPageObjMark_GetParamKey(
        mark: FPDF_PAGEOBJECTMARK,
        index: ::std::os::raw::c_ulong,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
        out_buflen: *mut ::std::os::raw::c_ulong,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the type of the value of a property in a content mark by key.\n\n   mark   - handle to a content mark.\n   key    - string key of the property.\n\n Returns the type of the value, or FPDF_OBJECT_UNKNOWN in case of failure."]
    pub fn FPDFPageObjMark_GetParamValueType(
        mark: FPDF_PAGEOBJECTMARK,
        key: FPDF_BYTESTRING,
    ) -> FPDF_OBJECT_TYPE;
}
extern "C" {
    #[doc = " Experimental API.\n Get the value of a number property in a content mark by key as int.\n FPDFPageObjMark_GetParamValueType() should have returned FPDF_OBJECT_NUMBER\n for this property.\n\n   mark      - handle to a content mark.\n   key       - string key of the property.\n   out_value - pointer to variable that will receive the value. Not filled if\n               false is returned.\n\n Returns TRUE if the key maps to a number value, FALSE otherwise."]
    pub fn FPDFPageObjMark_GetParamIntValue(
        mark: FPDF_PAGEOBJECTMARK,
        key: FPDF_BYTESTRING,
        out_value: *mut ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the value of a string property in a content mark by key.\n\n   mark       - handle to a content mark.\n   key        - string key of the property.\n   buffer     - buffer for holding the returned value in UTF-16LE. This is\n                only modified if |buflen| is longer than the length of the\n                value.\n                Optional, pass null to just retrieve the size of the buffer\n                needed.\n   buflen     - length of the buffer.\n   out_buflen - pointer to variable that will receive the minimum buffer size\n                to contain the value. Not filled if FALSE is returned.\n\n Returns TRUE if the key maps to a string/blob value, FALSE otherwise."]
    pub fn FPDFPageObjMark_GetParamStringValue(
        mark: FPDF_PAGEOBJECTMARK,
        key: FPDF_BYTESTRING,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
        out_buflen: *mut ::std::os::raw::c_ulong,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the value of a blob property in a content mark by key.\n\n   mark       - handle to a content mark.\n   key        - string key of the property.\n   buffer     - buffer for holding the returned value. This is only modified\n                if |buflen| is at least as long as the length of the value.\n                Optional, pass null to just retrieve the size of the buffer\n                needed.\n   buflen     - length of the buffer.\n   out_buflen - pointer to variable that will receive the minimum buffer size\n                to contain the value. Not filled if FALSE is returned.\n\n Returns TRUE if the key maps to a string/blob value, FALSE otherwise."]
    pub fn FPDFPageObjMark_GetParamBlobValue(
        mark: FPDF_PAGEOBJECTMARK,
        key: FPDF_BYTESTRING,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
        out_buflen: *mut ::std::os::raw::c_ulong,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Set the value of an int property in a content mark by key. If a parameter\n with key |key| exists, its value is set to |value|. Otherwise, it is added as\n a new parameter.\n\n   document    - handle to the document.\n   page_object - handle to the page object with the mark.\n   mark        - handle to a content mark.\n   key         - string key of the property.\n   value       - int value to set.\n\n Returns TRUE if the operation succeeded, FALSE otherwise."]
    pub fn FPDFPageObjMark_SetIntParam(
        document: FPDF_DOCUMENT,
        page_object: FPDF_PAGEOBJECT,
        mark: FPDF_PAGEOBJECTMARK,
        key: FPDF_BYTESTRING,
        value: ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Set the value of a string property in a content mark by key. If a parameter\n with key |key| exists, its value is set to |value|. Otherwise, it is added as\n a new parameter.\n\n   document    - handle to the document.\n   page_object - handle to the page object with the mark.\n   mark        - handle to a content mark.\n   key         - string key of the property.\n   value       - string value to set.\n\n Returns TRUE if the operation succeeded, FALSE otherwise."]
    pub fn FPDFPageObjMark_SetStringParam(
        document: FPDF_DOCUMENT,
        page_object: FPDF_PAGEOBJECT,
        mark: FPDF_PAGEOBJECTMARK,
        key: FPDF_BYTESTRING,
        value: FPDF_BYTESTRING,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Set the value of a blob property in a content mark by key. If a parameter\n with key |key| exists, its value is set to |value|. Otherwise, it is added as\n a new parameter.\n\n   document    - handle to the document.\n   page_object - handle to the page object with the mark.\n   mark        - handle to a content mark.\n   key         - string key of the property.\n   value       - pointer to blob value to set.\n   value_len   - size in bytes of |value|.\n\n Returns TRUE if the operation succeeded, FALSE otherwise."]
    pub fn FPDFPageObjMark_SetBlobParam(
        document: FPDF_DOCUMENT,
        page_object: FPDF_PAGEOBJECT,
        mark: FPDF_PAGEOBJECTMARK,
        key: FPDF_BYTESTRING,
        value: *mut ::std::os::raw::c_void,
        value_len: ::std::os::raw::c_ulong,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Removes a property from a content mark by key.\n\n   page_object - handle to the page object with the mark.\n   mark        - handle to a content mark.\n   key         - string key of the property.\n\n Returns TRUE if the operation succeeded, FALSE otherwise."]
    pub fn FPDFPageObjMark_RemoveParam(
        page_object: FPDF_PAGEOBJECT,
        mark: FPDF_PAGEOBJECTMARK,
        key: FPDF_BYTESTRING,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Load an image from a JPEG image file and then set it into |image_object|.\n\n   pages        - pointer to the start of all loaded pages, may be NULL.\n   count        - number of |pages|, may be 0.\n   image_object - handle to an image object.\n   file_access  - file access handler which specifies the JPEG image file.\n\n Returns TRUE on success.\n\n The image object might already have an associated image, which is shared and\n cached by the loaded pages. In that case, we need to clear the cached image\n for all the loaded pages. Pass |pages| and page count (|count|) to this API\n to clear the image cache. If the image is not previously shared, or NULL is a\n valid |pages| value."]
    pub fn FPDFImageObj_LoadJpegFile(
        pages: *mut FPDF_PAGE,
        count: ::std::os::raw::c_int,
        image_object: FPDF_PAGEOBJECT,
        file_access: *mut FPDF_FILEACCESS,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Load an image from a JPEG image file and then set it into |image_object|.\n\n   pages        - pointer to the start of all loaded pages, may be NULL.\n   count        - number of |pages|, may be 0.\n   image_object - handle to an image object.\n   file_access  - file access handler which specifies the JPEG image file.\n\n Returns TRUE on success.\n\n The image object might already have an associated image, which is shared and\n cached by the loaded pages. In that case, we need to clear the cached image\n for all the loaded pages. Pass |pages| and page count (|count|) to this API\n to clear the image cache. If the image is not previously shared, or NULL is a\n valid |pages| value. This function loads the JPEG image inline, so the image\n content is copied to the file. This allows |file_access| and its associated\n data to be deleted after this function returns."]
    pub fn FPDFImageObj_LoadJpegFileInline(
        pages: *mut FPDF_PAGE,
        count: ::std::os::raw::c_int,
        image_object: FPDF_PAGEOBJECT,
        file_access: *mut FPDF_FILEACCESS,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " TODO(thestig): Start deprecating this once FPDFPageObj_SetMatrix() is stable.\n\n Set the transform matrix of |image_object|.\n\n   image_object - handle to an image object.\n   a            - matrix value.\n   b            - matrix value.\n   c            - matrix value.\n   d            - matrix value.\n   e            - matrix value.\n   f            - matrix value.\n\n The matrix is composed as:\n   |a c e|\n   |b d f|\n and can be used to scale, rotate, shear and translate the |image_object|.\n\n Returns TRUE on success."]
    pub fn FPDFImageObj_SetMatrix(
        image_object: FPDF_PAGEOBJECT,
        a: f64,
        b: f64,
        c: f64,
        d: f64,
        e: f64,
        f: f64,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Set |bitmap| to |image_object|.\n\n   pages        - pointer to the start of all loaded pages, may be NULL.\n   count        - number of |pages|, may be 0.\n   image_object - handle to an image object.\n   bitmap       - handle of the bitmap.\n\n Returns TRUE on success."]
    pub fn FPDFImageObj_SetBitmap(
        pages: *mut FPDF_PAGE,
        count: ::std::os::raw::c_int,
        image_object: FPDF_PAGEOBJECT,
        bitmap: FPDF_BITMAP,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get a bitmap rasterization of |image_object|. FPDFImageObj_GetBitmap() only\n operates on |image_object| and does not take the associated image mask into\n account. It also ignores the matrix for |image_object|.\n The returned bitmap will be owned by the caller, and FPDFBitmap_Destroy()\n must be called on the returned bitmap when it is no longer needed.\n\n   image_object - handle to an image object.\n\n Returns the bitmap."]
    pub fn FPDFImageObj_GetBitmap(image_object: FPDF_PAGEOBJECT) -> FPDF_BITMAP;
}
extern "C" {
    #[doc = " Experimental API.\n Get a bitmap rasterization of |image_object| that takes the image mask and\n image matrix into account. To render correctly, the caller must provide the\n |document| associated with |image_object|. If there is a |page| associated\n with |image_object| the caller should provide that as well.\n The returned bitmap will be owned by the caller, and FPDFBitmap_Destroy()\n must be called on the returned bitmap when it is no longer needed.\n\n   document     - handle to a document associated with |image_object|.\n   page         - handle to an optional page associated with |image_object|.\n   image_object - handle to an image object.\n\n Returns the bitmap."]
    pub fn FPDFImageObj_GetRenderedBitmap(
        document: FPDF_DOCUMENT,
        page: FPDF_PAGE,
        image_object: FPDF_PAGEOBJECT,
    ) -> FPDF_BITMAP;
}
extern "C" {
    #[doc = " Get the decoded image data of |image_object|. The decoded data is the\n uncompressed image data, i.e. the raw image data after having all filters\n applied. |buffer| is only modified if |buflen| is longer than the length of\n the decoded image data.\n\n   image_object - handle to an image object.\n   buffer       - buffer for holding the decoded image data.\n   buflen       - length of the buffer in bytes.\n\n Returns the length of the decoded image data."]
    pub fn FPDFImageObj_GetImageDataDecoded(
        image_object: FPDF_PAGEOBJECT,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Get the raw image data of |image_object|. The raw data is the image data as\n stored in the PDF without applying any filters. |buffer| is only modified if\n |buflen| is longer than the length of the raw image data.\n\n   image_object - handle to an image object.\n   buffer       - buffer for holding the raw image data.\n   buflen       - length of the buffer in bytes.\n\n Returns the length of the raw image data."]
    pub fn FPDFImageObj_GetImageDataRaw(
        image_object: FPDF_PAGEOBJECT,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Get the number of filters (i.e. decoders) of the image in |image_object|.\n\n   image_object - handle to an image object.\n\n Returns the number of |image_object|'s filters."]
    pub fn FPDFImageObj_GetImageFilterCount(image_object: FPDF_PAGEOBJECT)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the filter at |index| of |image_object|'s list of filters. Note that the\n filters need to be applied in order, i.e. the first filter should be applied\n first, then the second, etc. |buffer| is only modified if |buflen| is longer\n than the length of the filter string.\n\n   image_object - handle to an image object.\n   index        - the index of the filter requested.\n   buffer       - buffer for holding filter string, encoded in UTF-8.\n   buflen       - length of the buffer.\n\n Returns the length of the filter string."]
    pub fn FPDFImageObj_GetImageFilter(
        image_object: FPDF_PAGEOBJECT,
        index: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Get the image metadata of |image_object|, including dimension, DPI, bits per\n pixel, and colorspace. If the |image_object| is not an image object or if it\n does not have an image, then the return value will be false. Otherwise,\n failure to retrieve any specific parameter would result in its value being 0.\n\n   image_object - handle to an image object.\n   page         - handle to the page that |image_object| is on. Required for\n                  retrieving the image's bits per pixel and colorspace.\n   metadata     - receives the image metadata; must not be NULL.\n\n Returns true if successful."]
    pub fn FPDFImageObj_GetImageMetadata(
        image_object: FPDF_PAGEOBJECT,
        page: FPDF_PAGE,
        metadata: *mut FPDF_IMAGEOBJ_METADATA,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Create a new path object at an initial position.\n\n   x - initial horizontal position.\n   y - initial vertical position.\n\n Returns a handle to a new path object."]
    pub fn FPDFPageObj_CreateNewPath(x: f32, y: f32) -> FPDF_PAGEOBJECT;
}
extern "C" {
    #[doc = " Create a closed path consisting of a rectangle.\n\n   x - horizontal position for the left boundary of the rectangle.\n   y - vertical position for the bottom boundary of the rectangle.\n   w - width of the rectangle.\n   h - height of the rectangle.\n\n Returns a handle to the new path object."]
    pub fn FPDFPageObj_CreateNewRect(x: f32, y: f32, w: f32, h: f32) -> FPDF_PAGEOBJECT;
}
extern "C" {
    #[doc = " Get the bounding box of |page_object|.\n\n page_object  - handle to a page object.\n left         - pointer where the left coordinate will be stored\n bottom       - pointer where the bottom coordinate will be stored\n right        - pointer where the right coordinate will be stored\n top          - pointer where the top coordinate will be stored\n\n Returns TRUE on success."]
    pub fn FPDFPageObj_GetBounds(
        page_object: FPDF_PAGEOBJECT,
        left: *mut f32,
        bottom: *mut f32,
        right: *mut f32,
        top: *mut f32,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Set the blend mode of |page_object|.\n\n page_object  - handle to a page object.\n blend_mode   - string containing the blend mode.\n\n Blend mode can be one of following: Color, ColorBurn, ColorDodge, Darken,\n Difference, Exclusion, HardLight, Hue, Lighten, Luminosity, Multiply, Normal,\n Overlay, Saturation, Screen, SoftLight"]
    pub fn FPDFPageObj_SetBlendMode(page_object: FPDF_PAGEOBJECT, blend_mode: FPDF_BYTESTRING);
}
extern "C" {
    #[doc = " Set the stroke RGBA of a page object. Range of values: 0 - 255.\n\n page_object  - the handle to the page object.\n R            - the red component for the object's stroke color.\n G            - the green component for the object's stroke color.\n B            - the blue component for the object's stroke color.\n A            - the stroke alpha for the object.\n\n Returns TRUE on success."]
    pub fn FPDFPageObj_SetStrokeColor(
        page_object: FPDF_PAGEOBJECT,
        R: ::std::os::raw::c_uint,
        G: ::std::os::raw::c_uint,
        B: ::std::os::raw::c_uint,
        A: ::std::os::raw::c_uint,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get the stroke RGBA of a page object. Range of values: 0 - 255.\n\n page_object  - the handle to the page object.\n R            - the red component of the path stroke color.\n G            - the green component of the object's stroke color.\n B            - the blue component of the object's stroke color.\n A            - the stroke alpha of the object.\n\n Returns TRUE on success."]
    pub fn FPDFPageObj_GetStrokeColor(
        page_object: FPDF_PAGEOBJECT,
        R: *mut ::std::os::raw::c_uint,
        G: *mut ::std::os::raw::c_uint,
        B: *mut ::std::os::raw::c_uint,
        A: *mut ::std::os::raw::c_uint,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Set the stroke width of a page object.\n\n path   - the handle to the page object.\n width  - the width of the stroke.\n\n Returns TRUE on success"]
    pub fn FPDFPageObj_SetStrokeWidth(page_object: FPDF_PAGEOBJECT, width: f32) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get the stroke width of a page object.\n\n path   - the handle to the page object.\n width  - the width of the stroke.\n\n Returns TRUE on success"]
    pub fn FPDFPageObj_GetStrokeWidth(page_object: FPDF_PAGEOBJECT, width: *mut f32) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get the line join of |page_object|.\n\n page_object  - handle to a page object.\n\n Returns the line join, or -1 on failure.\n Line join can be one of following: FPDF_LINEJOIN_MITER, FPDF_LINEJOIN_ROUND,\n FPDF_LINEJOIN_BEVEL"]
    pub fn FPDFPageObj_GetLineJoin(page_object: FPDF_PAGEOBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the line join of |page_object|.\n\n page_object  - handle to a page object.\n line_join    - line join\n\n Line join can be one of following: FPDF_LINEJOIN_MITER, FPDF_LINEJOIN_ROUND,\n FPDF_LINEJOIN_BEVEL"]
    pub fn FPDFPageObj_SetLineJoin(
        page_object: FPDF_PAGEOBJECT,
        line_join: ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get the line cap of |page_object|.\n\n page_object - handle to a page object.\n\n Returns the line cap, or -1 on failure.\n Line cap can be one of following: FPDF_LINECAP_BUTT, FPDF_LINECAP_ROUND,\n FPDF_LINECAP_PROJECTING_SQUARE"]
    pub fn FPDFPageObj_GetLineCap(page_object: FPDF_PAGEOBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the line cap of |page_object|.\n\n page_object - handle to a page object.\n line_cap    - line cap\n\n Line cap can be one of following: FPDF_LINECAP_BUTT, FPDF_LINECAP_ROUND,\n FPDF_LINECAP_PROJECTING_SQUARE"]
    pub fn FPDFPageObj_SetLineCap(
        page_object: FPDF_PAGEOBJECT,
        line_cap: ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Set the fill RGBA of a page object. Range of values: 0 - 255.\n\n page_object  - the handle to the page object.\n R            - the red component for the object's fill color.\n G            - the green component for the object's fill color.\n B            - the blue component for the object's fill color.\n A            - the fill alpha for the object.\n\n Returns TRUE on success."]
    pub fn FPDFPageObj_SetFillColor(
        page_object: FPDF_PAGEOBJECT,
        R: ::std::os::raw::c_uint,
        G: ::std::os::raw::c_uint,
        B: ::std::os::raw::c_uint,
        A: ::std::os::raw::c_uint,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get the fill RGBA of a page object. Range of values: 0 - 255.\n\n page_object  - the handle to the page object.\n R            - the red component of the object's fill color.\n G            - the green component of the object's fill color.\n B            - the blue component of the object's fill color.\n A            - the fill alpha of the object.\n\n Returns TRUE on success."]
    pub fn FPDFPageObj_GetFillColor(
        page_object: FPDF_PAGEOBJECT,
        R: *mut ::std::os::raw::c_uint,
        G: *mut ::std::os::raw::c_uint,
        B: *mut ::std::os::raw::c_uint,
        A: *mut ::std::os::raw::c_uint,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the line dash |phase| of |page_object|.\n\n page_object - handle to a page object.\n phase - pointer where the dashing phase will be stored.\n\n Returns TRUE on success."]
    pub fn FPDFPageObj_GetDashPhase(page_object: FPDF_PAGEOBJECT, phase: *mut f32) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Set the line dash phase of |page_object|.\n\n page_object - handle to a page object.\n phase - line dash phase.\n\n Returns TRUE on success."]
    pub fn FPDFPageObj_SetDashPhase(page_object: FPDF_PAGEOBJECT, phase: f32) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the line dash array of |page_object|.\n\n page_object - handle to a page object.\n\n Returns the line dash array size or -1 on failure."]
    pub fn FPDFPageObj_GetDashCount(page_object: FPDF_PAGEOBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Get the line dash array of |page_object|.\n\n page_object - handle to a page object.\n dash_array - pointer where the dashing array will be stored.\n dash_count - number of elements in |dash_array|.\n\n Returns TRUE on success."]
    pub fn FPDFPageObj_GetDashArray(
        page_object: FPDF_PAGEOBJECT,
        dash_array: *mut f32,
        dash_count: usize,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Set the line dash array of |page_object|.\n\n page_object - handle to a page object.\n dash_array - the dash array.\n dash_count - number of elements in |dash_array|.\n phase - the line dash phase.\n\n Returns TRUE on success."]
    pub fn FPDFPageObj_SetDashArray(
        page_object: FPDF_PAGEOBJECT,
        dash_array: *const f32,
        dash_count: usize,
        phase: f32,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get number of segments inside |path|.\n\n   path - handle to a path.\n\n A segment is a command, created by e.g. FPDFPath_MoveTo(),\n FPDFPath_LineTo() or FPDFPath_BezierTo().\n\n Returns the number of objects in |path| or -1 on failure."]
    pub fn FPDFPath_CountSegments(path: FPDF_PAGEOBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get segment in |path| at |index|.\n\n   path  - handle to a path.\n   index - the index of a segment.\n\n Returns the handle to the segment, or NULL on faiure."]
    pub fn FPDFPath_GetPathSegment(
        path: FPDF_PAGEOBJECT,
        index: ::std::os::raw::c_int,
    ) -> FPDF_PATHSEGMENT;
}
extern "C" {
    #[doc = " Get coordinates of |segment|.\n\n   segment  - handle to a segment.\n   x      - the horizontal position of the segment.\n   y      - the vertical position of the segment.\n\n Returns TRUE on success, otherwise |x| and |y| is not set."]
    pub fn FPDFPathSegment_GetPoint(
        segment: FPDF_PATHSEGMENT,
        x: *mut f32,
        y: *mut f32,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get type of |segment|.\n\n   segment - handle to a segment.\n\n Returns one of the FPDF_SEGMENT_* values on success,\n FPDF_SEGMENT_UNKNOWN on error."]
    pub fn FPDFPathSegment_GetType(segment: FPDF_PATHSEGMENT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets if the |segment| closes the current subpath of a given path.\n\n   segment - handle to a segment.\n\n Returns close flag for non-NULL segment, FALSE otherwise."]
    pub fn FPDFPathSegment_GetClose(segment: FPDF_PATHSEGMENT) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Move a path's current point.\n\n path   - the handle to the path object.\n x      - the horizontal position of the new current point.\n y      - the vertical position of the new current point.\n\n Note that no line will be created between the previous current point and the\n new one.\n\n Returns TRUE on success"]
    pub fn FPDFPath_MoveTo(path: FPDF_PAGEOBJECT, x: f32, y: f32) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Add a line between the current point and a new point in the path.\n\n path   - the handle to the path object.\n x      - the horizontal position of the new point.\n y      - the vertical position of the new point.\n\n The path's current point is changed to (x, y).\n\n Returns TRUE on success"]
    pub fn FPDFPath_LineTo(path: FPDF_PAGEOBJECT, x: f32, y: f32) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Add a cubic Bezier curve to the given path, starting at the current point.\n\n path   - the handle to the path object.\n x1     - the horizontal position of the first Bezier control point.\n y1     - the vertical position of the first Bezier control point.\n x2     - the horizontal position of the second Bezier control point.\n y2     - the vertical position of the second Bezier control point.\n x3     - the horizontal position of the ending point of the Bezier curve.\n y3     - the vertical position of the ending point of the Bezier curve.\n\n Returns TRUE on success"]
    pub fn FPDFPath_BezierTo(
        path: FPDF_PAGEOBJECT,
        x1: f32,
        y1: f32,
        x2: f32,
        y2: f32,
        x3: f32,
        y3: f32,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Close the current subpath of a given path.\n\n path   - the handle to the path object.\n\n This will add a line between the current point and the initial point of the\n subpath, thus terminating the current subpath.\n\n Returns TRUE on success"]
    pub fn FPDFPath_Close(path: FPDF_PAGEOBJECT) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Set the drawing mode of a path.\n\n path     - the handle to the path object.\n fillmode - the filling mode to be set: one of the FPDF_FILLMODE_* flags.\n stroke   - a boolean specifying if the path should be stroked or not.\n\n Returns TRUE on success"]
    pub fn FPDFPath_SetDrawMode(
        path: FPDF_PAGEOBJECT,
        fillmode: ::std::os::raw::c_int,
        stroke: FPDF_BOOL,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get the drawing mode of a path.\n\n path     - the handle to the path object.\n fillmode - the filling mode of the path: one of the FPDF_FILLMODE_* flags.\n stroke   - a boolean specifying if the path is stroked or not.\n\n Returns TRUE on success"]
    pub fn FPDFPath_GetDrawMode(
        path: FPDF_PAGEOBJECT,
        fillmode: *mut ::std::os::raw::c_int,
        stroke: *mut FPDF_BOOL,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Create a new text object using one of the standard PDF fonts.\n\n document   - handle to the document.\n font       - string containing the font name, without spaces.\n font_size  - the font size for the new text object.\n\n Returns a handle to a new text object, or NULL on failure"]
    pub fn FPDFPageObj_NewTextObj(
        document: FPDF_DOCUMENT,
        font: FPDF_BYTESTRING,
        font_size: f32,
    ) -> FPDF_PAGEOBJECT;
}
extern "C" {
    #[doc = " Set the text for a text object. If it had text, it will be replaced.\n\n text_object  - handle to the text object.\n text         - the UTF-16LE encoded string containing the text to be added.\n\n Returns TRUE on success"]
    pub fn FPDFText_SetText(text_object: FPDF_PAGEOBJECT, text: FPDF_WIDESTRING) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Set the text using charcodes for a text object. If it had text, it will be\n replaced.\n\n text_object  - handle to the text object.\n charcodes    - pointer to an array of charcodes to be added.\n count        - number of elements in |charcodes|.\n\n Returns TRUE on success"]
    pub fn FPDFText_SetCharcodes(
        text_object: FPDF_PAGEOBJECT,
        charcodes: *const u32,
        count: usize,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Returns a font object loaded from a stream of data. The font is loaded\n into the document.\n\n document   - handle to the document.\n data       - the stream of data, which will be copied by the font object.\n size       - size of the stream, in bytes.\n font_type  - FPDF_FONT_TYPE1 or FPDF_FONT_TRUETYPE depending on the font\n type.\n cid        - a boolean specifying if the font is a CID font or not.\n\n The loaded font can be closed using FPDFFont_Close.\n\n Returns NULL on failure"]
    pub fn FPDFText_LoadFont(
        document: FPDF_DOCUMENT,
        data: *const u8,
        size: u32,
        font_type: ::std::os::raw::c_int,
        cid: FPDF_BOOL,
    ) -> FPDF_FONT;
}
extern "C" {
    #[doc = " Experimental API.\n Loads one of the standard 14 fonts per PDF spec 1.7 page 416. The preferred\n way of using font style is using a dash to separate the name from the style,\n for example 'Helvetica-BoldItalic'.\n\n document   - handle to the document.\n font       - string containing the font name, without spaces.\n\n The loaded font can be closed using FPDFFont_Close.\n\n Returns NULL on failure."]
    pub fn FPDFText_LoadStandardFont(document: FPDF_DOCUMENT, font: FPDF_BYTESTRING) -> FPDF_FONT;
}
extern "C" {
    #[doc = " Get the font size of a text object.\n\n   text - handle to a text.\n   size - pointer to the font size of the text object, measured in points\n   (about 1/72 inch)\n\n Returns TRUE on success."]
    pub fn FPDFTextObj_GetFontSize(text: FPDF_PAGEOBJECT, size: *mut f32) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Close a loaded PDF font.\n\n font   - Handle to the loaded font."]
    pub fn FPDFFont_Close(font: FPDF_FONT);
}
extern "C" {
    #[doc = " Create a new text object using a loaded font.\n\n document   - handle to the document.\n font       - handle to the font object.\n font_size  - the font size for the new text object.\n\n Returns a handle to a new text object, or NULL on failure"]
    pub fn FPDFPageObj_CreateTextObj(
        document: FPDF_DOCUMENT,
        font: FPDF_FONT,
        font_size: f32,
    ) -> FPDF_PAGEOBJECT;
}
extern "C" {
    #[doc = " Get the text rendering mode of a text object.\n\n text     - the handle to the text object.\n\n Returns one of the known FPDF_TEXT_RENDERMODE enum values on success,\n FPDF_TEXTRENDERMODE_UNKNOWN on error."]
    pub fn FPDFTextObj_GetTextRenderMode(text: FPDF_PAGEOBJECT) -> FPDF_TEXT_RENDERMODE;
}
extern "C" {
    #[doc = " Experimental API.\n Set the text rendering mode of a text object.\n\n text         - the handle to the text object.\n render_mode  - the FPDF_TEXT_RENDERMODE enum value to be set (cannot set to\n                FPDF_TEXTRENDERMODE_UNKNOWN).\n\n Returns TRUE on success."]
    pub fn FPDFTextObj_SetTextRenderMode(
        text: FPDF_PAGEOBJECT,
        render_mode: FPDF_TEXT_RENDERMODE,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get the text of a text object.\n\n text_object      - the handle to the text object.\n text_page        - the handle to the text page.\n buffer           - the address of a buffer that receives the text.\n length           - the size, in bytes, of |buffer|.\n\n Returns the number of bytes in the text (including the trailing NUL\n character) on success, 0 on error.\n\n Regardless of the platform, the |buffer| is always in UTF-16LE encoding.\n If |length| is less than the returned length, or |buffer| is NULL, |buffer|\n will not be modified."]
    pub fn FPDFTextObj_GetText(
        text_object: FPDF_PAGEOBJECT,
        text_page: FPDF_TEXTPAGE,
        buffer: *mut FPDF_WCHAR,
        length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Get the font of a text object.\n\n text - the handle to the text object.\n\n Returns a handle to the font object held by |text| which retains ownership."]
    pub fn FPDFTextObj_GetFont(text: FPDF_PAGEOBJECT) -> FPDF_FONT;
}
extern "C" {
    #[doc = " Experimental API.\n Get the font name of a font.\n\n font   - the handle to the font object.\n buffer - the address of a buffer that receives the font name.\n length - the size, in bytes, of |buffer|.\n\n Returns the number of bytes in the font name (including the trailing NUL\n character) on success, 0 on error.\n\n Regardless of the platform, the |buffer| is always in UTF-8 encoding.\n If |length| is less than the returned length, or |buffer| is NULL, |buffer|\n will not be modified."]
    pub fn FPDFFont_GetFontName(
        font: FPDF_FONT,
        buffer: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Get the descriptor flags of a font.\n\n font - the handle to the font object.\n\n Returns the bit flags specifying various characteristics of the font as\n defined in ISO 32000-1:2008, table 123, -1 on failure."]
    pub fn FPDFFont_GetFlags(font: FPDF_FONT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Get the font weight of a font.\n\n font - the handle to the font object.\n\n Returns the font weight, -1 on failure.\n Typical values are 400 (normal) and 700 (bold)."]
    pub fn FPDFFont_GetWeight(font: FPDF_FONT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Get the italic angle of a font.\n\n font  - the handle to the font object.\n angle - pointer where the italic angle will be stored\n\n The italic angle of a |font| is defined as degrees counterclockwise\n from vertical. For a font that slopes to the right, this will be negative.\n\n Returns TRUE on success; |angle| unmodified on failure."]
    pub fn FPDFFont_GetItalicAngle(font: FPDF_FONT, angle: *mut ::std::os::raw::c_int)
        -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get ascent distance of a font.\n\n font       - the handle to the font object.\n font_size  - the size of the |font|.\n ascent     - pointer where the font ascent will be stored\n\n Ascent is the maximum distance in points above the baseline reached by the\n glyphs of the |font|. One point is 1/72 inch (around 0.3528 mm).\n\n Returns TRUE on success; |ascent| unmodified on failure."]
    pub fn FPDFFont_GetAscent(font: FPDF_FONT, font_size: f32, ascent: *mut f32) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get descent distance of a font.\n\n font       - the handle to the font object.\n font_size  - the size of the |font|.\n descent    - pointer where the font descent will be stored\n\n Descent is the maximum distance in points below the baseline reached by the\n glyphs of the |font|. One point is 1/72 inch (around 0.3528 mm).\n\n Returns TRUE on success; |descent| unmodified on failure."]
    pub fn FPDFFont_GetDescent(font: FPDF_FONT, font_size: f32, descent: *mut f32) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the width of a glyph in a font.\n\n font       - the handle to the font object.\n glyph      - the glyph.\n font_size  - the size of the font.\n width      - pointer where the glyph width will be stored\n\n Glyph width is the distance from the end of the prior glyph to the next\n glyph. This will be the vertical distance for vertical writing.\n\n Returns TRUE on success; |width| unmodified on failure."]
    pub fn FPDFFont_GetGlyphWidth(
        font: FPDF_FONT,
        glyph: u32,
        font_size: f32,
        width: *mut f32,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Get the glyphpath describing how to draw a font glyph.\n\n font       - the handle to the font object.\n glyph      - the glyph being drawn.\n font_size  - the size of the font.\n\n Returns the handle to the segment, or NULL on faiure."]
    pub fn FPDFFont_GetGlyphPath(font: FPDF_FONT, glyph: u32, font_size: f32) -> FPDF_GLYPHPATH;
}
extern "C" {
    #[doc = " Experimental API.\n Get number of segments inside glyphpath.\n\n glyphpath - handle to a glyph path.\n\n Returns the number of objects in |glyphpath| or -1 on failure."]
    pub fn FPDFGlyphPath_CountGlyphSegments(glyphpath: FPDF_GLYPHPATH) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Get segment in glyphpath at index.\n\n glyphpath  - handle to a glyph path.\n index      - the index of a segment.\n\n Returns the handle to the segment, or NULL on faiure."]
    pub fn FPDFGlyphPath_GetGlyphPathSegment(
        glyphpath: FPDF_GLYPHPATH,
        index: ::std::os::raw::c_int,
    ) -> FPDF_PATHSEGMENT;
}
extern "C" {
    #[doc = " Get number of page objects inside |form_object|.\n\n   form_object - handle to a form object.\n\n Returns the number of objects in |form_object| on success, -1 on error."]
    pub fn FPDFFormObj_CountObjects(form_object: FPDF_PAGEOBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get page object in |form_object| at |index|.\n\n   form_object - handle to a form object.\n   index       - the 0-based index of a page object.\n\n Returns the handle to the page object, or NULL on error."]
    pub fn FPDFFormObj_GetObject(
        form_object: FPDF_PAGEOBJECT,
        index: ::std::os::raw::c_ulong,
    ) -> FPDF_PAGEOBJECT;
}
#[doc = " Interface for unsupported feature notifications."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNSUPPORT_INFO {
    #[doc = " Version number of the interface. Must be 1."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Unsupported object notification function.\n Interface Version: 1\n Implementation Required: Yes\n\n   pThis - pointer to the interface structure.\n   nType - the type of unsupported object. One of the |FPDF_UNSP_*| entries."]
    pub FSDK_UnSupport_Handler: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _UNSUPPORT_INFO, nType: ::std::os::raw::c_int),
    >,
}
#[test]
fn bindgen_test_layout__UNSUPPORT_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<_UNSUPPORT_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_UNSUPPORT_INFO>(),
        16usize,
        concat!("Size of: ", stringify!(_UNSUPPORT_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_UNSUPPORT_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(_UNSUPPORT_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNSUPPORT_INFO),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FSDK_UnSupport_Handler) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNSUPPORT_INFO),
            "::",
            stringify!(FSDK_UnSupport_Handler)
        )
    );
}
#[doc = " Interface for unsupported feature notifications."]
pub type UNSUPPORT_INFO = _UNSUPPORT_INFO;
extern "C" {
    #[doc = " Setup an unsupported object handler.\n\n   unsp_info - Pointer to an UNSUPPORT_INFO structure.\n\n Returns TRUE on success."]
    pub fn FSDK_SetUnSpObjProcessHandler(unsp_info: *mut UNSUPPORT_INFO) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get the document's PageMode.\n\n   doc - Handle to document.\n\n Returns one of the |PAGEMODE_*| flags defined above.\n\n The page mode defines how the document should be initially displayed."]
    pub fn FPDFDoc_GetPageMode(document: FPDF_DOCUMENT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Flatten annotations and form fields into the page contents.\n\n   page  - handle to the page.\n   nFlag - One of the |FLAT_*| values denoting the page usage.\n\n Returns one of the |FLATTEN_*| values.\n\n Currently, all failures return |FLATTEN_FAIL| with no indication of the\n cause."]
    pub fn FPDFPage_Flatten(page: FPDF_PAGE, nFlag: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub const FWL_EVENTFLAG_FWL_EVENTFLAG_ShiftKey: FWL_EVENTFLAG = 1;
pub const FWL_EVENTFLAG_FWL_EVENTFLAG_ControlKey: FWL_EVENTFLAG = 2;
pub const FWL_EVENTFLAG_FWL_EVENTFLAG_AltKey: FWL_EVENTFLAG = 4;
pub const FWL_EVENTFLAG_FWL_EVENTFLAG_MetaKey: FWL_EVENTFLAG = 8;
pub const FWL_EVENTFLAG_FWL_EVENTFLAG_KeyPad: FWL_EVENTFLAG = 16;
pub const FWL_EVENTFLAG_FWL_EVENTFLAG_AutoRepeat: FWL_EVENTFLAG = 32;
pub const FWL_EVENTFLAG_FWL_EVENTFLAG_LeftButtonDown: FWL_EVENTFLAG = 64;
pub const FWL_EVENTFLAG_FWL_EVENTFLAG_MiddleButtonDown: FWL_EVENTFLAG = 128;
pub const FWL_EVENTFLAG_FWL_EVENTFLAG_RightButtonDown: FWL_EVENTFLAG = 256;
#[doc = " Key flags."]
pub type FWL_EVENTFLAG = ::std::os::raw::c_uint;
pub const FWL_VKEYCODE_FWL_VKEY_Back: FWL_VKEYCODE = 8;
pub const FWL_VKEYCODE_FWL_VKEY_Tab: FWL_VKEYCODE = 9;
pub const FWL_VKEYCODE_FWL_VKEY_NewLine: FWL_VKEYCODE = 10;
pub const FWL_VKEYCODE_FWL_VKEY_Clear: FWL_VKEYCODE = 12;
pub const FWL_VKEYCODE_FWL_VKEY_Return: FWL_VKEYCODE = 13;
pub const FWL_VKEYCODE_FWL_VKEY_Shift: FWL_VKEYCODE = 16;
pub const FWL_VKEYCODE_FWL_VKEY_Control: FWL_VKEYCODE = 17;
pub const FWL_VKEYCODE_FWL_VKEY_Menu: FWL_VKEYCODE = 18;
pub const FWL_VKEYCODE_FWL_VKEY_Pause: FWL_VKEYCODE = 19;
pub const FWL_VKEYCODE_FWL_VKEY_Capital: FWL_VKEYCODE = 20;
pub const FWL_VKEYCODE_FWL_VKEY_Kana: FWL_VKEYCODE = 21;
pub const FWL_VKEYCODE_FWL_VKEY_Hangul: FWL_VKEYCODE = 21;
pub const FWL_VKEYCODE_FWL_VKEY_Junja: FWL_VKEYCODE = 23;
pub const FWL_VKEYCODE_FWL_VKEY_Final: FWL_VKEYCODE = 24;
pub const FWL_VKEYCODE_FWL_VKEY_Hanja: FWL_VKEYCODE = 25;
pub const FWL_VKEYCODE_FWL_VKEY_Kanji: FWL_VKEYCODE = 25;
pub const FWL_VKEYCODE_FWL_VKEY_Escape: FWL_VKEYCODE = 27;
pub const FWL_VKEYCODE_FWL_VKEY_Convert: FWL_VKEYCODE = 28;
pub const FWL_VKEYCODE_FWL_VKEY_NonConvert: FWL_VKEYCODE = 29;
pub const FWL_VKEYCODE_FWL_VKEY_Accept: FWL_VKEYCODE = 30;
pub const FWL_VKEYCODE_FWL_VKEY_ModeChange: FWL_VKEYCODE = 31;
pub const FWL_VKEYCODE_FWL_VKEY_Space: FWL_VKEYCODE = 32;
pub const FWL_VKEYCODE_FWL_VKEY_Prior: FWL_VKEYCODE = 33;
pub const FWL_VKEYCODE_FWL_VKEY_Next: FWL_VKEYCODE = 34;
pub const FWL_VKEYCODE_FWL_VKEY_End: FWL_VKEYCODE = 35;
pub const FWL_VKEYCODE_FWL_VKEY_Home: FWL_VKEYCODE = 36;
pub const FWL_VKEYCODE_FWL_VKEY_Left: FWL_VKEYCODE = 37;
pub const FWL_VKEYCODE_FWL_VKEY_Up: FWL_VKEYCODE = 38;
pub const FWL_VKEYCODE_FWL_VKEY_Right: FWL_VKEYCODE = 39;
pub const FWL_VKEYCODE_FWL_VKEY_Down: FWL_VKEYCODE = 40;
pub const FWL_VKEYCODE_FWL_VKEY_Select: FWL_VKEYCODE = 41;
pub const FWL_VKEYCODE_FWL_VKEY_Print: FWL_VKEYCODE = 42;
pub const FWL_VKEYCODE_FWL_VKEY_Execute: FWL_VKEYCODE = 43;
pub const FWL_VKEYCODE_FWL_VKEY_Snapshot: FWL_VKEYCODE = 44;
pub const FWL_VKEYCODE_FWL_VKEY_Insert: FWL_VKEYCODE = 45;
pub const FWL_VKEYCODE_FWL_VKEY_Delete: FWL_VKEYCODE = 46;
pub const FWL_VKEYCODE_FWL_VKEY_Help: FWL_VKEYCODE = 47;
pub const FWL_VKEYCODE_FWL_VKEY_0: FWL_VKEYCODE = 48;
pub const FWL_VKEYCODE_FWL_VKEY_1: FWL_VKEYCODE = 49;
pub const FWL_VKEYCODE_FWL_VKEY_2: FWL_VKEYCODE = 50;
pub const FWL_VKEYCODE_FWL_VKEY_3: FWL_VKEYCODE = 51;
pub const FWL_VKEYCODE_FWL_VKEY_4: FWL_VKEYCODE = 52;
pub const FWL_VKEYCODE_FWL_VKEY_5: FWL_VKEYCODE = 53;
pub const FWL_VKEYCODE_FWL_VKEY_6: FWL_VKEYCODE = 54;
pub const FWL_VKEYCODE_FWL_VKEY_7: FWL_VKEYCODE = 55;
pub const FWL_VKEYCODE_FWL_VKEY_8: FWL_VKEYCODE = 56;
pub const FWL_VKEYCODE_FWL_VKEY_9: FWL_VKEYCODE = 57;
pub const FWL_VKEYCODE_FWL_VKEY_A: FWL_VKEYCODE = 65;
pub const FWL_VKEYCODE_FWL_VKEY_B: FWL_VKEYCODE = 66;
pub const FWL_VKEYCODE_FWL_VKEY_C: FWL_VKEYCODE = 67;
pub const FWL_VKEYCODE_FWL_VKEY_D: FWL_VKEYCODE = 68;
pub const FWL_VKEYCODE_FWL_VKEY_E: FWL_VKEYCODE = 69;
pub const FWL_VKEYCODE_FWL_VKEY_F: FWL_VKEYCODE = 70;
pub const FWL_VKEYCODE_FWL_VKEY_G: FWL_VKEYCODE = 71;
pub const FWL_VKEYCODE_FWL_VKEY_H: FWL_VKEYCODE = 72;
pub const FWL_VKEYCODE_FWL_VKEY_I: FWL_VKEYCODE = 73;
pub const FWL_VKEYCODE_FWL_VKEY_J: FWL_VKEYCODE = 74;
pub const FWL_VKEYCODE_FWL_VKEY_K: FWL_VKEYCODE = 75;
pub const FWL_VKEYCODE_FWL_VKEY_L: FWL_VKEYCODE = 76;
pub const FWL_VKEYCODE_FWL_VKEY_M: FWL_VKEYCODE = 77;
pub const FWL_VKEYCODE_FWL_VKEY_N: FWL_VKEYCODE = 78;
pub const FWL_VKEYCODE_FWL_VKEY_O: FWL_VKEYCODE = 79;
pub const FWL_VKEYCODE_FWL_VKEY_P: FWL_VKEYCODE = 80;
pub const FWL_VKEYCODE_FWL_VKEY_Q: FWL_VKEYCODE = 81;
pub const FWL_VKEYCODE_FWL_VKEY_R: FWL_VKEYCODE = 82;
pub const FWL_VKEYCODE_FWL_VKEY_S: FWL_VKEYCODE = 83;
pub const FWL_VKEYCODE_FWL_VKEY_T: FWL_VKEYCODE = 84;
pub const FWL_VKEYCODE_FWL_VKEY_U: FWL_VKEYCODE = 85;
pub const FWL_VKEYCODE_FWL_VKEY_V: FWL_VKEYCODE = 86;
pub const FWL_VKEYCODE_FWL_VKEY_W: FWL_VKEYCODE = 87;
pub const FWL_VKEYCODE_FWL_VKEY_X: FWL_VKEYCODE = 88;
pub const FWL_VKEYCODE_FWL_VKEY_Y: FWL_VKEYCODE = 89;
pub const FWL_VKEYCODE_FWL_VKEY_Z: FWL_VKEYCODE = 90;
pub const FWL_VKEYCODE_FWL_VKEY_LWin: FWL_VKEYCODE = 91;
pub const FWL_VKEYCODE_FWL_VKEY_Command: FWL_VKEYCODE = 91;
pub const FWL_VKEYCODE_FWL_VKEY_RWin: FWL_VKEYCODE = 92;
pub const FWL_VKEYCODE_FWL_VKEY_Apps: FWL_VKEYCODE = 93;
pub const FWL_VKEYCODE_FWL_VKEY_Sleep: FWL_VKEYCODE = 95;
pub const FWL_VKEYCODE_FWL_VKEY_NumPad0: FWL_VKEYCODE = 96;
pub const FWL_VKEYCODE_FWL_VKEY_NumPad1: FWL_VKEYCODE = 97;
pub const FWL_VKEYCODE_FWL_VKEY_NumPad2: FWL_VKEYCODE = 98;
pub const FWL_VKEYCODE_FWL_VKEY_NumPad3: FWL_VKEYCODE = 99;
pub const FWL_VKEYCODE_FWL_VKEY_NumPad4: FWL_VKEYCODE = 100;
pub const FWL_VKEYCODE_FWL_VKEY_NumPad5: FWL_VKEYCODE = 101;
pub const FWL_VKEYCODE_FWL_VKEY_NumPad6: FWL_VKEYCODE = 102;
pub const FWL_VKEYCODE_FWL_VKEY_NumPad7: FWL_VKEYCODE = 103;
pub const FWL_VKEYCODE_FWL_VKEY_NumPad8: FWL_VKEYCODE = 104;
pub const FWL_VKEYCODE_FWL_VKEY_NumPad9: FWL_VKEYCODE = 105;
pub const FWL_VKEYCODE_FWL_VKEY_Multiply: FWL_VKEYCODE = 106;
pub const FWL_VKEYCODE_FWL_VKEY_Add: FWL_VKEYCODE = 107;
pub const FWL_VKEYCODE_FWL_VKEY_Separator: FWL_VKEYCODE = 108;
pub const FWL_VKEYCODE_FWL_VKEY_Subtract: FWL_VKEYCODE = 109;
pub const FWL_VKEYCODE_FWL_VKEY_Decimal: FWL_VKEYCODE = 110;
pub const FWL_VKEYCODE_FWL_VKEY_Divide: FWL_VKEYCODE = 111;
pub const FWL_VKEYCODE_FWL_VKEY_F1: FWL_VKEYCODE = 112;
pub const FWL_VKEYCODE_FWL_VKEY_F2: FWL_VKEYCODE = 113;
pub const FWL_VKEYCODE_FWL_VKEY_F3: FWL_VKEYCODE = 114;
pub const FWL_VKEYCODE_FWL_VKEY_F4: FWL_VKEYCODE = 115;
pub const FWL_VKEYCODE_FWL_VKEY_F5: FWL_VKEYCODE = 116;
pub const FWL_VKEYCODE_FWL_VKEY_F6: FWL_VKEYCODE = 117;
pub const FWL_VKEYCODE_FWL_VKEY_F7: FWL_VKEYCODE = 118;
pub const FWL_VKEYCODE_FWL_VKEY_F8: FWL_VKEYCODE = 119;
pub const FWL_VKEYCODE_FWL_VKEY_F9: FWL_VKEYCODE = 120;
pub const FWL_VKEYCODE_FWL_VKEY_F10: FWL_VKEYCODE = 121;
pub const FWL_VKEYCODE_FWL_VKEY_F11: FWL_VKEYCODE = 122;
pub const FWL_VKEYCODE_FWL_VKEY_F12: FWL_VKEYCODE = 123;
pub const FWL_VKEYCODE_FWL_VKEY_F13: FWL_VKEYCODE = 124;
pub const FWL_VKEYCODE_FWL_VKEY_F14: FWL_VKEYCODE = 125;
pub const FWL_VKEYCODE_FWL_VKEY_F15: FWL_VKEYCODE = 126;
pub const FWL_VKEYCODE_FWL_VKEY_F16: FWL_VKEYCODE = 127;
pub const FWL_VKEYCODE_FWL_VKEY_F17: FWL_VKEYCODE = 128;
pub const FWL_VKEYCODE_FWL_VKEY_F18: FWL_VKEYCODE = 129;
pub const FWL_VKEYCODE_FWL_VKEY_F19: FWL_VKEYCODE = 130;
pub const FWL_VKEYCODE_FWL_VKEY_F20: FWL_VKEYCODE = 131;
pub const FWL_VKEYCODE_FWL_VKEY_F21: FWL_VKEYCODE = 132;
pub const FWL_VKEYCODE_FWL_VKEY_F22: FWL_VKEYCODE = 133;
pub const FWL_VKEYCODE_FWL_VKEY_F23: FWL_VKEYCODE = 134;
pub const FWL_VKEYCODE_FWL_VKEY_F24: FWL_VKEYCODE = 135;
pub const FWL_VKEYCODE_FWL_VKEY_NunLock: FWL_VKEYCODE = 144;
pub const FWL_VKEYCODE_FWL_VKEY_Scroll: FWL_VKEYCODE = 145;
pub const FWL_VKEYCODE_FWL_VKEY_LShift: FWL_VKEYCODE = 160;
pub const FWL_VKEYCODE_FWL_VKEY_RShift: FWL_VKEYCODE = 161;
pub const FWL_VKEYCODE_FWL_VKEY_LControl: FWL_VKEYCODE = 162;
pub const FWL_VKEYCODE_FWL_VKEY_RControl: FWL_VKEYCODE = 163;
pub const FWL_VKEYCODE_FWL_VKEY_LMenu: FWL_VKEYCODE = 164;
pub const FWL_VKEYCODE_FWL_VKEY_RMenu: FWL_VKEYCODE = 165;
pub const FWL_VKEYCODE_FWL_VKEY_BROWSER_Back: FWL_VKEYCODE = 166;
pub const FWL_VKEYCODE_FWL_VKEY_BROWSER_Forward: FWL_VKEYCODE = 167;
pub const FWL_VKEYCODE_FWL_VKEY_BROWSER_Refresh: FWL_VKEYCODE = 168;
pub const FWL_VKEYCODE_FWL_VKEY_BROWSER_Stop: FWL_VKEYCODE = 169;
pub const FWL_VKEYCODE_FWL_VKEY_BROWSER_Search: FWL_VKEYCODE = 170;
pub const FWL_VKEYCODE_FWL_VKEY_BROWSER_Favorites: FWL_VKEYCODE = 171;
pub const FWL_VKEYCODE_FWL_VKEY_BROWSER_Home: FWL_VKEYCODE = 172;
pub const FWL_VKEYCODE_FWL_VKEY_VOLUME_Mute: FWL_VKEYCODE = 173;
pub const FWL_VKEYCODE_FWL_VKEY_VOLUME_Down: FWL_VKEYCODE = 174;
pub const FWL_VKEYCODE_FWL_VKEY_VOLUME_Up: FWL_VKEYCODE = 175;
pub const FWL_VKEYCODE_FWL_VKEY_MEDIA_NEXT_Track: FWL_VKEYCODE = 176;
pub const FWL_VKEYCODE_FWL_VKEY_MEDIA_PREV_Track: FWL_VKEYCODE = 177;
pub const FWL_VKEYCODE_FWL_VKEY_MEDIA_Stop: FWL_VKEYCODE = 178;
pub const FWL_VKEYCODE_FWL_VKEY_MEDIA_PLAY_Pause: FWL_VKEYCODE = 179;
pub const FWL_VKEYCODE_FWL_VKEY_MEDIA_LAUNCH_Mail: FWL_VKEYCODE = 180;
pub const FWL_VKEYCODE_FWL_VKEY_MEDIA_LAUNCH_MEDIA_Select: FWL_VKEYCODE = 181;
pub const FWL_VKEYCODE_FWL_VKEY_MEDIA_LAUNCH_APP1: FWL_VKEYCODE = 182;
pub const FWL_VKEYCODE_FWL_VKEY_MEDIA_LAUNCH_APP2: FWL_VKEYCODE = 183;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_1: FWL_VKEYCODE = 186;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_Plus: FWL_VKEYCODE = 187;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_Comma: FWL_VKEYCODE = 188;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_Minus: FWL_VKEYCODE = 189;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_Period: FWL_VKEYCODE = 190;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_2: FWL_VKEYCODE = 191;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_3: FWL_VKEYCODE = 192;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_4: FWL_VKEYCODE = 219;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_5: FWL_VKEYCODE = 220;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_6: FWL_VKEYCODE = 221;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_7: FWL_VKEYCODE = 222;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_8: FWL_VKEYCODE = 223;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_102: FWL_VKEYCODE = 226;
pub const FWL_VKEYCODE_FWL_VKEY_ProcessKey: FWL_VKEYCODE = 229;
pub const FWL_VKEYCODE_FWL_VKEY_Packet: FWL_VKEYCODE = 231;
pub const FWL_VKEYCODE_FWL_VKEY_Attn: FWL_VKEYCODE = 246;
pub const FWL_VKEYCODE_FWL_VKEY_Crsel: FWL_VKEYCODE = 247;
pub const FWL_VKEYCODE_FWL_VKEY_Exsel: FWL_VKEYCODE = 248;
pub const FWL_VKEYCODE_FWL_VKEY_Ereof: FWL_VKEYCODE = 249;
pub const FWL_VKEYCODE_FWL_VKEY_Play: FWL_VKEYCODE = 250;
pub const FWL_VKEYCODE_FWL_VKEY_Zoom: FWL_VKEYCODE = 251;
pub const FWL_VKEYCODE_FWL_VKEY_NoName: FWL_VKEYCODE = 252;
pub const FWL_VKEYCODE_FWL_VKEY_PA1: FWL_VKEYCODE = 253;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_Clear: FWL_VKEYCODE = 254;
pub const FWL_VKEYCODE_FWL_VKEY_Unknown: FWL_VKEYCODE = 0;
#[doc = " Virtual keycodes."]
pub type FWL_VKEYCODE = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Experimental API.\n Get the number of JavaScript actions in |document|.\n\n   document - handle to a document.\n\n Returns the number of JavaScript actions in |document| or -1 on error."]
    pub fn FPDFDoc_GetJavaScriptActionCount(document: FPDF_DOCUMENT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Get the JavaScript action at |index| in |document|.\n\n   document - handle to a document.\n   index    - the index of the requested JavaScript action.\n\n Returns the handle to the JavaScript action, or NULL on failure.\n Caller owns the returned handle and must close it with\n FPDFDoc_CloseJavaScriptAction()."]
    pub fn FPDFDoc_GetJavaScriptAction(
        document: FPDF_DOCUMENT,
        index: ::std::os::raw::c_int,
    ) -> FPDF_JAVASCRIPT_ACTION;
}
extern "C" {
    #[doc = "   javascript - Handle to a JavaScript action."]
    pub fn FPDFDoc_CloseJavaScriptAction(javascript: FPDF_JAVASCRIPT_ACTION);
}
extern "C" {
    #[doc = " Experimental API.\n Get the name from the |javascript| handle. |buffer| is only modified if\n |buflen| is longer than the length of the name. On errors, |buffer| is\n unmodified and the returned length is 0.\n\n   javascript - handle to an JavaScript action.\n   buffer     - buffer for holding the name, encoded in UTF-16LE.\n   buflen     - length of the buffer in bytes.\n\n Returns the length of the JavaScript action name in bytes."]
    pub fn FPDFJavaScriptAction_GetName(
        javascript: FPDF_JAVASCRIPT_ACTION,
        buffer: *mut FPDF_WCHAR,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Get the script from the |javascript| handle. |buffer| is only modified if\n |buflen| is longer than the length of the script. On errors, |buffer| is\n unmodified and the returned length is 0.\n\n   javascript - handle to an JavaScript action.\n   buffer     - buffer for holding the name, encoded in UTF-16LE.\n   buflen     - length of the buffer in bytes.\n\n Returns the length of the JavaScript action name in bytes."]
    pub fn FPDFJavaScriptAction_GetScript(
        javascript: FPDF_JAVASCRIPT_ACTION,
        buffer: *mut FPDF_WCHAR,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Import pages to a FPDF_DOCUMENT.\n\n   dest_doc     - The destination document for the pages.\n   src_doc      - The document to be imported.\n   page_indices - An array of page indices to be imported. The first page is\n                  zero. If |page_indices| is NULL, all pages from |src_doc|\n                  are imported.\n   length       - The length of the |page_indices| array.\n   index        - The page index at which to insert the first imported page\n                  into |dest_doc|. The first page is zero.\n\n Returns TRUE on success. Returns FALSE if any pages in |page_indices| is\n invalid."]
    pub fn FPDF_ImportPagesByIndex(
        dest_doc: FPDF_DOCUMENT,
        src_doc: FPDF_DOCUMENT,
        page_indices: *const ::std::os::raw::c_int,
        length: ::std::os::raw::c_ulong,
        index: ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Import pages to a FPDF_DOCUMENT.\n\n   dest_doc  - The destination document for the pages.\n   src_doc   - The document to be imported.\n   pagerange - A page range string, Such as \"1,3,5-7\". The first page is one.\n               If |pagerange| is NULL, all pages from |src_doc| are imported.\n   index     - The page index at which to insert the first imported page into\n               |dest_doc|. The first page is zero.\n\n Returns TRUE on success. Returns FALSE if any pages in |pagerange| is\n invalid or if |pagerange| cannot be read."]
    pub fn FPDF_ImportPages(
        dest_doc: FPDF_DOCUMENT,
        src_doc: FPDF_DOCUMENT,
        pagerange: FPDF_BYTESTRING,
        index: ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Create a new document from |src_doc|.  The pages of |src_doc| will be\n combined to provide |num_pages_on_x_axis x num_pages_on_y_axis| pages per\n |output_doc| page.\n\n   src_doc             - The document to be imported.\n   output_width        - The output page width in PDF \"user space\" units.\n   output_height       - The output page height in PDF \"user space\" units.\n   num_pages_on_x_axis - The number of pages on X Axis.\n   num_pages_on_y_axis - The number of pages on Y Axis.\n\n Return value:\n   A handle to the created document, or NULL on failure.\n\n Comments:\n   number of pages per page = num_pages_on_x_axis * num_pages_on_y_axis\n"]
    pub fn FPDF_ImportNPagesToOne(
        src_doc: FPDF_DOCUMENT,
        output_width: f32,
        output_height: f32,
        num_pages_on_x_axis: usize,
        num_pages_on_y_axis: usize,
    ) -> FPDF_DOCUMENT;
}
extern "C" {
    #[doc = " Experimental API.\n Create a template to generate form xobjects from |src_doc|'s page at\n |src_page_index|, for use in |dest_doc|.\n\n Returns a handle on success, or NULL on failure. Caller owns the newly\n created object."]
    pub fn FPDF_NewXObjectFromPage(
        dest_doc: FPDF_DOCUMENT,
        src_doc: FPDF_DOCUMENT,
        src_page_index: ::std::os::raw::c_int,
    ) -> FPDF_XOBJECT;
}
extern "C" {
    #[doc = " Experimental API.\n Close an FPDF_XOBJECT handle created by FPDF_NewXObjectFromPage().\n FPDF_PAGEOBJECTs created from the FPDF_XOBJECT handle are not affected."]
    pub fn FPDF_CloseXObject(xobject: FPDF_XOBJECT);
}
extern "C" {
    #[doc = " Experimental API.\n Create a new form object from an FPDF_XOBJECT object.\n\n Returns a new form object on success, or NULL on failure. Caller owns the\n newly created object."]
    pub fn FPDF_NewFormObjectFromXObject(xobject: FPDF_XOBJECT) -> FPDF_PAGEOBJECT;
}
extern "C" {
    #[doc = " Copy the viewer preferences from |src_doc| into |dest_doc|.\n\n   dest_doc - Document to write the viewer preferences into.\n   src_doc  - Document to read the viewer preferences from.\n\n Returns TRUE on success."]
    pub fn FPDF_CopyViewerPreferences(dest_doc: FPDF_DOCUMENT, src_doc: FPDF_DOCUMENT)
        -> FPDF_BOOL;
}
#[doc = " IFPDF_RENDERINFO interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IFSDK_PAUSE {
    #[doc = " Version number of the interface. Currently must be 1."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Method: NeedToPauseNow\n           Check if we need to pause a progressive process now.\n Interface Version:\n           1\n Implementation Required:\n           yes\n Parameters:\n           pThis       -   Pointer to the interface structure itself\n Return Value:\n           Non-zero for pause now, 0 for continue."]
    pub NeedToPauseNow:
        ::std::option::Option<unsafe extern "C" fn(pThis: *mut _IFSDK_PAUSE) -> FPDF_BOOL>,
    #[doc = " A user defined data pointer, used by user's application. Can be NULL."]
    pub user: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__IFSDK_PAUSE() {
    const UNINIT: ::std::mem::MaybeUninit<_IFSDK_PAUSE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IFSDK_PAUSE>(),
        24usize,
        concat!("Size of: ", stringify!(_IFSDK_PAUSE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IFSDK_PAUSE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IFSDK_PAUSE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IFSDK_PAUSE),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NeedToPauseNow) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IFSDK_PAUSE),
            "::",
            stringify!(NeedToPauseNow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IFSDK_PAUSE),
            "::",
            stringify!(user)
        )
    );
}
#[doc = " IFPDF_RENDERINFO interface."]
pub type IFSDK_PAUSE = _IFSDK_PAUSE;
extern "C" {
    #[doc = " Experimental API.\n Function: FPDF_RenderPageBitmapWithColorScheme_Start\n          Start to render page contents to a device independent bitmap\n          progressively with a specified color scheme for the content.\n Parameters:\n          bitmap       -   Handle to the device independent bitmap (as the\n                           output buffer). Bitmap handle can be created by\n                           FPDFBitmap_Create function.\n          page         -   Handle to the page as returned by FPDF_LoadPage\n                           function.\n          start_x      -   Left pixel position of the display area in the\n                           bitmap coordinate.\n          start_y      -   Top pixel position of the display area in the\n                           bitmap coordinate.\n          size_x       -   Horizontal size (in pixels) for displaying the\n                           page.\n          size_y       -   Vertical size (in pixels) for displaying the page.\n          rotate       -   Page orientation: 0 (normal), 1 (rotated 90\n                           degrees clockwise), 2 (rotated 180 degrees),\n                           3 (rotated 90 degrees counter-clockwise).\n          flags        -   0 for normal display, or combination of flags\n                           defined in fpdfview.h. With FPDF_ANNOT flag, it\n                           renders all annotations that does not require\n                           user-interaction, which are all annotations except\n                           widget and popup annotations.\n          color_scheme -   Color scheme to be used in rendering the |page|.\n                           If null, this function will work similar to\n                           FPDF_RenderPageBitmap_Start().\n          pause        -   The IFSDK_PAUSE interface. A callback mechanism\n                           allowing the page rendering process.\n Return value:\n          Rendering Status. See flags for progressive process status for the\n          details."]
    pub fn FPDF_RenderPageBitmapWithColorScheme_Start(
        bitmap: FPDF_BITMAP,
        page: FPDF_PAGE,
        start_x: ::std::os::raw::c_int,
        start_y: ::std::os::raw::c_int,
        size_x: ::std::os::raw::c_int,
        size_y: ::std::os::raw::c_int,
        rotate: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        color_scheme: *const FPDF_COLORSCHEME,
        pause: *mut IFSDK_PAUSE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDF_RenderPageBitmap_Start\n          Start to render page contents to a device independent bitmap\n          progressively.\n Parameters:\n          bitmap      -   Handle to the device independent bitmap (as the\n                          output buffer). Bitmap handle can be created by\n                          FPDFBitmap_Create().\n          page        -   Handle to the page, as returned by FPDF_LoadPage().\n          start_x     -   Left pixel position of the display area in the\n                          bitmap coordinates.\n          start_y     -   Top pixel position of the display area in the bitmap\n                          coordinates.\n          size_x      -   Horizontal size (in pixels) for displaying the page.\n          size_y      -   Vertical size (in pixels) for displaying the page.\n          rotate      -   Page orientation: 0 (normal), 1 (rotated 90 degrees\n                          clockwise), 2 (rotated 180 degrees), 3 (rotated 90\n                          degrees counter-clockwise).\n          flags       -   0 for normal display, or combination of flags\n                          defined in fpdfview.h. With FPDF_ANNOT flag, it\n                          renders all annotations that does not require\n                          user-interaction, which are all annotations except\n                          widget and popup annotations.\n          pause       -   The IFSDK_PAUSE interface.A callback mechanism\n                          allowing the page rendering process\n Return value:\n          Rendering Status. See flags for progressive process status for the\n          details."]
    pub fn FPDF_RenderPageBitmap_Start(
        bitmap: FPDF_BITMAP,
        page: FPDF_PAGE,
        start_x: ::std::os::raw::c_int,
        start_y: ::std::os::raw::c_int,
        size_x: ::std::os::raw::c_int,
        size_y: ::std::os::raw::c_int,
        rotate: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        pause: *mut IFSDK_PAUSE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDF_RenderPage_Continue\n          Continue rendering a PDF page.\n Parameters:\n          page        -   Handle to the page, as returned by FPDF_LoadPage().\n          pause       -   The IFSDK_PAUSE interface (a callback mechanism\n                          allowing the page rendering process to be paused\n                          before it's finished). This can be NULL if you\n                          don't want to pause.\n Return value:\n          The rendering status. See flags for progressive process status for\n          the details."]
    pub fn FPDF_RenderPage_Continue(
        page: FPDF_PAGE,
        pause: *mut IFSDK_PAUSE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDF_RenderPage_Close\n          Release the resource allocate during page rendering. Need to be\n          called after finishing rendering or\n          cancel the rendering.\n Parameters:\n          page        -   Handle to the page, as returned by FPDF_LoadPage().\n Return value:\n          None."]
    pub fn FPDF_RenderPage_Close(page: FPDF_PAGE);
}
#[doc = " Structure for custom file write"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_FILEWRITE_ {
    #[doc = "\n Version number of the interface. Currently must be 1.\n"]
    pub version: ::std::os::raw::c_int,
    #[doc = " Method: WriteBlock\n          Output a block of data in your custom way.\n Interface Version:\n          1\n Implementation Required:\n          Yes\n Comments:\n          Called by function FPDF_SaveDocument\n Parameters:\n          pThis       -   Pointer to the structure itself\n          pData       -   Pointer to a buffer to output\n          size        -   The size of the buffer.\n Return value:\n          Should be non-zero if successful, zero for error."]
    pub WriteBlock: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut FPDF_FILEWRITE_,
            pData: *const ::std::os::raw::c_void,
            size: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_FPDF_FILEWRITE_() {
    const UNINIT: ::std::mem::MaybeUninit<FPDF_FILEWRITE_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FPDF_FILEWRITE_>(),
        16usize,
        concat!("Size of: ", stringify!(FPDF_FILEWRITE_))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_FILEWRITE_>(),
        8usize,
        concat!("Alignment of ", stringify!(FPDF_FILEWRITE_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEWRITE_),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WriteBlock) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEWRITE_),
            "::",
            stringify!(WriteBlock)
        )
    );
}
#[doc = " Structure for custom file write"]
pub type FPDF_FILEWRITE = FPDF_FILEWRITE_;
extern "C" {
    #[doc = " Function: FPDF_SaveAsCopy\n          Saves the copy of specified document in custom way.\n Parameters:\n          document        -   Handle to document, as returned by\n                              FPDF_LoadDocument() or FPDF_CreateNewDocument().\n          pFileWrite      -   A pointer to a custom file write structure.\n          flags           -   The creating flags.\n Return value:\n          TRUE for succeed, FALSE for failed.\n"]
    pub fn FPDF_SaveAsCopy(
        document: FPDF_DOCUMENT,
        pFileWrite: *mut FPDF_FILEWRITE,
        flags: FPDF_DWORD,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDF_SaveWithVersion\n          Same as FPDF_SaveAsCopy(), except the file version of the\n          saved document can be specified by the caller.\n Parameters:\n          document        -   Handle to document.\n          pFileWrite      -   A pointer to a custom file write structure.\n          flags           -   The creating flags.\n          fileVersion     -   The PDF file version. File version: 14 for 1.4,\n                              15 for 1.5, ...\n Return value:\n          TRUE if succeed, FALSE if failed.\n"]
    pub fn FPDF_SaveWithVersion(
        document: FPDF_DOCUMENT,
        pFileWrite: *mut FPDF_FILEWRITE,
        flags: FPDF_DWORD,
        fileVersion: ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get the character index in |text_page| internal character list.\n\n   text_page  - a text page information structure.\n   nTextIndex - index of the text returned from FPDFText_GetText().\n\n Returns the index of the character in internal character list. -1 for error."]
    pub fn FPDFText_GetCharIndexFromTextIndex(
        text_page: FPDF_TEXTPAGE,
        nTextIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the text index in |text_page| internal character list.\n\n   text_page  - a text page information structure.\n   nCharIndex - index of the character in internal character list.\n\n Returns the index of the text returned from FPDFText_GetText(). -1 for error."]
    pub fn FPDFText_GetTextIndexFromCharIndex(
        text_page: FPDF_TEXTPAGE,
        nCharIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDF_GetSignatureCount\n          Get total number of signatures in the document.\n Parameters:\n          document    -   Handle to document. Returned by FPDF_LoadDocument().\n Return value:\n          Total number of signatures in the document on success, -1 on error."]
    pub fn FPDF_GetSignatureCount(document: FPDF_DOCUMENT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDF_GetSignatureObject\n          Get the Nth signature of the document.\n Parameters:\n          document    -   Handle to document. Returned by FPDF_LoadDocument().\n          index       -   Index into the array of signatures of the document.\n Return value:\n          Returns the handle to the signature, or NULL on failure. The caller\n          does not take ownership of the returned FPDF_SIGNATURE. Instead, it\n          remains valid until FPDF_CloseDocument() is called for the document."]
    pub fn FPDF_GetSignatureObject(
        document: FPDF_DOCUMENT,
        index: ::std::os::raw::c_int,
    ) -> FPDF_SIGNATURE;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDFSignatureObj_GetContents\n          Get the contents of a signature object.\n Parameters:\n          signature   -   Handle to the signature object. Returned by\n                          FPDF_GetSignatureObject().\n          buffer      -   The address of a buffer that receives the contents.\n          length      -   The size, in bytes, of |buffer|.\n Return value:\n          Returns the number of bytes in the contents on success, 0 on error.\n\n For public-key signatures, |buffer| is either a DER-encoded PKCS#1 binary or\n a DER-encoded PKCS#7 binary. If |length| is less than the returned length, or\n |buffer| is NULL, |buffer| will not be modified."]
    pub fn FPDFSignatureObj_GetContents(
        signature: FPDF_SIGNATURE,
        buffer: *mut ::std::os::raw::c_void,
        length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDFSignatureObj_GetByteRange\n          Get the byte range of a signature object.\n Parameters:\n          signature   -   Handle to the signature object. Returned by\n                          FPDF_GetSignatureObject().\n          buffer      -   The address of a buffer that receives the\n                          byte range.\n          length      -   The size, in ints, of |buffer|.\n Return value:\n          Returns the number of ints in the byte range on\n          success, 0 on error.\n\n |buffer| is an array of pairs of integers (starting byte offset,\n length in bytes) that describes the exact byte range for the digest\n calculation. If |length| is less than the returned length, or\n |buffer| is NULL, |buffer| will not be modified."]
    pub fn FPDFSignatureObj_GetByteRange(
        signature: FPDF_SIGNATURE,
        buffer: *mut ::std::os::raw::c_int,
        length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDFSignatureObj_GetSubFilter\n          Get the encoding of the value of a signature object.\n Parameters:\n          signature   -   Handle to the signature object. Returned by\n                          FPDF_GetSignatureObject().\n          buffer      -   The address of a buffer that receives the encoding.\n          length      -   The size, in bytes, of |buffer|.\n Return value:\n          Returns the number of bytes in the encoding name (including the\n          trailing NUL character) on success, 0 on error.\n\n The |buffer| is always encoded in 7-bit ASCII. If |length| is less than the\n returned length, or |buffer| is NULL, |buffer| will not be modified."]
    pub fn FPDFSignatureObj_GetSubFilter(
        signature: FPDF_SIGNATURE,
        buffer: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDFSignatureObj_GetReason\n          Get the reason (comment) of the signature object.\n Parameters:\n          signature   -   Handle to the signature object. Returned by\n                          FPDF_GetSignatureObject().\n          buffer      -   The address of a buffer that receives the reason.\n          length      -   The size, in bytes, of |buffer|.\n Return value:\n          Returns the number of bytes in the reason on success, 0 on error.\n\n Regardless of the platform, the |buffer| is always in UTF-16LE encoding. The\n string is terminated by a UTF16 NUL character. If |length| is less than the\n returned length, or |buffer| is NULL, |buffer| will not be modified."]
    pub fn FPDFSignatureObj_GetReason(
        signature: FPDF_SIGNATURE,
        buffer: *mut ::std::os::raw::c_void,
        length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDFSignatureObj_GetTime\n          Get the time of signing of a signature object.\n Parameters:\n          signature   -   Handle to the signature object. Returned by\n                          FPDF_GetSignatureObject().\n          buffer      -   The address of a buffer that receives the time.\n          length      -   The size, in bytes, of |buffer|.\n Return value:\n          Returns the number of bytes in the encoding name (including the\n          trailing NUL character) on success, 0 on error.\n\n The |buffer| is always encoded in 7-bit ASCII. If |length| is less than the\n returned length, or |buffer| is NULL, |buffer| will not be modified.\n\n The format of time is expected to be D:YYYYMMDDHHMMSS+XX'YY', i.e. it's\n percision is seconds, with timezone information. This value should be used\n only when the time of signing is not available in the (PKCS#7 binary)\n signature."]
    pub fn FPDFSignatureObj_GetTime(
        signature: FPDF_SIGNATURE,
        buffer: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDFSignatureObj_GetDocMDPPermission\n          Get the DocMDP permission of a signature object.\n Parameters:\n          signature   -   Handle to the signature object. Returned by\n                          FPDF_GetSignatureObject().\n Return value:\n          Returns the permission (1, 2 or 3) on success, 0 on error."]
    pub fn FPDFSignatureObj_GetDocMDPPermission(
        signature: FPDF_SIGNATURE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Function: FPDF_StructTree_GetForPage\n          Get the structure tree for a page.\n Parameters:\n          page        -   Handle to the page, as returned by FPDF_LoadPage().\n Return value:\n          A handle to the structure tree or NULL on error."]
    pub fn FPDF_StructTree_GetForPage(page: FPDF_PAGE) -> FPDF_STRUCTTREE;
}
extern "C" {
    #[doc = " Function: FPDF_StructTree_Close\n          Release a resource allocated by FPDF_StructTree_GetForPage().\n Parameters:\n          struct_tree -   Handle to the structure tree, as returned by\n                          FPDF_StructTree_LoadPage().\n Return value:\n          None."]
    pub fn FPDF_StructTree_Close(struct_tree: FPDF_STRUCTTREE);
}
extern "C" {
    #[doc = " Function: FPDF_StructTree_CountChildren\n          Count the number of children for the structure tree.\n Parameters:\n          struct_tree -   Handle to the structure tree, as returned by\n                          FPDF_StructTree_LoadPage().\n Return value:\n          The number of children, or -1 on error."]
    pub fn FPDF_StructTree_CountChildren(struct_tree: FPDF_STRUCTTREE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDF_StructTree_GetChildAtIndex\n          Get a child in the structure tree.\n Parameters:\n          struct_tree -   Handle to the structure tree, as returned by\n                          FPDF_StructTree_LoadPage().\n          index       -   The index for the child, 0-based.\n Return value:\n          The child at the n-th index or NULL on error."]
    pub fn FPDF_StructTree_GetChildAtIndex(
        struct_tree: FPDF_STRUCTTREE,
        index: ::std::os::raw::c_int,
    ) -> FPDF_STRUCTELEMENT;
}
extern "C" {
    #[doc = " Function: FPDF_StructElement_GetAltText\n          Get the alt text for a given element.\n Parameters:\n          struct_element -   Handle to the struct element.\n          buffer         -   A buffer for output the alt text. May be NULL.\n          buflen         -   The length of the buffer, in bytes. May be 0.\n Return value:\n          The number of bytes in the title, including the terminating NUL\n          character. The number of bytes is returned regardless of the\n          |buffer| and |buflen| parameters.\n Comments:\n          Regardless of the platform, the |buffer| is always in UTF-16LE\n          encoding. The string is terminated by a UTF16 NUL character. If\n          |buflen| is less than the required length, or |buffer| is NULL,\n          |buffer| will not be modified."]
    pub fn FPDF_StructElement_GetAltText(
        struct_element: FPDF_STRUCTELEMENT,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDF_StructElement_GetID\n          Get the ID for a given element.\n Parameters:\n          struct_element -   Handle to the struct element.\n          buffer         -   A buffer for output the ID string. May be NULL.\n          buflen         -   The length of the buffer, in bytes. May be 0.\n Return value:\n          The number of bytes in the ID string, including the terminating NUL\n          character. The number of bytes is returned regardless of the\n          |buffer| and |buflen| parameters.\n Comments:\n          Regardless of the platform, the |buffer| is always in UTF-16LE\n          encoding. The string is terminated by a UTF16 NUL character. If\n          |buflen| is less than the required length, or |buffer| is NULL,\n          |buffer| will not be modified."]
    pub fn FPDF_StructElement_GetID(
        struct_element: FPDF_STRUCTELEMENT,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDF_StructElement_GetLang\n          Get the case-insensitive IETF BCP 47 language code for an element.\n Parameters:\n          struct_element -   Handle to the struct element.\n          buffer         -   A buffer for output the lang string. May be NULL.\n          buflen         -   The length of the buffer, in bytes. May be 0.\n Return value:\n          The number of bytes in the ID string, including the terminating NUL\n          character. The number of bytes is returned regardless of the\n          |buffer| and |buflen| parameters.\n Comments:\n          Regardless of the platform, the |buffer| is always in UTF-16LE\n          encoding. The string is terminated by a UTF16 NUL character. If\n          |buflen| is less than the required length, or |buffer| is NULL,\n          |buffer| will not be modified."]
    pub fn FPDF_StructElement_GetLang(
        struct_element: FPDF_STRUCTELEMENT,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDF_StructElement_GetStringAttribute\n          Get a struct element attribute of type \"name\" or \"string\".\n Parameters:\n          struct_element -   Handle to the struct element.\n          attr_name      -   The name of the attribute to retrieve.\n          buffer         -   A buffer for output. May be NULL.\n          buflen         -   The length of the buffer, in bytes. May be 0.\n Return value:\n          The number of bytes in the attribute value, including the\n          terminating NUL character. The number of bytes is returned\n          regardless of the |buffer| and |buflen| parameters.\n Comments:\n          Regardless of the platform, the |buffer| is always in UTF-16LE\n          encoding. The string is terminated by a UTF16 NUL character. If\n          |buflen| is less than the required length, or |buffer| is NULL,\n          |buffer| will not be modified."]
    pub fn FPDF_StructElement_GetStringAttribute(
        struct_element: FPDF_STRUCTELEMENT,
        attr_name: FPDF_BYTESTRING,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Function: FPDF_StructElement_GetMarkedContentID\n          Get the marked content ID for a given element.\n Parameters:\n          struct_element -   Handle to the struct element.\n Return value:\n          The marked content ID of the element. If no ID exists, returns\n          -1."]
    pub fn FPDF_StructElement_GetMarkedContentID(
        struct_element: FPDF_STRUCTELEMENT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDF_StructElement_GetType\n           Get the type (/S) for a given element.\n Parameters:\n           struct_element - Handle to the struct element.\n           buffer        - A buffer for output. May be NULL.\n           buflen        - The length of the buffer, in bytes. May be 0.\n Return value:\n           The number of bytes in the type, including the terminating NUL\n           character. The number of bytes is returned regardless of the\n           |buffer| and |buflen| parameters.\n Comments:\n           Regardless of the platform, the |buffer| is always in UTF-16LE\n           encoding. The string is terminated by a UTF16 NUL character. If\n           |buflen| is less than the required length, or |buffer| is NULL,\n           |buffer| will not be modified."]
    pub fn FPDF_StructElement_GetType(
        struct_element: FPDF_STRUCTELEMENT,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Function: FPDF_StructElement_GetTitle\n           Get the title (/T) for a given element.\n Parameters:\n           struct_element - Handle to the struct element.\n           buffer         - A buffer for output. May be NULL.\n           buflen         - The length of the buffer, in bytes. May be 0.\n Return value:\n           The number of bytes in the title, including the terminating NUL\n           character. The number of bytes is returned regardless of the\n           |buffer| and |buflen| parameters.\n Comments:\n           Regardless of the platform, the |buffer| is always in UTF-16LE\n           encoding. The string is terminated by a UTF16 NUL character. If\n           |buflen| is less than the required length, or |buffer| is NULL,\n           |buffer| will not be modified."]
    pub fn FPDF_StructElement_GetTitle(
        struct_element: FPDF_STRUCTELEMENT,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Function: FPDF_StructElement_CountChildren\n          Count the number of children for the structure element.\n Parameters:\n          struct_element -   Handle to the struct element.\n Return value:\n          The number of children, or -1 on error."]
    pub fn FPDF_StructElement_CountChildren(
        struct_element: FPDF_STRUCTELEMENT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDF_StructElement_GetChildAtIndex\n          Get a child in the structure element.\n Parameters:\n          struct_tree -   Handle to the struct element.\n          index       -   The index for the child, 0-based.\n Return value:\n          The child at the n-th index or NULL on error.\n Comments:\n          If the child exists but is not an element, then this function will\n          return NULL. This will also return NULL for out of bounds indices."]
    pub fn FPDF_StructElement_GetChildAtIndex(
        struct_element: FPDF_STRUCTELEMENT,
        index: ::std::os::raw::c_int,
    ) -> FPDF_STRUCTELEMENT;
}
#[doc = " Interface: FPDF_SYSFONTINFO\n          Interface for getting system font information and font mapping"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FPDF_SYSFONTINFO {
    #[doc = " Version number of the interface. Currently must be 1."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Method: Release\n          Give implementation a chance to release any data after the\n          interface is no longer used.\n Interface Version:\n          1\n Implementation Required:\n          No\n Parameters:\n          pThis       -   Pointer to the interface structure itself\n Return Value:\n          None\n Comments:\n          Called by PDFium during the final cleanup process."]
    pub Release: ::std::option::Option<unsafe extern "C" fn(pThis: *mut _FPDF_SYSFONTINFO)>,
    #[doc = " Method: EnumFonts\n          Enumerate all fonts installed on the system\n Interface Version:\n          1\n Implementation Required:\n          No\n Parameters:\n          pThis       -   Pointer to the interface structure itself\n          pMapper     -   An opaque pointer to internal font mapper, used\n                          when calling FPDF_AddInstalledFont().\n Return Value:\n          None\n Comments:\n          Implementations should call FPDF_AddIntalledFont() function for\n          each font found. Only TrueType/OpenType and Type1 fonts are accepted\n          by PDFium."]
    pub EnumFonts: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FPDF_SYSFONTINFO, pMapper: *mut ::std::os::raw::c_void),
    >,
    #[doc = " Method: MapFont\n          Use the system font mapper to get a font handle from requested\n          parameters.\n Interface Version:\n          1\n Implementation Required:\n          Required if GetFont method is not implemented.\n Parameters:\n          pThis       -   Pointer to the interface structure itself\n          weight      -   Weight of the requested font. 400 is normal and\n                          700 is bold.\n          bItalic     -   Italic option of the requested font, TRUE or\n                          FALSE.\n          charset     -   Character set identifier for the requested font.\n                          See above defined constants.\n          pitch_family -  A combination of flags. See above defined\n                          constants.\n          face        -   Typeface name. Currently use system local encoding\n                          only.\n          bExact      -   Obsolete: this parameter is now ignored.\n Return Value:\n          An opaque pointer for font handle, or NULL if system mapping is\n          not supported.\n Comments:\n          If the system supports native font mapper (like Windows),\n          implementation can implement this method to get a font handle.\n          Otherwise, PDFium will do the mapping and then call GetFont\n          method. Only TrueType/OpenType and Type1 fonts are accepted\n          by PDFium."]
    pub MapFont: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_SYSFONTINFO,
            weight: ::std::os::raw::c_int,
            bItalic: FPDF_BOOL,
            charset: ::std::os::raw::c_int,
            pitch_family: ::std::os::raw::c_int,
            face: *const ::std::os::raw::c_char,
            bExact: *mut FPDF_BOOL,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Method: GetFont\n          Get a handle to a particular font by its internal ID\n Interface Version:\n          1\n Implementation Required:\n          Required if MapFont method is not implemented.\n Return Value:\n          An opaque pointer for font handle.\n Parameters:\n          pThis       -   Pointer to the interface structure itself\n          face        -   Typeface name in system local encoding.\n Comments:\n          If the system mapping not supported, PDFium will do the font\n          mapping and use this method to get a font handle."]
    pub GetFont: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_SYSFONTINFO,
            face: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Method: GetFontData\n          Get font data from a font\n Interface Version:\n          1\n Implementation Required:\n          Yes\n Parameters:\n          pThis       -   Pointer to the interface structure itself\n          hFont       -   Font handle returned by MapFont or GetFont method\n          table       -   TrueType/OpenType table identifier (refer to\n                          TrueType specification), or 0 for the whole file.\n          buffer      -   The buffer receiving the font data. Can be NULL if\n                          not provided.\n          buf_size    -   Buffer size, can be zero if not provided.\n Return Value:\n          Number of bytes needed, if buffer not provided or not large\n          enough, or number of bytes written into buffer otherwise.\n Comments:\n          Can read either the full font file, or a particular\n          TrueType/OpenType table."]
    pub GetFontData: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_SYSFONTINFO,
            hFont: *mut ::std::os::raw::c_void,
            table: ::std::os::raw::c_uint,
            buffer: *mut ::std::os::raw::c_uchar,
            buf_size: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_ulong,
    >,
    #[doc = " Method: GetFaceName\n          Get face name from a font handle\n Interface Version:\n          1\n Implementation Required:\n          No\n Parameters:\n          pThis       -   Pointer to the interface structure itself\n          hFont       -   Font handle returned by MapFont or GetFont method\n          buffer      -   The buffer receiving the face name. Can be NULL if\n                          not provided\n          buf_size    -   Buffer size, can be zero if not provided\n Return Value:\n          Number of bytes needed, if buffer not provided or not large\n          enough, or number of bytes written into buffer otherwise."]
    pub GetFaceName: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_SYSFONTINFO,
            hFont: *mut ::std::os::raw::c_void,
            buffer: *mut ::std::os::raw::c_char,
            buf_size: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_ulong,
    >,
    #[doc = " Method: GetFontCharset\n          Get character set information for a font handle\n Interface Version:\n          1\n Implementation Required:\n          No\n Parameters:\n          pThis       -   Pointer to the interface structure itself\n          hFont       -   Font handle returned by MapFont or GetFont method\n Return Value:\n          Character set identifier. See defined constants above."]
    pub GetFontCharset: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_SYSFONTINFO,
            hFont: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: DeleteFont\n          Delete a font handle\n Interface Version:\n          1\n Implementation Required:\n          Yes\n Parameters:\n          pThis       -   Pointer to the interface structure itself\n          hFont       -   Font handle returned by MapFont or GetFont method\n Return Value:\n          None"]
    pub DeleteFont: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FPDF_SYSFONTINFO, hFont: *mut ::std::os::raw::c_void),
    >,
}
#[test]
fn bindgen_test_layout__FPDF_SYSFONTINFO() {
    const UNINIT: ::std::mem::MaybeUninit<_FPDF_SYSFONTINFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FPDF_SYSFONTINFO>(),
        72usize,
        concat!("Size of: ", stringify!(_FPDF_SYSFONTINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_FPDF_SYSFONTINFO>(),
        8usize,
        concat!("Alignment of ", stringify!(_FPDF_SYSFONTINFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSFONTINFO),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Release) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSFONTINFO),
            "::",
            stringify!(Release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnumFonts) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSFONTINFO),
            "::",
            stringify!(EnumFonts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MapFont) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSFONTINFO),
            "::",
            stringify!(MapFont)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetFont) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSFONTINFO),
            "::",
            stringify!(GetFont)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetFontData) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSFONTINFO),
            "::",
            stringify!(GetFontData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetFaceName) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSFONTINFO),
            "::",
            stringify!(GetFaceName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetFontCharset) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSFONTINFO),
            "::",
            stringify!(GetFontCharset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DeleteFont) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSFONTINFO),
            "::",
            stringify!(DeleteFont)
        )
    );
}
#[doc = " Interface: FPDF_SYSFONTINFO\n          Interface for getting system font information and font mapping"]
pub type FPDF_SYSFONTINFO = _FPDF_SYSFONTINFO;
#[doc = " Struct: FPDF_CharsetFontMap\n    Provides the name of a font to use for a given charset value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_CharsetFontMap_ {
    #[doc = " Character Set Enum value, see FXFONT_*_CHARSET above."]
    pub charset: ::std::os::raw::c_int,
    #[doc = " Name of default font to use with that charset."]
    pub fontname: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_FPDF_CharsetFontMap_() {
    const UNINIT: ::std::mem::MaybeUninit<FPDF_CharsetFontMap_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FPDF_CharsetFontMap_>(),
        16usize,
        concat!("Size of: ", stringify!(FPDF_CharsetFontMap_))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_CharsetFontMap_>(),
        8usize,
        concat!("Alignment of ", stringify!(FPDF_CharsetFontMap_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).charset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_CharsetFontMap_),
            "::",
            stringify!(charset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fontname) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_CharsetFontMap_),
            "::",
            stringify!(fontname)
        )
    );
}
#[doc = " Struct: FPDF_CharsetFontMap\n    Provides the name of a font to use for a given charset value."]
pub type FPDF_CharsetFontMap = FPDF_CharsetFontMap_;
extern "C" {
    #[doc = " Function: FPDF_GetDefaultTTFMap\n    Returns a pointer to the default character set to TT Font name map. The\n    map is an array of FPDF_CharsetFontMap structs, with its end indicated\n    by a { -1, NULL } entry.\n Parameters:\n     None.\n Return Value:\n     Pointer to the Charset Font Map."]
    pub fn FPDF_GetDefaultTTFMap() -> *const FPDF_CharsetFontMap;
}
extern "C" {
    #[doc = " Function: FPDF_AddInstalledFont\n          Add a system font to the list in PDFium.\n Comments:\n          This function is only called during the system font list building\n          process.\n Parameters:\n          mapper          -   Opaque pointer to Foxit font mapper\n          face            -   The font face name\n          charset         -   Font character set. See above defined constants.\n Return Value:\n          None."]
    pub fn FPDF_AddInstalledFont(
        mapper: *mut ::std::os::raw::c_void,
        face: *const ::std::os::raw::c_char,
        charset: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Function: FPDF_SetSystemFontInfo\n          Set the system font info interface into PDFium\n Parameters:\n          pFontInfo       -   Pointer to a FPDF_SYSFONTINFO structure\n Return Value:\n          None\n Comments:\n          Platform support implementation should implement required methods of\n          FFDF_SYSFONTINFO interface, then call this function during PDFium\n          initialization process."]
    pub fn FPDF_SetSystemFontInfo(pFontInfo: *mut FPDF_SYSFONTINFO);
}
extern "C" {
    #[doc = " Function: FPDF_GetDefaultSystemFontInfo\n          Get default system font info interface for current platform\n Parameters:\n          None\n Return Value:\n          Pointer to a FPDF_SYSFONTINFO structure describing the default\n          interface, or NULL if the platform doesn't have a default interface.\n          Application should call FPDF_FreeDefaultSystemFontInfo to free the\n          returned pointer.\n Comments:\n          For some platforms, PDFium implements a default version of system\n          font info interface. The default implementation can be passed to\n          FPDF_SetSystemFontInfo()."]
    pub fn FPDF_GetDefaultSystemFontInfo() -> *mut FPDF_SYSFONTINFO;
}
extern "C" {
    #[doc = " Function: FPDF_FreeDefaultSystemFontInfo\n           Free a default system font info interface\n Parameters:\n           pFontInfo       -   Pointer to a FPDF_SYSFONTINFO structure\n Return Value:\n           None\n Comments:\n           This function should be called on the output from\n           FPDF_SetSystemFontInfo() once it is no longer needed."]
    pub fn FPDF_FreeDefaultSystemFontInfo(pFontInfo: *mut FPDF_SYSFONTINFO);
}
extern "C" {
    #[doc = " Function: FPDFText_LoadPage\n          Prepare information about all characters in a page.\n Parameters:\n          page    -   Handle to the page. Returned by FPDF_LoadPage function\n                      (in FPDFVIEW module).\n Return value:\n          A handle to the text page information structure.\n          NULL if something goes wrong.\n Comments:\n          Application must call FPDFText_ClosePage to release the text page\n          information.\n"]
    pub fn FPDFText_LoadPage(page: FPDF_PAGE) -> FPDF_TEXTPAGE;
}
extern "C" {
    #[doc = " Function: FPDFText_ClosePage\n          Release all resources allocated for a text page information\n          structure.\n Parameters:\n          text_page   -   Handle to a text page information structure.\n                          Returned by FPDFText_LoadPage function.\n Return Value:\n          None.\n"]
    pub fn FPDFText_ClosePage(text_page: FPDF_TEXTPAGE);
}
extern "C" {
    #[doc = " Function: FPDFText_CountChars\n          Get number of characters in a page.\n Parameters:\n          text_page   -   Handle to a text page information structure.\n                          Returned by FPDFText_LoadPage function.\n Return value:\n          Number of characters in the page. Return -1 for error.\n          Generated characters, like additional space characters, new line\n          characters, are also counted.\n Comments:\n          Characters in a page form a \"stream\", inside the stream, each\n          character has an index.\n          We will use the index parameters in many of FPDFTEXT functions. The\n          first character in the page\n          has an index value of zero.\n"]
    pub fn FPDFText_CountChars(text_page: FPDF_TEXTPAGE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDFText_GetUnicode\n          Get Unicode of a character in a page.\n Parameters:\n          text_page   -   Handle to a text page information structure.\n                          Returned by FPDFText_LoadPage function.\n          index       -   Zero-based index of the character.\n Return value:\n          The Unicode of the particular character.\n          If a character is not encoded in Unicode and Foxit engine can't\n          convert to Unicode,\n          the return value will be zero.\n"]
    pub fn FPDFText_GetUnicode(
        text_page: FPDF_TEXTPAGE,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Function: FPDFText_GetFontSize\n          Get the font size of a particular character.\n Parameters:\n          text_page   -   Handle to a text page information structure.\n                          Returned by FPDFText_LoadPage function.\n          index       -   Zero-based index of the character.\n Return value:\n          The font size of the particular character, measured in points (about\n          1/72 inch). This is the typographic size of the font (so called\n          \"em size\").\n"]
    pub fn FPDFText_GetFontSize(text_page: FPDF_TEXTPAGE, index: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDFText_GetFontInfo\n          Get the font name and flags of a particular character.\n Parameters:\n          text_page - Handle to a text page information structure.\n                      Returned by FPDFText_LoadPage function.\n          index     - Zero-based index of the character.\n          buffer    - A buffer receiving the font name.\n          buflen    - The length of |buffer| in bytes.\n          flags     - Optional pointer to an int receiving the font flags.\n                      These flags should be interpreted per PDF spec 1.7\n                      Section 5.7.1 Font Descriptor Flags.\n Return value:\n          On success, return the length of the font name, including the\n          trailing NUL character, in bytes. If this length is less than or\n          equal to |length|, |buffer| is set to the font name, |flags| is\n          set to the font flags. |buffer| is in UTF-8 encoding. Return 0 on\n          failure.\n"]
    pub fn FPDFText_GetFontInfo(
        text_page: FPDF_TEXTPAGE,
        index: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
        flags: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDFText_GetFontWeight\n          Get the font weight of a particular character.\n Parameters:\n          text_page   -   Handle to a text page information structure.\n                          Returned by FPDFText_LoadPage function.\n          index       -   Zero-based index of the character.\n Return value:\n          On success, return the font weight of the particular character. If\n          |text_page| is invalid, if |index| is out of bounds, or if the\n          character's text object is undefined, return -1.\n"]
    pub fn FPDFText_GetFontWeight(
        text_page: FPDF_TEXTPAGE,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDFText_GetTextRenderMode\n          Get text rendering mode of character.\n Parameters:\n          text_page   -   Handle to a text page information structure.\n                          Returned by FPDFText_LoadPage function.\n          index       -   Zero-based index of the character.\n Return Value:\n          On success, return the render mode value. A valid value is of type\n          FPDF_TEXT_RENDERMODE. If |text_page| is invalid, if |index| is out\n          of bounds, or if the text object is undefined, then return\n          FPDF_TEXTRENDERMODE_UNKNOWN.\n"]
    pub fn FPDFText_GetTextRenderMode(
        text_page: FPDF_TEXTPAGE,
        index: ::std::os::raw::c_int,
    ) -> FPDF_TEXT_RENDERMODE;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDFText_GetFillColor\n          Get the fill color of a particular character.\n Parameters:\n          text_page      -   Handle to a text page information structure.\n                             Returned by FPDFText_LoadPage function.\n          index          -   Zero-based index of the character.\n          R              -   Pointer to an unsigned int number receiving the\n                             red value of the fill color.\n          G              -   Pointer to an unsigned int number receiving the\n                             green value of the fill color.\n          B              -   Pointer to an unsigned int number receiving the\n                             blue value of the fill color.\n          A              -   Pointer to an unsigned int number receiving the\n                             alpha value of the fill color.\n Return value:\n          Whether the call succeeded. If false, |R|, |G|, |B| and |A| are\n          unchanged.\n"]
    pub fn FPDFText_GetFillColor(
        text_page: FPDF_TEXTPAGE,
        index: ::std::os::raw::c_int,
        R: *mut ::std::os::raw::c_uint,
        G: *mut ::std::os::raw::c_uint,
        B: *mut ::std::os::raw::c_uint,
        A: *mut ::std::os::raw::c_uint,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDFText_GetStrokeColor\n          Get the stroke color of a particular character.\n Parameters:\n          text_page      -   Handle to a text page information structure.\n                             Returned by FPDFText_LoadPage function.\n          index          -   Zero-based index of the character.\n          R              -   Pointer to an unsigned int number receiving the\n                             red value of the stroke color.\n          G              -   Pointer to an unsigned int number receiving the\n                             green value of the stroke color.\n          B              -   Pointer to an unsigned int number receiving the\n                             blue value of the stroke color.\n          A              -   Pointer to an unsigned int number receiving the\n                             alpha value of the stroke color.\n Return value:\n          Whether the call succeeded. If false, |R|, |G|, |B| and |A| are\n          unchanged.\n"]
    pub fn FPDFText_GetStrokeColor(
        text_page: FPDF_TEXTPAGE,
        index: ::std::os::raw::c_int,
        R: *mut ::std::os::raw::c_uint,
        G: *mut ::std::os::raw::c_uint,
        B: *mut ::std::os::raw::c_uint,
        A: *mut ::std::os::raw::c_uint,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDFText_GetCharAngle\n          Get character rotation angle.\n Parameters:\n          text_page   -   Handle to a text page information structure.\n                          Returned by FPDFText_LoadPage function.\n          index       -   Zero-based index of the character.\n Return Value:\n          On success, return the angle value in radian. Value will always be\n          greater or equal to 0. If |text_page| is invalid, or if |index| is\n          out of bounds, then return -1.\n"]
    pub fn FPDFText_GetCharAngle(text_page: FPDF_TEXTPAGE, index: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    #[doc = " Function: FPDFText_GetCharBox\n          Get bounding box of a particular character.\n Parameters:\n          text_page   -   Handle to a text page information structure.\n                          Returned by FPDFText_LoadPage function.\n          index       -   Zero-based index of the character.\n          left        -   Pointer to a double number receiving left position\n                          of the character box.\n          right       -   Pointer to a double number receiving right position\n                          of the character box.\n          bottom      -   Pointer to a double number receiving bottom position\n                          of the character box.\n          top         -   Pointer to a double number receiving top position of\n                          the character box.\n Return Value:\n          On success, return TRUE and fill in |left|, |right|, |bottom|, and\n          |top|. If |text_page| is invalid, or if |index| is out of bounds,\n          then return FALSE, and the out parameters remain unmodified.\n Comments:\n          All positions are measured in PDF \"user space\".\n"]
    pub fn FPDFText_GetCharBox(
        text_page: FPDF_TEXTPAGE,
        index: ::std::os::raw::c_int,
        left: *mut f64,
        right: *mut f64,
        bottom: *mut f64,
        top: *mut f64,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDFText_GetLooseCharBox\n          Get a \"loose\" bounding box of a particular character, i.e., covering\n          the entire glyph bounds, without taking the actual glyph shape into\n          account.\n Parameters:\n          text_page   -   Handle to a text page information structure.\n                          Returned by FPDFText_LoadPage function.\n          index       -   Zero-based index of the character.\n          rect        -   Pointer to a FS_RECTF receiving the character box.\n Return Value:\n          On success, return TRUE and fill in |rect|. If |text_page| is\n          invalid, or if |index| is out of bounds, then return FALSE, and the\n          |rect| out parameter remains unmodified.\n Comments:\n          All positions are measured in PDF \"user space\".\n"]
    pub fn FPDFText_GetLooseCharBox(
        text_page: FPDF_TEXTPAGE,
        index: ::std::os::raw::c_int,
        rect: *mut FS_RECTF,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDFText_GetMatrix\n          Get the effective transformation matrix for a particular character.\n Parameters:\n          text_page   -   Handle to a text page information structure.\n                          Returned by FPDFText_LoadPage().\n          index       -   Zero-based index of the character.\n          matrix      -   Pointer to a FS_MATRIX receiving the transformation\n                          matrix.\n Return Value:\n          On success, return TRUE and fill in |matrix|. If |text_page| is\n          invalid, or if |index| is out of bounds, or if |matrix| is NULL,\n          then return FALSE, and |matrix| remains unmodified.\n"]
    pub fn FPDFText_GetMatrix(
        text_page: FPDF_TEXTPAGE,
        index: ::std::os::raw::c_int,
        matrix: *mut FS_MATRIX,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDFText_GetCharOrigin\n          Get origin of a particular character.\n Parameters:\n          text_page   -   Handle to a text page information structure.\n                          Returned by FPDFText_LoadPage function.\n          index       -   Zero-based index of the character.\n          x           -   Pointer to a double number receiving x coordinate of\n                          the character origin.\n          y           -   Pointer to a double number receiving y coordinate of\n                          the character origin.\n Return Value:\n          Whether the call succeeded. If false, x and y are unchanged.\n Comments:\n          All positions are measured in PDF \"user space\".\n"]
    pub fn FPDFText_GetCharOrigin(
        text_page: FPDF_TEXTPAGE,
        index: ::std::os::raw::c_int,
        x: *mut f64,
        y: *mut f64,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDFText_GetCharIndexAtPos\n          Get the index of a character at or nearby a certain position on the\n          page.\n Parameters:\n          text_page   -   Handle to a text page information structure.\n                          Returned by FPDFText_LoadPage function.\n          x           -   X position in PDF \"user space\".\n          y           -   Y position in PDF \"user space\".\n          xTolerance  -   An x-axis tolerance value for character hit\n                          detection, in point units.\n          yTolerance  -   A y-axis tolerance value for character hit\n                          detection, in point units.\n Return Value:\n          The zero-based index of the character at, or nearby the point (x,y).\n          If there is no character at or nearby the point, return value will\n          be -1. If an error occurs, -3 will be returned.\n"]
    pub fn FPDFText_GetCharIndexAtPos(
        text_page: FPDF_TEXTPAGE,
        x: f64,
        y: f64,
        xTolerance: f64,
        yTolerance: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDFText_GetText\n          Extract unicode text string from the page.\n Parameters:\n          text_page   -   Handle to a text page information structure.\n                          Returned by FPDFText_LoadPage function.\n          start_index -   Index for the start characters.\n          count       -   Number of characters to be extracted.\n          result      -   A buffer (allocated by application) receiving the\n                          extracted unicodes. The size of the buffer must be\n                          able to hold the number of characters plus a\n                          terminator.\n Return Value:\n          Number of characters written into the result buffer, including the\n          trailing terminator.\n Comments:\n          This function ignores characters without unicode information.\n"]
    pub fn FPDFText_GetText(
        text_page: FPDF_TEXTPAGE,
        start_index: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDFText_CountRects\n          Count number of rectangular areas occupied by a segment of texts.\n Parameters:\n          text_page   -   Handle to a text page information structure.\n                          Returned by FPDFText_LoadPage function.\n          start_index -   Index for the start characters.\n          count       -   Number of characters.\n Return value:\n          Number of rectangles. Zero for error.\n Comments:\n          This function, along with FPDFText_GetRect can be used by\n          applications to detect the position on the page for a text segment,\n          so proper areas can be highlighted. FPDFTEXT will automatically\n          merge small character boxes into bigger one if those characters\n          are on the same line and use same font settings.\n"]
    pub fn FPDFText_CountRects(
        text_page: FPDF_TEXTPAGE,
        start_index: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDFText_GetRect\n          Get a rectangular area from the result generated by\n          FPDFText_CountRects.\n Parameters:\n          text_page   -   Handle to a text page information structure.\n                          Returned by FPDFText_LoadPage function.\n          rect_index  -   Zero-based index for the rectangle.\n          left        -   Pointer to a double value receiving the rectangle\n                          left boundary.\n          top         -   Pointer to a double value receiving the rectangle\n                          top boundary.\n          right       -   Pointer to a double value receiving the rectangle\n                          right boundary.\n          bottom      -   Pointer to a double value receiving the rectangle\n                          bottom boundary.\n Return Value:\n          On success, return TRUE and fill in |left|, |top|, |right|, and\n          |bottom|. If |text_page| is invalid then return FALSE, and the out\n          parameters remain unmodified. If |text_page| is valid but\n          |rect_index| is out of bounds, then return FALSE and set the out\n          parameters to 0.\n"]
    pub fn FPDFText_GetRect(
        text_page: FPDF_TEXTPAGE,
        rect_index: ::std::os::raw::c_int,
        left: *mut f64,
        top: *mut f64,
        right: *mut f64,
        bottom: *mut f64,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDFText_GetBoundedText\n          Extract unicode text within a rectangular boundary on the page.\n Parameters:\n          text_page   -   Handle to a text page information structure.\n                          Returned by FPDFText_LoadPage function.\n          left        -   Left boundary.\n          top         -   Top boundary.\n          right       -   Right boundary.\n          bottom      -   Bottom boundary.\n          buffer      -   A unicode buffer.\n          buflen      -   Number of characters (not bytes) for the buffer,\n                          excluding an additional terminator.\n Return Value:\n          If buffer is NULL or buflen is zero, return number of characters\n          (not bytes) of text present within the rectangle, excluding a\n          terminating NUL. Generally you should pass a buffer at least one\n          larger than this if you want a terminating NUL, which will be\n          provided if space is available. Otherwise, return number of\n          characters copied into the buffer, including the terminating NUL\n          when space for it is available.\n Comment:\n          If the buffer is too small, as much text as will fit is copied into\n          it.\n"]
    pub fn FPDFText_GetBoundedText(
        text_page: FPDF_TEXTPAGE,
        left: f64,
        top: f64,
        right: f64,
        bottom: f64,
        buffer: *mut ::std::os::raw::c_ushort,
        buflen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDFText_FindStart\n          Start a search.\n Parameters:\n          text_page   -   Handle to a text page information structure.\n                          Returned by FPDFText_LoadPage function.\n          findwhat    -   A unicode match pattern.\n          flags       -   Option flags.\n          start_index -   Start from this character. -1 for end of the page.\n Return Value:\n          A handle for the search context. FPDFText_FindClose must be called\n          to release this handle.\n"]
    pub fn FPDFText_FindStart(
        text_page: FPDF_TEXTPAGE,
        findwhat: FPDF_WIDESTRING,
        flags: ::std::os::raw::c_ulong,
        start_index: ::std::os::raw::c_int,
    ) -> FPDF_SCHHANDLE;
}
extern "C" {
    #[doc = " Function: FPDFText_FindNext\n          Search in the direction from page start to end.\n Parameters:\n          handle      -   A search context handle returned by\n                          FPDFText_FindStart.\n Return Value:\n          Whether a match is found.\n"]
    pub fn FPDFText_FindNext(handle: FPDF_SCHHANDLE) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDFText_FindPrev\n          Search in the direction from page end to start.\n Parameters:\n          handle      -   A search context handle returned by\n                          FPDFText_FindStart.\n Return Value:\n          Whether a match is found.\n"]
    pub fn FPDFText_FindPrev(handle: FPDF_SCHHANDLE) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDFText_GetSchResultIndex\n          Get the starting character index of the search result.\n Parameters:\n          handle      -   A search context handle returned by\n                          FPDFText_FindStart.\n Return Value:\n          Index for the starting character.\n"]
    pub fn FPDFText_GetSchResultIndex(handle: FPDF_SCHHANDLE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDFText_GetSchCount\n          Get the number of matched characters in the search result.\n Parameters:\n          handle      -   A search context handle returned by\n                          FPDFText_FindStart.\n Return Value:\n          Number of matched characters.\n"]
    pub fn FPDFText_GetSchCount(handle: FPDF_SCHHANDLE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDFText_FindClose\n          Release a search context.\n Parameters:\n          handle      -   A search context handle returned by\n                          FPDFText_FindStart.\n Return Value:\n          None.\n"]
    pub fn FPDFText_FindClose(handle: FPDF_SCHHANDLE);
}
extern "C" {
    #[doc = " Function: FPDFLink_LoadWebLinks\n          Prepare information about weblinks in a page.\n Parameters:\n          text_page   -   Handle to a text page information structure.\n                          Returned by FPDFText_LoadPage function.\n Return Value:\n          A handle to the page's links information structure, or\n          NULL if something goes wrong.\n Comments:\n          Weblinks are those links implicitly embedded in PDF pages. PDF also\n          has a type of annotation called \"link\" (FPDFTEXT doesn't deal with\n          that kind of link). FPDFTEXT weblink feature is useful for\n          automatically detecting links in the page contents. For example,\n          things like \"https://www.example.com\" will be detected, so\n          applications can allow user to click on those characters to activate\n          the link, even the PDF doesn't come with link annotations.\n\n          FPDFLink_CloseWebLinks must be called to release resources.\n"]
    pub fn FPDFLink_LoadWebLinks(text_page: FPDF_TEXTPAGE) -> FPDF_PAGELINK;
}
extern "C" {
    #[doc = " Function: FPDFLink_CountWebLinks\n          Count number of detected web links.\n Parameters:\n          link_page   -   Handle returned by FPDFLink_LoadWebLinks.\n Return Value:\n          Number of detected web links.\n"]
    pub fn FPDFLink_CountWebLinks(link_page: FPDF_PAGELINK) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDFLink_GetURL\n          Fetch the URL information for a detected web link.\n Parameters:\n          link_page   -   Handle returned by FPDFLink_LoadWebLinks.\n          link_index  -   Zero-based index for the link.\n          buffer      -   A unicode buffer for the result.\n          buflen      -   Number of 16-bit code units (not bytes) for the\n                          buffer, including an additional terminator.\n Return Value:\n          If |buffer| is NULL or |buflen| is zero, return the number of 16-bit\n          code units (not bytes) needed to buffer the result (an additional\n          terminator is included in this count).\n          Otherwise, copy the result into |buffer|, truncating at |buflen| if\n          the result is too large to fit, and return the number of 16-bit code\n          units actually copied into the buffer (the additional terminator is\n          also included in this count).\n          If |link_index| does not correspond to a valid link, then the result\n          is an empty string.\n"]
    pub fn FPDFLink_GetURL(
        link_page: FPDF_PAGELINK,
        link_index: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_ushort,
        buflen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDFLink_CountRects\n          Count number of rectangular areas for the link.\n Parameters:\n          link_page   -   Handle returned by FPDFLink_LoadWebLinks.\n          link_index  -   Zero-based index for the link.\n Return Value:\n          Number of rectangular areas for the link.  If |link_index| does\n          not correspond to a valid link, then 0 is returned.\n"]
    pub fn FPDFLink_CountRects(
        link_page: FPDF_PAGELINK,
        link_index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDFLink_GetRect\n          Fetch the boundaries of a rectangle for a link.\n Parameters:\n          link_page   -   Handle returned by FPDFLink_LoadWebLinks.\n          link_index  -   Zero-based index for the link.\n          rect_index  -   Zero-based index for a rectangle.\n          left        -   Pointer to a double value receiving the rectangle\n                          left boundary.\n          top         -   Pointer to a double value receiving the rectangle\n                          top boundary.\n          right       -   Pointer to a double value receiving the rectangle\n                          right boundary.\n          bottom      -   Pointer to a double value receiving the rectangle\n                          bottom boundary.\n Return Value:\n          On success, return TRUE and fill in |left|, |top|, |right|, and\n          |bottom|. If |link_page| is invalid or if |link_index| does not\n          correspond to a valid link, then return FALSE, and the out\n          parameters remain unmodified.\n"]
    pub fn FPDFLink_GetRect(
        link_page: FPDF_PAGELINK,
        link_index: ::std::os::raw::c_int,
        rect_index: ::std::os::raw::c_int,
        left: *mut f64,
        top: *mut f64,
        right: *mut f64,
        bottom: *mut f64,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API.\n Function: FPDFLink_GetTextRange\n          Fetch the start char index and char count for a link.\n Parameters:\n          link_page         -   Handle returned by FPDFLink_LoadWebLinks.\n          link_index        -   Zero-based index for the link.\n          start_char_index  -   pointer to int receiving the start char index\n          char_count        -   pointer to int receiving the char count\n Return Value:\n          On success, return TRUE and fill in |start_char_index| and\n          |char_count|. if |link_page| is invalid or if |link_index| does\n          not correspond to a valid link, then return FALSE and the out\n          parameters remain unmodified.\n"]
    pub fn FPDFLink_GetTextRange(
        link_page: FPDF_PAGELINK,
        link_index: ::std::os::raw::c_int,
        start_char_index: *mut ::std::os::raw::c_int,
        char_count: *mut ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDFLink_CloseWebLinks\n          Release resources used by weblink feature.\n Parameters:\n          link_page   -   Handle returned by FPDFLink_LoadWebLinks.\n Return Value:\n          None.\n"]
    pub fn FPDFLink_CloseWebLinks(link_page: FPDF_PAGELINK);
}
extern "C" {
    #[doc = " Experimental API.\n Gets the decoded data from the thumbnail of |page| if it exists.\n This only modifies |buffer| if |buflen| less than or equal to the\n size of the decoded data. Returns the size of the decoded\n data or 0 if thumbnail DNE. Optional, pass null to just retrieve\n the size of the buffer needed.\n\n   page    - handle to a page.\n   buffer  - buffer for holding the decoded image data.\n   buflen  - length of the buffer in bytes."]
    pub fn FPDFPage_GetDecodedThumbnailData(
        page: FPDF_PAGE,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Gets the raw data from the thumbnail of |page| if it exists.\n This only modifies |buffer| if |buflen| is less than or equal to\n the size of the raw data. Returns the size of the raw data or 0\n if thumbnail DNE. Optional, pass null to just retrieve the size\n of the buffer needed.\n\n   page    - handle to a page.\n   buffer  - buffer for holding the raw image data.\n   buflen  - length of the buffer in bytes."]
    pub fn FPDFPage_GetRawThumbnailData(
        page: FPDF_PAGE,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API.\n Returns the thumbnail of |page| as a FPDF_BITMAP. Returns a nullptr\n if unable to access the thumbnail's stream.\n\n   page - handle to a page."]
    pub fn FPDFPage_GetThumbnailAsBitmap(page: FPDF_PAGE) -> FPDF_BITMAP;
}
extern "C" {
    #[doc = " Set \"MediaBox\" entry to the page dictionary.\n\n page   - Handle to a page.\n left   - The left of the rectangle.\n bottom - The bottom of the rectangle.\n right  - The right of the rectangle.\n top    - The top of the rectangle."]
    pub fn FPDFPage_SetMediaBox(page: FPDF_PAGE, left: f32, bottom: f32, right: f32, top: f32);
}
extern "C" {
    #[doc = " Set \"CropBox\" entry to the page dictionary.\n\n page   - Handle to a page.\n left   - The left of the rectangle.\n bottom - The bottom of the rectangle.\n right  - The right of the rectangle.\n top    - The top of the rectangle."]
    pub fn FPDFPage_SetCropBox(page: FPDF_PAGE, left: f32, bottom: f32, right: f32, top: f32);
}
extern "C" {
    #[doc = " Set \"BleedBox\" entry to the page dictionary.\n\n page   - Handle to a page.\n left   - The left of the rectangle.\n bottom - The bottom of the rectangle.\n right  - The right of the rectangle.\n top    - The top of the rectangle."]
    pub fn FPDFPage_SetBleedBox(page: FPDF_PAGE, left: f32, bottom: f32, right: f32, top: f32);
}
extern "C" {
    #[doc = " Set \"TrimBox\" entry to the page dictionary.\n\n page   - Handle to a page.\n left   - The left of the rectangle.\n bottom - The bottom of the rectangle.\n right  - The right of the rectangle.\n top    - The top of the rectangle."]
    pub fn FPDFPage_SetTrimBox(page: FPDF_PAGE, left: f32, bottom: f32, right: f32, top: f32);
}
extern "C" {
    #[doc = " Set \"ArtBox\" entry to the page dictionary.\n\n page   - Handle to a page.\n left   - The left of the rectangle.\n bottom - The bottom of the rectangle.\n right  - The right of the rectangle.\n top    - The top of the rectangle."]
    pub fn FPDFPage_SetArtBox(page: FPDF_PAGE, left: f32, bottom: f32, right: f32, top: f32);
}
extern "C" {
    #[doc = " Get \"MediaBox\" entry from the page dictionary.\n\n page   - Handle to a page.\n left   - Pointer to a float value receiving the left of the rectangle.\n bottom - Pointer to a float value receiving the bottom of the rectangle.\n right  - Pointer to a float value receiving the right of the rectangle.\n top    - Pointer to a float value receiving the top of the rectangle.\n\n On success, return true and write to the out parameters. Otherwise return\n false and leave the out parameters unmodified."]
    pub fn FPDFPage_GetMediaBox(
        page: FPDF_PAGE,
        left: *mut f32,
        bottom: *mut f32,
        right: *mut f32,
        top: *mut f32,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get \"CropBox\" entry from the page dictionary.\n\n page   - Handle to a page.\n left   - Pointer to a float value receiving the left of the rectangle.\n bottom - Pointer to a float value receiving the bottom of the rectangle.\n right  - Pointer to a float value receiving the right of the rectangle.\n top    - Pointer to a float value receiving the top of the rectangle.\n\n On success, return true and write to the out parameters. Otherwise return\n false and leave the out parameters unmodified."]
    pub fn FPDFPage_GetCropBox(
        page: FPDF_PAGE,
        left: *mut f32,
        bottom: *mut f32,
        right: *mut f32,
        top: *mut f32,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get \"BleedBox\" entry from the page dictionary.\n\n page   - Handle to a page.\n left   - Pointer to a float value receiving the left of the rectangle.\n bottom - Pointer to a float value receiving the bottom of the rectangle.\n right  - Pointer to a float value receiving the right of the rectangle.\n top    - Pointer to a float value receiving the top of the rectangle.\n\n On success, return true and write to the out parameters. Otherwise return\n false and leave the out parameters unmodified."]
    pub fn FPDFPage_GetBleedBox(
        page: FPDF_PAGE,
        left: *mut f32,
        bottom: *mut f32,
        right: *mut f32,
        top: *mut f32,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get \"TrimBox\" entry from the page dictionary.\n\n page   - Handle to a page.\n left   - Pointer to a float value receiving the left of the rectangle.\n bottom - Pointer to a float value receiving the bottom of the rectangle.\n right  - Pointer to a float value receiving the right of the rectangle.\n top    - Pointer to a float value receiving the top of the rectangle.\n\n On success, return true and write to the out parameters. Otherwise return\n false and leave the out parameters unmodified."]
    pub fn FPDFPage_GetTrimBox(
        page: FPDF_PAGE,
        left: *mut f32,
        bottom: *mut f32,
        right: *mut f32,
        top: *mut f32,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Get \"ArtBox\" entry from the page dictionary.\n\n page   - Handle to a page.\n left   - Pointer to a float value receiving the left of the rectangle.\n bottom - Pointer to a float value receiving the bottom of the rectangle.\n right  - Pointer to a float value receiving the right of the rectangle.\n top    - Pointer to a float value receiving the top of the rectangle.\n\n On success, return true and write to the out parameters. Otherwise return\n false and leave the out parameters unmodified."]
    pub fn FPDFPage_GetArtBox(
        page: FPDF_PAGE,
        left: *mut f32,
        bottom: *mut f32,
        right: *mut f32,
        top: *mut f32,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Apply transforms to |page|.\n\n If |matrix| is provided it will be applied to transform the page.\n If |clipRect| is provided it will be used to clip the resulting page.\n If neither |matrix| or |clipRect| are provided this method returns |false|.\n Returns |true| if transforms are applied.\n\n This function will transform the whole page, and would take effect to all the\n objects in the page.\n\n page        - Page handle.\n matrix      - Transform matrix.\n clipRect    - Clipping rectangle."]
    pub fn FPDFPage_TransFormWithClip(
        page: FPDF_PAGE,
        matrix: *const FS_MATRIX,
        clipRect: *const FS_RECTF,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Transform (scale, rotate, shear, move) the clip path of page object.\n page_object - Handle to a page object. Returned by\n FPDFPageObj_NewImageObj().\n\n a  - The coefficient \"a\" of the matrix.\n b  - The coefficient \"b\" of the matrix.\n c  - The coefficient \"c\" of the matrix.\n d  - The coefficient \"d\" of the matrix.\n e  - The coefficient \"e\" of the matrix.\n f  - The coefficient \"f\" of the matrix."]
    pub fn FPDFPageObj_TransformClipPath(
        page_object: FPDF_PAGEOBJECT,
        a: f64,
        b: f64,
        c: f64,
        d: f64,
        e: f64,
        f: f64,
    );
}
extern "C" {
    #[doc = " Experimental API.\n Get the clip path of the page object.\n\n   page object - Handle to a page object. Returned by e.g.\n                 FPDFPage_GetObject().\n\n Returns the handle to the clip path, or NULL on failure. The caller does not\n take ownership of the returned FPDF_CLIPPATH. Instead, it remains valid until\n FPDF_ClosePage() is called for the page containing |page_object|."]
    pub fn FPDFPageObj_GetClipPath(page_object: FPDF_PAGEOBJECT) -> FPDF_CLIPPATH;
}
extern "C" {
    #[doc = " Experimental API.\n Get number of paths inside |clip_path|.\n\n   clip_path - handle to a clip_path.\n\n Returns the number of objects in |clip_path| or -1 on failure."]
    pub fn FPDFClipPath_CountPaths(clip_path: FPDF_CLIPPATH) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Get number of segments inside one path of |clip_path|.\n\n   clip_path  - handle to a clip_path.\n   path_index - index into the array of paths of the clip path.\n\n Returns the number of segments or -1 on failure."]
    pub fn FPDFClipPath_CountPathSegments(
        clip_path: FPDF_CLIPPATH,
        path_index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API.\n Get segment in one specific path of |clip_path| at index.\n\n   clip_path     - handle to a clip_path.\n   path_index    - the index of a path.\n   segment_index - the index of a segment.\n\n Returns the handle to the segment, or NULL on failure. The caller does not\n take ownership of the returned FPDF_PATHSEGMENT. Instead, it remains valid\n until FPDF_ClosePage() is called for the page containing |clip_path|."]
    pub fn FPDFClipPath_GetPathSegment(
        clip_path: FPDF_CLIPPATH,
        path_index: ::std::os::raw::c_int,
        segment_index: ::std::os::raw::c_int,
    ) -> FPDF_PATHSEGMENT;
}
extern "C" {
    #[doc = " Create a new clip path, with a rectangle inserted.\n\n Caller takes ownership of the returned FPDF_CLIPPATH. It should be freed with\n FPDF_DestroyClipPath().\n\n left   - The left of the clip box.\n bottom - The bottom of the clip box.\n right  - The right of the clip box.\n top    - The top of the clip box."]
    pub fn FPDF_CreateClipPath(left: f32, bottom: f32, right: f32, top: f32) -> FPDF_CLIPPATH;
}
extern "C" {
    #[doc = " Destroy the clip path.\n\n clipPath - A handle to the clip path. It will be invalid after this call."]
    pub fn FPDF_DestroyClipPath(clipPath: FPDF_CLIPPATH);
}
extern "C" {
    #[doc = " Clip the page content, the page content that outside the clipping region\n become invisible.\n\n A clip path will be inserted before the page content stream or content array.\n In this way, the page content will be clipped by this clip path.\n\n page        - A page handle.\n clipPath    - A handle to the clip path. (Does not take ownership.)"]
    pub fn FPDFPage_InsertClipPath(page: FPDF_PAGE, clipPath: FPDF_CLIPPATH);
}
